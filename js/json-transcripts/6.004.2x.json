{"C03S01B05-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s1/5?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s1v5", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "The Beta is an example of a reduced-instruction-set computer (RISC) architecture."}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:13", "is_worked_example": false, "text": "\"Reduced\" refers to the fact that in the Beta ISA, most instructions only access the internal registers for their operands and destination."}, {"start": "00:00:13", "is_lecture": true, "end": "00:00:22", "is_worked_example": false, "text": "Memory values are loaded and stored using separate memory-access instructions, which implement only a simple address calculation."}, {"start": "00:00:22", "is_lecture": true, "end": "00:00:30", "is_worked_example": false, "text": "These reductions lead to smaller, higher-performance hardware implementations and simpler compilers on the software side."}, {"start": "00:00:30", "is_lecture": true, "end": "00:00:34", "is_worked_example": false, "text": "The ARM and MIPS ISAs are other examples of RISC architectures."}, {"start": "00:00:34", "is_lecture": true, "end": "00:00:38", "is_worked_example": false, "text": "Intel's x86 ISA is more complex."}, {"start": "00:00:38", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "There is a limited amount of storage inside of the CPU -- using the language of sequential logic, we'll refer to this as the CPU state."}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:55", "is_worked_example": false, "text": "There's a 32-bit program counter (PC for short) that holds the address of the current instruction in main memory."}, {"start": "00:00:55", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "And there are thirty-two registers, numbered 0 through 31."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "Each register holds a 32-bit value."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "We'll use use 5-bit fields in the instruction to specify the number of the register to be used an operand or destination."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:23", "is_worked_example": false, "text": "As shorthand, we'll refer to a register using the prefix \"R\" followed by its number, e.g., \"R0\" refers to the register selected by the 5-bit field 0b00000."}, {"start": "00:01:23", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "Register 31 (R31) is special -- its value always reads as 0 and writes to R31 have no affect on its value."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "The number of bits in each register and hence the number of bits supported by ALU operations is a fundamental parameter of the ISA."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:45", "is_worked_example": false, "text": "The Beta is a 32-bit architecture."}, {"start": "00:01:45", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "Many modern computers are 64-bit architectures, meaning they have 64-bit registers and a 64-bit datapath."}, {"start": "00:01:53", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "Main memory is an array of 32-bit words."}, {"start": "00:01:56", "is_lecture": true, "end": "00:01:59", "is_worked_example": false, "text": "Each word contains four 8-bit bytes."}, {"start": "00:01:59", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "The bytes are numbered 0 through 3, with byte 0 corresponding to the low-order 7 bits of the 32-bit value, and so on."}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:14", "is_worked_example": false, "text": "The Beta ISA only supports word accesses, either loading or storing full 32-bit words."}, {"start": "00:02:14", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "Most \"real\" computers also support accesses to bytes and half-words."}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:28", "is_worked_example": false, "text": "Even though the Beta only accesses full words, following a convention used by many ISAs it uses byte addresses."}, {"start": "00:02:28", "is_lecture": true, "end": "00:02:35", "is_worked_example": false, "text": "Since there are 4 bytes in each word, consecutive words in memory have addresses that differ by 4."}, {"start": "00:02:35", "is_lecture": true, "end": "00:02:41", "is_worked_example": false, "text": "So the first word in memory has address 0, the second word address 4, and so on."}, {"start": "00:02:41", "is_lecture": true, "end": "00:02:46", "is_worked_example": false, "text": "You can see the addresses to left of each memory location in the diagram shown here."}, {"start": "00:02:46", "is_lecture": true, "end": "00:02:56", "is_worked_example": false, "text": "Note that we'll usually use hexadecimal notation when specifying addresses and other binary values -- the \"0x\" prefix indicates when a number is in hex."}, {"start": "00:02:56", "is_lecture": true, "end": "00:03:03", "is_worked_example": false, "text": "When drawing a memory diagram, we'll follow the convention that addresses increase as you read from top to bottom."}, {"start": "00:03:03", "is_lecture": true, "end": "00:03:11", "is_worked_example": false, "text": "The Beta ISA supports 32-bit byte addressing, so an address fits exactly into one 32-bit register or memory location."}, {"start": "00:03:11", "is_lecture": true, "end": "00:03:21", "is_worked_example": false, "text": "The maximum memory size is 2^32 bytes or 2^30 words -- that's 4 gigabytes (4 GB) or one billion words of main memory."}, {"start": "00:03:21", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "Some Beta implementations might actually have a smaller main memory, i.e., one with fewer than 1 billion locations."}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:32", "is_worked_example": false, "text": "Why have separate registers and main memory?"}, {"start": "00:03:32", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "Well, modern programs and datasets are very large, so we'll want to have a large main memory to hold everything."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:51", "is_worked_example": false, "text": "But large memories are slow and usually only support access to one location at a time, so they don't make good storage for use in each instruction which needs to access several operands and store a result."}, {"start": "00:03:51", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "If we used only one large storage array, then an instruction would need to have three 32-bit addresses to specify the two source operands and destination -- each instruction encoding would be huge!"}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:12", "is_worked_example": false, "text": "And the required memory accesses would have to be one-after-the-other, really slowing down instruction execution."}, {"start": "00:04:12", "is_lecture": true, "end": "00:04:22", "is_worked_example": false, "text": "On the other hand, if we use registers to hold the operands and serve as the destination, we can design the register hardware for parallel access and make it very fast."}, {"start": "00:04:22", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "To keep the speed up we won't be able to have very many registers -- a classic size-vs-speed performance tradeoff we see in digital systems all the time."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "In the end, the tradeoff leading to the best performance is to have a small number of very fast registers used by most instructions and a large but slow main memory."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:45", "is_worked_example": false, "text": "So that's what the BETA ISA does."}, {"start": "00:04:45", "is_lecture": true, "end": "00:04:50", "is_worked_example": false, "text": "In general, all program data will reside in main memory."}, {"start": "00:04:50", "is_lecture": true, "end": "00:04:58", "is_worked_example": false, "text": "Each variable used by the program \"lives\" in a specific main memory location and so has a specific memory address."}, {"start": "00:04:58", "is_lecture": true, "end": "00:05:11", "is_worked_example": false, "text": "For example, in the diagram below, the value of variable \"x\" is stored in memory location 0x1008, and the value of \"y\" is stored in memory location 0x100C, and so on."}, {"start": "00:05:11", "is_lecture": true, "end": "00:05:23", "is_worked_example": false, "text": "To perform a computation, e.g., to compute x*37 and store the result in y, we would have to first load the value of x into a register, say, R0."}, {"start": "00:05:23", "is_lecture": true, "end": "00:05:30", "is_worked_example": false, "text": "Then we would have the datapath multiply the value in R0 by 37, storing the result back into R0."}, {"start": "00:05:30", "is_lecture": true, "end": "00:05:37", "is_worked_example": false, "text": "Here we've assumed that the constant 37 is somehow available to the datapath and doesn't itself need to be loaded from memory."}, {"start": "00:05:37", "is_lecture": true, "end": "00:05:44", "is_worked_example": false, "text": "Finally, we would write the updated value in R0 back into memory at the location for y."}, {"start": "00:05:44", "is_lecture": true, "end": "00:05:46", "is_worked_example": false, "text": "Whew!  A lot of steps..."}, {"start": "00:05:46", "is_lecture": true, "end": "00:05:53", "is_worked_example": false, "text": "Of course, we could avoid all the loading and storing if we chose to keep the values for x and y in registers."}, {"start": "00:05:53", "is_lecture": true, "end": "00:06:01", "is_worked_example": false, "text": "Since there are only 32 registers, we can't do this for all of our variables, but maybe we could arrange to load x and y into registers,"}, {"start": "00:06:01", "is_lecture": true, "end": "00:06:12", "is_worked_example": false, "text": "do all the required computations involving x and y by referring to those registers, and then, when we're done, store changes to x and y back into memory for later use."}, {"start": "00:06:12", "is_lecture": true, "end": "00:06:20", "is_worked_example": false, "text": "Optimizing performance by keeping often-used values in registers is a favorite trick of programmers and compiler writers."}, {"start": "00:06:20", "is_lecture": true, "end": "00:06:30", "is_worked_example": false, "text": "So the basic program template is some loads to bring values into the registers, followed by computation, followed by any necessary stores."}, {"start": "00:06:30", "is_lecture": true, "end": "00:06:36", "is_worked_example": false, "text": "ISAs that use this template are usually referred to as \"load-store architectures\"."}]}, "C03S01B04-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s1/4?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s1v4", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "There are many approaches to building a general-purpose computer that can be easily re-programmed for new problems."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "Almost all modern computers are based on the \"stored program\" computer architecture developed by John von Neumann in 1945, which is now commonly referred to as the \"von Neumann model\"."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "The von Neumann model has three components."}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:28", "is_worked_example": false, "text": "There's a central processing unit (aka the CPU) that contains a datapath and control FSM as described previously."}, {"start": "00:00:28", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "The CPU is connected to a read/write memory that holds some number W of words, each with N bits."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "Nowadays, even small memories have a billion words and the width of each location is at least 32 bits (usually more)."}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "This memory is often referred to as \"main memory\" to distinguish it from other memories in the system."}, {"start": "00:00:49", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "You can think of it as an array: when the CPU wishes to operate on values in memory , it sends the memory an array index, which we call the address, and, after a short delay (currently 10's of nanoseconds) the memory will return the N-bit value stored at that address."}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:13", "is_worked_example": false, "text": "Writes to main memory follow the same protocol except, of course, the data flows in the opposite direction."}, {"start": "00:01:13", "is_lecture": true, "end": "00:01:17", "is_worked_example": false, "text": "We'll talk about memory technologies a couple of lectures from now."}, {"start": "00:01:17", "is_lecture": true, "end": "00:01:29", "is_worked_example": false, "text": "And, finally, there are input/output devices that enable the computer system to communicate with the outside world or to access data storage that, unlike main memory, will remember values even when turned off."}, {"start": "00:01:29", "is_lecture": true, "end": "00:01:36", "is_worked_example": false, "text": "The key idea is to use main memory to hold the instructions for the CPU as well as data."}, {"start": "00:01:36", "is_lecture": true, "end": "00:01:41", "is_worked_example": false, "text": "Both instructions and data are, of course, just binary data stored in main memory."}, {"start": "00:01:41", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "Interpreted as an instruction, a value in memory can be thought of as a set of fields containing one or bits encoding information about the actions to be performed by the CPU."}, {"start": "00:01:53", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "The opcode field indicates the operation to be performed (e.g., ADD, XOR, COMPARE)."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "Subsequent fields specify which registers supply the source operands and the destination register where the result is stored."}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:14", "is_worked_example": false, "text": "The CPU interprets the information in the instruction fields and performs the requested operation."}, {"start": "00:02:14", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "It would then move on to the next instruction in memory, executing the stored program step-by-step."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:29", "is_worked_example": false, "text": "The goal of this chapter is to discuss the details of what operations we want the CPU to perform, how many registers we should have, and so on."}, {"start": "00:02:29", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "Of course, some values in memory are not instructions!"}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "They might be binary data representing numeric values, strings of characters, and so on."}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:48", "is_worked_example": false, "text": "The CPU will read these values into its temporary registers when it needs to operate on them and write newly computed values back into memory."}, {"start": "00:02:48", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "Mr. Blue is asking a good question: how do we know which words in memory are instructions and which are data?"}, {"start": "00:02:55", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "After all, they're both binary values!"}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:06", "is_worked_example": false, "text": "The answer is that we can't tell by looking at the values -- it's how they are used by the CPU that distinguishes instructions from data."}, {"start": "00:03:06", "is_lecture": true, "end": "00:03:10", "is_worked_example": false, "text": "If a value is loaded into the datapath, it's being used as data."}, {"start": "00:03:10", "is_lecture": true, "end": "00:03:15", "is_worked_example": false, "text": "If a value is loaded by the control logic, it's being used an instruction."}, {"start": "00:03:15", "is_lecture": true, "end": "00:03:19", "is_worked_example": false, "text": "So this is the digital system we'll build to perform computations."}, {"start": "00:03:19", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "We'll start with a datapath that contains some number of registers to hold data values."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:32", "is_worked_example": false, "text": "We'll be able to select which registers will supply operands for the arithmetic and logic unit that will perform an operation."}, {"start": "00:03:32", "is_lecture": true, "end": "00:03:35", "is_worked_example": false, "text": "The ALU produces a result and other status signals."}, {"start": "00:03:35", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "The ALU result can be written back to one of the registers for later use."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:44", "is_worked_example": false, "text": "We'll provide the datapath with means to move data to and from main memory."}, {"start": "00:03:44", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "There will be a control unit that provides the necessary control signals to the datapath."}, {"start": "00:03:04", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "In the example datapath shown here, the control unit would provide ASEL and BSEL to select two register values as operands and DEST to select the register where the ALU result will be written."}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "If the datapath had, say, 32 internal registers, ASEL, BSEL and DEST would be 5-bit values, each specifying a particular register number in the range 0 to 31."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:31", "is_worked_example": false, "text": "The control unit also provides the FN function code that controls the operation performed by the ALU."}, {"start": "00:04:31", "is_lecture": true, "end": "00:04:30", "is_worked_example": false, "text": "The ALU we designed in Part 1 of the course requires a 6-bit function code to select between a variety of arithmetic, boolean and shift operations."}, {"start": "00:04:30", "is_lecture": true, "end": "00:04:35", "is_worked_example": false, "text": "The control unit would load values from main memory to be interpreted as instructions."}, {"start": "00:04:35", "is_lecture": true, "end": "00:04:45", "is_worked_example": false, "text": "The control unit contains a register, called the \"program counter\", that keeps track of the address in main memory of the next instruction to be executed."}, {"start": "00:04:45", "is_lecture": true, "end": "00:04:53", "is_worked_example": false, "text": "The control unit also contains a (hopefully small) amount of logic to translate the instruction fields into the necessary control signals."}, {"start": "00:04:53", "is_lecture": true, "end": "00:05:04", "is_worked_example": false, "text": "Note the control unit receives status signals from the datapath that will enable programs to execute different sequences of instructions if, for example, a particular data value was zero."}, {"start": "00:05:04", "is_lecture": true, "end": "00:05:11", "is_worked_example": false, "text": "The datapath serves as the brawn of our digital system and is responsible for storing and manipulating data values."}, {"start": "00:05:11", "is_lecture": true, "end": "00:05:21", "is_worked_example": false, "text": "The control unit serves as the brain of our system, interpreting the program stored in main memory and generating the necessary sequence of control signals for the datapath."}, {"start": "00:05:21", "is_lecture": true, "end": "00:05:25", "is_worked_example": false, "text": "Instructions are the fundamental unit of work."}, {"start": "00:05:25", "is_lecture": true, "end": "00:05:30", "is_worked_example": false, "text": "They're fetched by the control unit and executed one after another in the order they are fetched."}, {"start": "00:05:30", "is_lecture": true, "end": "00:05:39", "is_worked_example": false, "text": "Each instruction specifies the operation to be performed along with the registers to supply the source operands and destination register where the result will be stored."}, {"start": "00:05:39", "is_lecture": true, "end": "00:05:45", "is_worked_example": false, "text": "In a von Neumann machine, instruction execution involves the steps shown here:"}, {"start": "00:05:45", "is_lecture": true, "end": "00:05:51", "is_worked_example": false, "text": "the instruction is loaded from the memory location whose address is specified by the program counter."}, {"start": "00:05:51", "is_lecture": true, "end": "00:05:58", "is_worked_example": false, "text": "When the requested data is returned by the memory, the instruction fields are converted to the appropriate control signals for the datapath,"}, {"start": "00:05:58", "is_lecture": true, "end": "00:06:09", "is_worked_example": false, "text": "selecting the source operands from the specified registers, directing the ALU to perform the specified operation, and storing the result in the specified destination register."}, {"start": "00:06:09", "is_lecture": true, "end": "00:06:16", "is_worked_example": false, "text": "The final step in executing an instruction is updating the value of the program counter to be the address of the next instruction."}, {"start": "00:06:16", "is_lecture": true, "end": "00:06:20", "is_worked_example": false, "text": "This execution loop is performed again and again."}, {"start": "00:06:20", "is_lecture": true, "end": "00:06:24", "is_worked_example": false, "text": "Modern machines can execute up more than a billion instructions per second!"}, {"start": "00:06:24", "is_lecture": true, "end": "00:06:28", "is_worked_example": false, "text": "The discussion so far has been a bit abstract."}, {"start": "00:06:28", "is_lecture": true, "end": "00:06:33", "is_worked_example": false, "text": "Now it's time to roll up our sleeves and figure out what instructions we want our system to support."}, {"start": "00:06:33", "is_lecture": true, "end": "00:06:44", "is_worked_example": false, "text": "The specification of instruction fields and their meaning along with the details of the datapath design are collectively called the instruction set architecture (ISA) of the system."}, {"start": "00:06:44", "is_lecture": true, "end": "00:06:56", "is_worked_example": false, "text": "The ISA is a detailed functional specification of the operations and storage mechanisms and serves as a contract between the designers of the digital hardware and the programmers who will write the programs."}, {"start": "00:06:56", "is_lecture": true, "end": "00:07:06", "is_worked_example": false, "text": "Since the programs are stored in main memory and can hence be changed, we'll call them software, to distinguish them from the digital logic which, once implemented, doesn't change."}, {"start": "00:07:06", "is_lecture": true, "end": "00:07:11", "is_worked_example": false, "text": "It's the combination of hardware and software that determine the behavior of our system."}, {"start": "00:07:11", "is_lecture": true, "end": "00:07:20", "is_worked_example": false, "text": "The ISA is a new layer of abstraction: we can write programs for the system without knowing the implementation details of the hardware."}, {"start": "00:07:20", "is_lecture": true, "end": "00:07:27", "is_worked_example": false, "text": "As hardware technology improves we can build faster systems without having to change the software."}, {"start": "00:07:27", "is_lecture": true, "end": "00:07:41", "is_worked_example": false, "text": "You can see here that over a fifteen year timespan, the hardware for executing the Intel x86 instruction set went from executing 300,000 instructions per second to executing 5 billion instructions per second."}, {"start": "00:07:41", "is_lecture": true, "end": "00:07:51", "is_worked_example": false, "text": "Same software as before, we've just taken advantage of smaller and faster MOSFETs to build more complex circuits and faster execution engines."}, {"start": "00:07:51", "is_lecture": true, "end": "00:07:54", "is_worked_example": false, "text": "But a word of caution is in order!"}, {"start": "00:07:54", "is_lecture": true, "end": "00:08:06", "is_worked_example": false, "text": "It's tempting to make choices in the ISA that reflect the constraints of current technologies, e.g., the number of internal registers, the width of the operands, or the maximum size of main memory."}, {"start": "00:08:06", "is_lecture": true, "end": "00:08:23", "is_worked_example": false, "text": "But it will be hard to change the ISA when technology improves since there's a powerful economic incentive to ensure that old software can run on new machines, which means that a particular ISA can live for decades and span many generations of technology."}, {"start": "00:08:23", "is_lecture": true, "end": "00:08:29", "is_worked_example": false, "text": "If your ISA is successful, you'll have to live with any bad choices you made for a very long time."}, {"start": "00:08:29", "is_lecture": true, "end": "00:08:33", "is_worked_example": false, "text": "Designing an ISA is hard!"}, {"start": "00:08:33", "is_lecture": true, "end": "00:08:35", "is_worked_example": false, "text": "What are the operations that should be supported?"}, {"start": "00:08:35", "is_lecture": true, "end": "00:08:36", "is_worked_example": false, "text": "How many internal registers?"}, {"start": "00:08:36", "is_lecture": true, "end": "00:08:38", "is_worked_example": false, "text": "How much main memory?"}, {"start": "00:08:38", "is_lecture": true, "end": "00:08:45", "is_worked_example": false, "text": "Should we design the instruction encoding to minimize program size or to keep the logic in the control unit as simple as possible?"}, {"start": "00:08:45", "is_lecture": true, "end": "00:08:51", "is_worked_example": false, "text": "Looking into our crystal ball, what can we say about the computation and storage capabilities of future technologies?"}, {"start": "00:08:51", "is_lecture": true, "end": "00:08:56", "is_worked_example": false, "text": "We'll answer these questions by taking a quantitative approach."}, {"start": "00:08:56", "is_lecture": true, "end": "00:09:03", "is_worked_example": false, "text": "First we'll choose a set of benchmark programs, chosen as representative of the many types of programs we expect to run on our system."}, {"start": "00:09:03", "is_lecture": true, "end": "00:09:18", "is_worked_example": false, "text": "So some of benchmark programs will perform scientific and engineering computations, some will manipulate large data sets or perform database operations, some will require specialized computations for graphics or communications, and so on."}, {"start": "00:09:18", "is_lecture": true, "end": "00:09:25", "is_worked_example": false, "text": "Happily, after many decades of computer use, several standardized benchmark suites are available for us to use."}, {"start": "00:09:25", "is_lecture": true, "end": "00:09:33", "is_worked_example": false, "text": "We'll then implement the benchmark programs using our instruction set and simulate their execution on our proposed datapath."}, {"start": "00:09:33", "is_lecture": true, "end": "00:09:37", "is_worked_example": false, "text": "We'll evaluate the results to measure how well the system performs."}, {"start": "00:09:37", "is_lecture": true, "end": "00:09:40", "is_worked_example": false, "text": "But what do we mean by \"well\"?"}, {"start": "00:09:40", "is_lecture": true, "end": "00:09:48", "is_worked_example": false, "text": "That's where it gets interesting: \"well\" could refer to execution speed, energy consumption, circuit size, system cost, etc."}, {"start": "00:09:48", "is_lecture": true, "end": "00:09:56", "is_worked_example": false, "text": "If you're designing a smart watch, you'll make different choices than if you're designing a high-performance graphics card or a data-center server."}, {"start": "00:09:56", "is_lecture": true, "end": "00:10:03", "is_worked_example": false, "text": "Whatever metric you choose to evaluate your proposed system, there's an important design principle we can follow:"}, {"start": "00:10:03", "is_lecture": true, "end": "00:10:07", "is_worked_example": false, "text": "identify the common operations and focus on them as you optimize your design."}, {"start": "00:10:07", "is_lecture": true, "end": "00:10:17", "is_worked_example": false, "text": "For example, in general-purpose computing, almost all programs spend a lot of their time on simple arithmetic operations and accessing values in main memory."}, {"start": "00:10:17", "is_lecture": true, "end": "00:10:21", "is_worked_example": false, "text": "So those operations should be made as fast and energy efficient as possible."}, {"start": "00:10:21", "is_lecture": true, "end": "00:10:29", "is_worked_example": false, "text": "Now, let's get to work designing our own instruction set and execution engine, a system we'll call the Beta."}]}, "C11S02B02-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s2/2?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s2v2", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:06", "is_worked_example": true, "text": "Consider this 2-way set associative cache to be used with our beta processor."}, {"start": "00:00:06", "is_lecture": false, "end": "00:00:12", "is_worked_example": true, "text": "Each line holds a single 32 bit data word together with a valid bit and a tag."}, {"start": "00:00:12", "is_lecture": false, "end": "00:00:17", "is_worked_example": true, "text": "Our beta uses 32 bit addresses."}, {"start": "00:00:17", "is_lecture": false, "end": "00:00:27", "is_worked_example": true, "text": "We want to determine which address bits should be used for the cache index and which should be used for the tag so as to ensure best cache performance."}, {"start": "00:00:27", "is_lecture": false, "end": "00:00:40", "is_worked_example": true, "text": "The bottom two bits of the address are always assumed to be 00 for word alignment since are addresses are in bytes but our data is in words of 32 bits or 4 bytes."}, {"start": "00:00:40", "is_lecture": false, "end": "00:00:47", "is_worked_example": true, "text": "Our cache has 8 lines in it, so this means that our index must be 3 bits wide."}, {"start": "00:00:47", "is_lecture": false, "end": "00:00:54", "is_worked_example": true, "text": "The bits that we want to use for the index are the next least significant bits which are address bits [4:2]."}, {"start": "00:00:54", "is_lecture": false, "end": "00:01:02", "is_worked_example": true, "text": "The reason that we want to make these bits be part of the index instead of the tag is because of locality."}, {"start": "00:01:02", "is_lecture": false, "end": "00:01:15", "is_worked_example": true, "text": "The idea is that instructions or data that are near each other in memory are more likely to be accessed around the same time than instructions or data that reside in a different part of memory."}, {"start": "00:01:15", "is_lecture": false, "end": "00:01:28", "is_worked_example": true, "text": "So if for example, our instruction comes from address 0x1000, it is fairly likely that we will also access the next instruction which is at address 0x1004."}, {"start": "00:01:28", "is_lecture": false, "end": "00:01:42", "is_worked_example": true, "text": "With this scheme the index of the first instruction would map to line 0 of the cache while the next instruction would map to line 1 of the cache so they would not cause a collision or a miss in the cache."}, {"start": "00:01:42", "is_lecture": false, "end": "00:01:47", "is_worked_example": true, "text": "This leaves the higher order bits for the tag."}, {"start": "00:01:47", "is_lecture": false, "end": "00:01:54", "is_worked_example": true, "text": "We need to use all of the remaining bits for the tag in order to be able to uniquely identify each distinct address."}, {"start": "00:01:54", "is_lecture": false, "end": "00:02:06", "is_worked_example": true, "text": "Since many addresses will map to the same line in the cache, we must compare the tag of the data in the cache to see if we have in fact found the data that we are looking for."}, {"start": "00:02:06", "is_lecture": false, "end": "00:02:11", "is_worked_example": true, "text": "So we use address bits [31:5] for the tag."}, {"start": "00:02:11", "is_lecture": false, "end": "00:02:18", "is_worked_example": true, "text": "Suppose our beta executes a read of address 0x5678."}, {"start": "00:02:18", "is_lecture": false, "end": "00:02:27", "is_worked_example": true, "text": "We would like to identify which locations in the cache will need to be checked to determine if our data is already present in the cache or not."}, {"start": "00:02:27", "is_lecture": false, "end": "00:02:34", "is_worked_example": true, "text": "In order to determine this, we need to identify the portion of the address that corresponds to the index."}, {"start": "00:02:34", "is_lecture": false, "end": "00:02:43", "is_worked_example": true, "text": "The index bits are bits [4:2] which correspond to 110 in binary for this address."}, {"start": "00:02:43", "is_lecture": false, "end": "00:02:48", "is_worked_example": true, "text": "That means that this address would map to cache line 6 in our cache."}, {"start": "00:02:48", "is_lecture": false, "end": "00:02:59", "is_worked_example": true, "text": "Since this is a 2-way set associative cache, there are two possible locations that our data could be located, either in 6A or 6B."}, {"start": "00:02:59", "is_lecture": false, "end": "00:03:08", "is_worked_example": true, "text": "So we would need to compare both tags to determine whether or not the data we are trying to read is already in the cache."}, {"start": "00:03:08", "is_lecture": false, "end": "00:03:21", "is_worked_example": true, "text": "Assuming that checking the cache on a read takes 1 cycle, and that refilling the cache on a miss takes an additional 8 cycles,"}, {"start": "00:03:21", "is_lecture": false, "end": "00:03:32", "is_worked_example": true, "text": "this means that the time it takes on a miss is 9 cycles, 1 to first check if the value is in the cache, plus another 8 to bring the value into the cache if it wasn't already there."}, {"start": "00:03:32", "is_lecture": false, "end": "00:03:40", "is_worked_example": true, "text": "Now suppose that we want to achieve an average read access time of 1.1 cycles."}, {"start": "00:03:40", "is_lecture": false, "end": "00:03:47", "is_worked_example": true, "text": "What is the minimum hit ratio required to achieve this average access time over many reads?"}, {"start": "00:03:47", "is_lecture": false, "end": "00:03:55", "is_worked_example": true, "text": "We know that average access time = (hit time * hit rate) + (miss time * miss rate)."}, {"start": "00:03:55", "is_lecture": false, "end": "00:04:00", "is_worked_example": true, "text": "If we call 'a' our hit rate, then our miss rate is (1-a)."}, {"start": "00:04:00", "is_lecture": false, "end": "00:04:11", "is_worked_example": true, "text": "So our desired average access time of 1.1 must equal 1 * a plus 9 * (1-a)."}, {"start": "00:04:11", "is_lecture": false, "end": "00:04:24", "is_worked_example": true, "text": "This reduces to 1.1 = 9-8a, which means that 8a = 7.9 or a = 7.9/8."}, {"start": "00:04:24", "is_lecture": false, "end": "00:04:32", "is_worked_example": true, "text": "So to achieve a 1.1 cycle average access time our hit rate must be at least 7.9/8."}, {"start": "00:04:32", "is_lecture": false, "end": "00:04:39", "is_worked_example": true, "text": "We are provided with this benchmark program for testing our 2-way set associative cache."}, {"start": "00:04:39", "is_lecture": false, "end": "00:04:43", "is_worked_example": true, "text": "The cache is initially empty before execution begins."}, {"start": "00:04:43", "is_lecture": false, "end": "00:04:48", "is_worked_example": true, "text": "In other words, all the valid bits of the cache are 0."}, {"start": "00:04:48", "is_lecture": false, "end": "00:05:00", "is_worked_example": true, "text": "Assuming that an LRU, or least recently used, replacement strategy is used, we would like to determine the approximate cache hit ratio for this program."}, {"start": "00:05:00", "is_lecture": false, "end": "00:05:04", "is_worked_example": true, "text": "Let's begin by understanding what this benchmark does."}, {"start": "00:05:04", "is_lecture": false, "end": "00:05:07", "is_worked_example": true, "text": "The program begins at address 0."}, {"start": "00:05:07", "is_lecture": false, "end": "00:05:14", "is_worked_example": true, "text": "It first performs some initialization of registers using three CMOVE operations."}, {"start": "00:05:14", "is_lecture": false, "end": "00:05:21", "is_worked_example": true, "text": "The first, initializes R0 to hold source which is the address in memory where our data will be stored."}, {"start": "00:05:21", "is_lecture": false, "end": "00:05:34", "is_worked_example": true, "text": "The second initializes R1 to 0, and the third initializes R2 to 0x1000 which is the number of words that this benchmark will work with."}, {"start": "00:05:34", "is_lecture": false, "end": "00:05:38", "is_worked_example": true, "text": "We then enter the loop which is shown in the yellow rectangle."}, {"start": "00:05:38", "is_lecture": false, "end": "00:05:46", "is_worked_example": true, "text": "The loop loads the first element of our data from location source + 0 into register R3."}, {"start": "00:05:46", "is_lecture": false, "end": "00:05:51", "is_worked_example": true, "text": "It then increments R0 to point to the next piece of data."}, {"start": "00:05:51", "is_lecture": false, "end": "00:06:01", "is_worked_example": true, "text": "Since our data is 32 bits wide, this requires the addition of the constant 4 representing the number of bytes between consecutive data words."}, {"start": "00:06:01", "is_lecture": false, "end": "00:06:10", "is_worked_example": true, "text": "It then takes the value that was just loaded and adds it to R1 which holds a running sum of all the data seen so far."}, {"start": "00:06:10", "is_lecture": false, "end": "00:06:18", "is_worked_example": true, "text": "R2 is then decremented by 1 to indicate that we have one fewer piece of data to handle."}, {"start": "00:06:18", "is_lecture": false, "end": "00:06:24", "is_worked_example": true, "text": "Finally, as long as R2 is not equal to 0 it repeats the loop."}, {"start": "00:06:24", "is_lecture": false, "end": "00:06:33", "is_worked_example": true, "text": "At the very end of the benchmark the final sum is stored at address source, and the program halts."}, {"start": "00:06:33", "is_lecture": false, "end": "00:06:44", "is_worked_example": true, "text": "When trying to determine the approximate hit ratio, the instructions that occur only once because they live outside of the loop can basically be ignored."}, {"start": "00:06:44", "is_lecture": false, "end": "00:06:55", "is_worked_example": true, "text": "So looking only at what happens over and over again in the loop, each time through the loop, we have 5 instruction fetches and one data fetch."}, {"start": "00:06:55", "is_lecture": false, "end": "00:07:01", "is_worked_example": true, "text": "The first time through the loop, we miss on the instruction fetches and then bring them into the cache."}, {"start": "00:07:01", "is_lecture": false, "end": "00:07:06", "is_worked_example": true, "text": "We also miss on the data load from address 0x100."}, {"start": "00:07:06", "is_lecture": false, "end": "00:07:15", "is_worked_example": true, "text": "When this data is brought into the cache, instead of replacing the recently loaded instructions, it loads the data into the 2nd set of the cache."}, {"start": "00:07:15", "is_lecture": false, "end": "00:07:18", "is_worked_example": true, "text": "The loop is then repeated."}, {"start": "00:07:18", "is_lecture": false, "end": "00:07:22", "is_worked_example": true, "text": "This time through the loop, all the instruction fetches result in hits."}, {"start": "00:07:22", "is_lecture": false, "end": "00:07:34", "is_worked_example": true, "text": "However, the data that we now need is a new piece of data so that will result in a cache miss and once again load the new data word into the 2nd set of the cache."}, {"start": "00:07:34", "is_lecture": false, "end": "00:07:38", "is_worked_example": true, "text": "This behavior then repeats itself every time through the loop."}, {"start": "00:07:38", "is_lecture": false, "end": "00:07:46", "is_worked_example": true, "text": "Since the loop is executed many times, we can also ignore the initial instruction fetches on the first iteration of the loop."}, {"start": "00:07:46", "is_lecture": false, "end": "00:07:55", "is_worked_example": true, "text": "So in steady state, we get 5 instruction cache hits, and 1 data cache miss every time through the loop."}, {"start": "00:07:55", "is_lecture": false, "end": "00:08:01", "is_worked_example": true, "text": "This means that our approximate hit ratio is 5/6."}, {"start": "00:08:01", "is_lecture": false, "end": "00:08:12", "is_worked_example": true, "text": "The last question we want to consider is what is stored in the cache after execution of this benchmark is completed."}, {"start": "00:08:12", "is_lecture": false, "end": "00:08:23", "is_worked_example": true, "text": "As we saw earlier, because we have a 2-way set associative cache, the instructions and data don't conflict with each other because they can each go in a separate set."}, {"start": "00:08:23", "is_lecture": false, "end": "00:08:32", "is_worked_example": true, "text": "We want to determine which instruction and which piece of data will end up in line 4 of the cache after execution is completed."}, {"start": "00:08:32", "is_lecture": false, "end": "00:08:37", "is_worked_example": true, "text": "We'll begin by identifying the mapping of instructions to cache lines."}, {"start": "00:08:37", "is_lecture": false, "end": "00:08:51", "is_worked_example": true, "text": "Since our program begins at address 0, the first CMOVE instruction is at address 0, and it's index is equal to 0b000, or 0 in binary."}, {"start": "00:08:51", "is_lecture": false, "end": "00:08:55", "is_worked_example": true, "text": "This means that it will map to cache line 0."}, {"start": "00:08:55", "is_lecture": false, "end": "00:09:01", "is_worked_example": true, "text": "Since at this point, nothing is in the cache, it will be loaded into line 0 of set A."}, {"start": "00:09:01", "is_lecture": false, "end": "00:09:10", "is_worked_example": true, "text": "In a similar manner the next 2 CMOVE instructions and the LD instruction will be loaded into lines 1-3 of set A."}, {"start": "00:09:10", "is_lecture": false, "end": "00:09:14", "is_worked_example": true, "text": "At this point, we begin loading data."}, {"start": "00:09:14", "is_lecture": false, "end": "00:09:23", "is_worked_example": true, "text": "Since the cache is 2-way set associative, the data will be loaded into set B instead of removing the instructions that were loaded into set A."}, {"start": "00:09:23", "is_lecture": false, "end": "00:09:49", "is_worked_example": true, "text": "The instructions that are outside the loop will end up getting taken out of set A in favor of loading a data item into those cache locations, but the instructions that make up the loop will not be displaced because every time something maps to cache lines 3-7, the least recently used location will correspond to a data value not to the instructions which are used over and over again."}, {"start": "00:09:49", "is_lecture": false, "end": "00:10:01", "is_worked_example": true, "text": "This means that at the end of execution of the benchmark, the instruction that will be in line 4 of the cache is the ADDC instruction from address 0x10 of the program."}, {"start": "00:10:01", "is_lecture": false, "end": "00:10:08", "is_worked_example": true, "text": "The loop instructions which will remain in the cache are shown here."}, {"start": "00:10:08", "is_lecture": false, "end": "00:10:13", "is_worked_example": true, "text": "Now let's consider what happens to the data used in this benchmark."}, {"start": "00:10:13", "is_lecture": false, "end": "00:10:19", "is_worked_example": true, "text": "We expect the loop instructions to remain in lines 3-7 of set A of the cache."}, {"start": "00:10:19", "is_lecture": false, "end": "00:10:26", "is_worked_example": true, "text": "The data will use all of set B plus locations 0-2 of set A as needed."}, {"start": "00:10:26", "is_lecture": false, "end": "00:10:30", "is_worked_example": true, "text": "The data begins at address 0x100."}, {"start": "00:10:30", "is_lecture": false, "end": "00:10:41", "is_worked_example": true, "text": "The index portion of address 0x100 is 0b000 so this data element maps to cache line 0."}, {"start": "00:10:41", "is_lecture": false, "end": "00:10:51", "is_worked_example": true, "text": "Since the least recently used set for line 0 is set B, it will go into set B leaving the instructions in tact in set A."}, {"start": "00:10:51", "is_lecture": false, "end": "00:10:55", "is_worked_example": true, "text": "The next data element is at address 0x104."}, {"start": "00:10:55", "is_lecture": false, "end": "00:11:13", "is_worked_example": true, "text": "Since the bottom two bits are used for word alignment, the index portion of this address is 0b001, so this data element maps to line 1 of set B, and so on through element 0x7."}, {"start": "00:11:13", "is_lecture": false, "end": "00:11:19", "is_worked_example": true, "text": "Data element 0x8 is at address 0x120."}, {"start": "00:11:19", "is_lecture": false, "end": "00:11:25", "is_worked_example": true, "text": "The index portion of this address is once again 0b000."}, {"start": "00:11:25", "is_lecture": false, "end": "00:11:32", "is_worked_example": true, "text": "So this element maps to cache line 0 just like element 0x0 did."}, {"start": "00:11:32", "is_lecture": false, "end": "00:11:48", "is_worked_example": true, "text": "However, at this point line 0 of set B was accessed more recently than line 0 of set A, so the CMOVE instruction which is executed only once will get replaced by a data element that maps to line 0."}, {"start": "00:11:48", "is_lecture": false, "end": "00:12:02", "is_worked_example": true, "text": "As we mentioned earlier, all the instructions in the loop will not be displaced because they are accessed over and over again so they never end up being the least recently used item in a cache line."}, {"start": "00:12:02", "is_lecture": false, "end": "00:12:13", "is_worked_example": true, "text": "After executing the loop 16 times meaning that data elements 0 through 0xF have been accessed, the cache will look like this."}, {"start": "00:12:13", "is_lecture": false, "end": "00:12:19", "is_worked_example": true, "text": "Note that the loop instructions continue in their original location in the cache."}, {"start": "00:12:19", "is_lecture": false, "end": "00:12:28", "is_worked_example": true, "text": "The state of the cache continues to look like this with more recently accessed data elements replacing the earlier data elements."}, {"start": "00:12:28", "is_lecture": false, "end": "00:12:38", "is_worked_example": true, "text": "Since there are 0x1000 elements of data, this continues until just before address 0x4100."}, {"start": "00:12:38", "is_lecture": false, "end": "00:12:46", "is_worked_example": true, "text": "The last element is actually located 1 word before that at address 0x40FC."}, {"start": "00:12:46", "is_lecture": false, "end": "00:12:52", "is_worked_example": true, "text": "The last 8 elements of the data and their mapping to cache lines is shown here."}, {"start": "00:12:52", "is_lecture": false, "end": "00:13:11", "is_worked_example": true, "text": "The data element that ends up in line 4 of the cache, when the benchmark is done executing, is element 0x0FFC of the data which comes from address 0x40F0."}]}, "C06S01B02-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c6/c6s1/2?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c6s1v2", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:10", "is_worked_example": false, "text": "A compiler is a program that translates a high-level language program into a functionally equivalent sequence of machine instructions, i.e., an assembly language program."}, {"start": "00:00:10", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "A compiler first checks that the high-level program is correct, i.e., that the statements are well formed, the programmer isn't asking for nonsensical computations,"}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:28", "is_worked_example": false, "text": "e.g., adding a string value and an integer, or attempting to use the value of a variable before it has been properly initialized."}, {"start": "00:00:28", "is_lecture": true, "end": "00:00:44", "is_worked_example": false, "text": "The compiler may also provide warnings when operations may not produce the expected results, e.g., when converting from a floating-point number to an integer, where the floating-point value may be too large to fit in the number of bits provided by the integer."}, {"start": "00:00:44", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "If the program passes scrutiny, the compiler then proceeds to generate efficient sequences of instructions, often finding ways to rearrange the computation so that the resulting sequences are shorter and faster."}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "It's hard to beat a modern optimizing compiler at producing assembly language, since the compiler will patiently explore alternatives and deduce properties of the program that may not be apparent to even diligent assembly language programmers."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:18", "is_worked_example": false, "text": "In this section, we'll look at a simple technique for compiling C programs into assembly."}, {"start": "00:01:18", "is_lecture": true, "end": "00:01:24", "is_worked_example": false, "text": "Then, in the next section, we'll dive more deeply into how a modern compiler works."}, {"start": "00:01:24", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "There are two main routines in our simple compiler: compile_statement and compile_expr."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:35", "is_worked_example": false, "text": "The job of compile_statement is to compile a single statement from the source program."}, {"start": "00:01:35", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "Since the source program is a sequence of statements, we'll be calling compile_statement repeatedly."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "We'll focus on the compilation technique for four types of statements."}, {"start": "00:01:48", "is_lecture": true, "end": "00:01:52", "is_worked_example": false, "text": "An unconditional statement is simply an expression that's evaluated once."}, {"start": "00:01:52", "is_lecture": true, "end": "00:01:58", "is_worked_example": false, "text": "A compound statement is simply a sequence of statements to be executed in turn."}, {"start": "00:01:58", "is_lecture": true, "end": "00:02:06", "is_worked_example": false, "text": "Conditional statements, sometimes called \"if statements\", compute the value of an test expression, e.g., a comparison such as \"A < B\"."}, {"start": "00:02:06", "is_lecture": true, "end": "00:02:12", "is_worked_example": false, "text": "If the test is true then statement_1 is executed, otherwise statement_2 is executed."}, {"start": "00:02:12", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "Iteration statements also contain a test expression."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "In each iteration, if the test true, then the statement is executed, and the process repeats."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "If the test is false, the iteration is terminated."}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "The other main routine is compile_expr whose job it is to generate code to compute the value of an expression, leaving the result in some register."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:38", "is_worked_example": false, "text": "Expressions take many forms:"}, {"start": "00:02:38", "is_lecture": true, "end": "00:02:40", "is_worked_example": false, "text": "simple constant values"}, {"start": "00:02:40", "is_lecture": true, "end": "00:02:43", "is_worked_example": false, "text": "values from scalar or array variables,"}, {"start": "00:02:43", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "assignment expressions that compute a value and then store the result in some variable,"}, {"start": "00:03:49", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "unary or binary operations that combine the values of their operands with the specified operator."}, {"start": "00:02:55", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "Complex arithmetic expressions can be decomposed into sequences of unary and binary operations."}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "And, finally, procedure calls, where a named sequence of statements will be executed with the values of the supplied arguments assigned as the values for the formal parameters of the procedure."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "Compiling procedures and procedure calls is a topic that we'll tackle next lecture since there are some complications to understand and deal with."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:29", "is_worked_example": false, "text": "Happily, compiling the other types of expressions and statements is straightforward, so let's get started."}, {"start": "00:03:29", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "What code do we need to put the value of a constant into a register?"}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:43", "is_worked_example": false, "text": "If the constant will fit into the 16-bit constant field of an instruction, we can use CMOVE to load the sign-extended constant into a register."}, {"start": "00:03:43", "is_lecture": true, "end": "00:03:51", "is_worked_example": false, "text": "This approach works for constants between -32768 and +32767."}, {"start": "00:03:51", "is_lecture": true, "end": "00:03:58", "is_worked_example": false, "text": "If the constant is too large, it's stored in a main memory location and we use a LD instruction to get the value into a register."}, {"start": "00:03:58", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "Loading the value of a variable is much the same as loading the value of a large constant."}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:10", "is_worked_example": false, "text": "We use a LD instruction to access the memory location that holds the value of the variable."}, {"start": "00:04:10", "is_lecture": true, "end": "00:04:20", "is_worked_example": false, "text": "Performing an array access is slightly more complicated: arrays are stored as consecutive locations in main memory, starting with index 0."}, {"start": "00:04:20", "is_lecture": true, "end": "00:04:24", "is_worked_example": false, "text": "Each element of the array occupies some fixed number bytes."}, {"start": "00:04:24", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "So we need code to convert the array index into the actual main memory address for the specified array element."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:41", "is_worked_example": false, "text": "We first invoke compile_expr to generate code that evaluates the index expression and leaves the result in Rx."}, {"start": "00:04:41", "is_lecture": true, "end": "00:04:46", "is_worked_example": false, "text": "That will be a value between 0 and the size of the array minus 1."}, {"start": "00:04:46", "is_lecture": true, "end": "00:05:00", "is_worked_example": false, "text": "We'll use a LD instruction to access the appropriate array entry, but that means we need to convert the index into a byte offset, which we do by multiplying the index by bsize, the number of bytes in one element."}, {"start": "00:05:00", "is_lecture": true, "end": "00:05:04", "is_worked_example": false, "text": "If b was an array of integers, bsize would be 4."}, {"start": "00:05:04", "is_lecture": true, "end": "00:05:19", "is_worked_example": false, "text": "Now that we have the byte offset in a register, we can use LD to add the offset to the base address of the array computing the address of the desired array element, then load the memory value at that address into a register."}, {"start": "00:05:19", "is_lecture": true, "end": "00:05:21", "is_worked_example": false, "text": "Assignment expressions are easy"}, {"start": "00:05:21", "is_lecture": true, "end": "00:05:32", "is_worked_example": false, "text": "Invoke compile_expr to generate code that loads the value of the expression into a register, then generate a ST instruction to store the value into the specified variable."}, {"start": "00:05:32", "is_lecture": true, "end": "00:05:35", "is_worked_example": false, "text": "Arithmetic operations are pretty easy too."}, {"start": "00:05:35", "is_lecture": true, "end": "00:05:42", "is_worked_example": false, "text": "Use compile_expr to generate code for each of the operand expressions, leaving the results in registers."}, {"start": "00:05:42", "is_lecture": true, "end": "00:05:49", "is_worked_example": false, "text": "Then generate the appropriate ALU instruction to combine the operands and leave the answer in a register."}, {"start": "00:05:49", "is_lecture": true, "end": "00:05:53", "is_worked_example": false, "text": "Let's look at example to see how all this works."}, {"start": "00:05:53", "is_lecture": true, "end": "00:06:00", "is_worked_example": false, "text": "Here have an assignment expression that requires a subtract, a multiply, and an addition to compute the required value."}, {"start": "00:06:00", "is_lecture": true, "end": "00:06:07", "is_worked_example": false, "text": "Let's follow the compilation process from start to finish as we invoke compile_expr to generate the necessary code."}, {"start": "00:06:07", "is_lecture": true, "end": "00:06:17", "is_worked_example": false, "text": "Following the template for assignment expressions from the previous page, we recursively call compile_expr to compute value of the right-hand-side of the assignment."}, {"start": "00:06:17", "is_lecture": true, "end": "00:06:26", "is_worked_example": false, "text": "That's a multiply operation, so, following the Operations template, we need to compile the left-hand operand of the multiply."}, {"start": "00:06:26", "is_lecture": true, "end": "00:06:34", "is_worked_example": false, "text": "That's a subtract operation, so, we call compile_expr again to compile the left-hand operand of the subtract."}, {"start": "00:06:34", "is_lecture": true, "end": "00:06:43", "is_worked_example": false, "text": "Aha, we know how to get the value of a variable into a register. So we generate a LD instruction to load the value of x into r1."}, {"start": "00:06:43", "is_lecture": true, "end": "00:06:48", "is_worked_example": false, "text": "The process we're following is called \"recursive descent\"."}, {"start": "00:06:48", "is_lecture": true, "end": "00:06:54", "is_worked_example": false, "text": "We've used recursive calls to compile_expr to process each level of the expression tree."}, {"start": "00:06:54", "is_lecture": true, "end": "00:07:04", "is_worked_example": false, "text": "At each recursive call the expressions get simpler, until we reach a variable or constant, where we can generate the appropriate instruction without descending further."}, {"start": "00:07:04", "is_lecture": true, "end": "00:07:10", "is_worked_example": false, "text": "At this point we've reach a leaf of the expression tree and we're done with this branch of the recursion."}, {"start": "00:07:10", "is_lecture": true, "end": "00:07:16", "is_worked_example": false, "text": "Now we need to get the value of the right-hand operand of the subtract into a register."}, {"start": "00:07:16", "is_lecture": true, "end": "00:07:21", "is_worked_example": false, "text": "In case it's a small constant, so we generate a CMOVE instruction."}, {"start": "00:07:21", "is_lecture": true, "end": "00:07:31", "is_worked_example": false, "text": "Now that both operand values are in registers, we return to the subtract template and generate a SUB instruction to do the subtraction."}, {"start": "00:07:31", "is_lecture": true, "end": "00:07:36", "is_worked_example": false, "text": "We now have the value for the left-hand operand of the multiply in r1."}, {"start": "00:07:36", "is_lecture": true, "end": "00:07:49", "is_worked_example": false, "text": "We follow the same process for the right-hand operand of the multiply, recursively calling compile_expr to process each level of the expression until we reach a variable or constant."}, {"start": "00:07:49", "is_lecture": true, "end": "00:07:59", "is_worked_example": false, "text": "Then we return up the expression tree, generating the appropriate instructions as we go, following the dictates of the appropriate template from the previous slide."}, {"start": "00:07:59", "is_lecture": true, "end": "00:08:02", "is_worked_example": false, "text": "The generated code is shown on the left of the slide."}, {"start": "00:08:02", "is_lecture": true, "end": "00:08:09", "is_worked_example": false, "text": "The recursive-descent technique makes short work of generating code for even the most complicated of expressions."}, {"start": "00:08:09", "is_lecture": true, "end": "00:08:15", "is_worked_example": false, "text": "There's even opportunity to find some simple optimizations by looking at adjacent instructions."}, {"start": "00:08:15", "is_lecture": true, "end": "00:08:25", "is_worked_example": false, "text": "For example, a CMOVE followed by an arithmetic operation can often be shorted to a single arithmetic instruction with the constant as its second operand."}, {"start": "00:08:25", "is_lecture": true, "end": "00:08:33", "is_worked_example": false, "text": "These local transformations are called \"peephole optimizations\" since we're only considering just one or two instructions at a time."}]}, "C09S02B02-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c9/c9s2/2?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c9s2v2", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:12", "is_worked_example": true, "text": "In order to better understand the role of each of the beta control signals, we will work through an example problem that provides us with a partially filled control table for 5 different instructions."}, {"start": "00:00:12", "is_lecture": false, "end": "00:00:19", "is_worked_example": true, "text": "Two of these instructions are existing beta instructions that we must infer from the provided control signals."}, {"start": "00:00:19", "is_lecture": false, "end": "00:00:29", "is_worked_example": true, "text": "The other three are three new instructions that we are adding to our beta by modifying the necessary control signals to produce the desired behavior of each of the operations."}, {"start": "00:00:29", "is_lecture": false, "end": "00:00:37", "is_worked_example": true, "text": "The first instruction that we want to add to our beta is an LDX instruction which is a load that is double indexed."}, {"start": "00:00:37", "is_lecture": false, "end": "00:00:50", "is_worked_example": true, "text": "What this means is that in order to produce the effective address of the load, instead of adding the contents of a register to a constant as is done in the LD instruction, we add the contents of two different registers."}, {"start": "00:00:50", "is_lecture": false, "end": "00:00:57", "is_worked_example": true, "text": "So the address for this load operation is the result of adding together the contents of registers Ra and Rb."}, {"start": "00:00:57", "is_lecture": false, "end": "00:01:04", "is_worked_example": true, "text": "The contents of the memory location pointed to by this effective address are loaded into register Rc."}, {"start": "00:01:04", "is_lecture": false, "end": "00:01:09", "is_worked_example": true, "text": "Finally, the PC is incremented by 4 to point to the next instruction."}, {"start": "00:01:09", "is_lecture": false, "end": "00:01:18", "is_worked_example": true, "text": "The second instruction that we want to add to our beta is a MVZC instruction which is a move constant if zero instruction."}, {"start": "00:01:18", "is_lecture": false, "end": "00:01:29", "is_worked_example": true, "text": "The way this instruction works is that if the contents of register Ra equal zero, then the sign extended version of the literal constant will be loaded into register Rc."}, {"start": "00:01:29", "is_lecture": false, "end": "00:01:35", "is_worked_example": true, "text": "This is followed by incrementing the PC to point to the next instruction."}, {"start": "00:01:35", "is_lecture": false, "end": "00:01:44", "is_worked_example": true, "text": "The third instruction that we want to add to our beta is a STR instruction which is a store relative instruction."}, {"start": "00:01:44", "is_lecture": false, "end": "00:01:54", "is_worked_example": true, "text": "For this instruction, the effective address is computed by sign extending the constant C, multiplying it by 4 and adding it to PC + 4."}, {"start": "00:01:54", "is_lecture": false, "end": "00:02:03", "is_worked_example": true, "text": "The contents of register Rc are then stored at the memory location pointed to by the effective address that was just computed."}, {"start": "00:02:03", "is_lecture": false, "end": "00:02:10", "is_worked_example": true, "text": "As a final step, the PC is incremented by 4 to point to the next instruction."}, {"start": "00:02:10", "is_lecture": false, "end": "00:02:14", "is_worked_example": true, "text": "We are given the partially filled control ROM shown here."}, {"start": "00:02:14", "is_lecture": false, "end": "00:02:18", "is_worked_example": true, "text": "It is our job to fill in all the yellow boxes labeled with a ?."}, {"start": "00:02:18", "is_lecture": false, "end": "00:02:22", "is_worked_example": true, "text": "Let's begin by looking at the top row of this table."}, {"start": "00:02:22", "is_lecture": false, "end": "00:02:29", "is_worked_example": true, "text": "The value that stands out as a bit different in this row is the PCSEL value which is equal to 2."}, {"start": "00:02:29", "is_lecture": false, "end": "00:02:39", "is_worked_example": true, "text": "For most instructions PCSEL equals 0, for branch instructions it equals 1, and for JMP instructions it equals 2."}, {"start": "00:02:39", "is_lecture": false, "end": "00:02:44", "is_worked_example": true, "text": "This means that the instruction described in this row must be a JMP instruction."}, {"start": "00:02:44", "is_lecture": false, "end": "00:02:54", "is_worked_example": true, "text": "Zooming in on the PCSEL control logic from the beta diagram, we see that normally PCSEL = 0 to go to the next instruction."}, {"start": "00:02:54", "is_lecture": false, "end": "00:03:08", "is_worked_example": true, "text": "PCSEL = 1 in order to perform a branch operation, and PCSEL = 2 in order to perform a jump operation where the target of the jump is specified by JT, or the jump target."}, {"start": "00:03:08", "is_lecture": false, "end": "00:03:14", "is_worked_example": true, "text": "This means that the instruction described in this row must be a JMP instruction."}, {"start": "00:03:14", "is_lecture": false, "end": "00:03:17", "is_worked_example": true, "text": "The behavior of a JMP instruction is shown here."}, {"start": "00:03:17", "is_lecture": false, "end": "00:03:26", "is_worked_example": true, "text": "The effective address is calculated by taking the contents of RA and clearing the bottom 2 bits so that the value becomes word aligned."}, {"start": "00:03:26", "is_lecture": false, "end": "00:03:36", "is_worked_example": true, "text": "The address of the next instruction, which is PC + 4, is stored in register Rc in case we need to return to the next instruction in the program."}, {"start": "00:03:36", "is_lecture": false, "end": "00:03:46", "is_worked_example": true, "text": "The PC is then updated with the new effective address in order to actually continue execution at the destination of the JMP instruction."}, {"start": "00:03:46", "is_lecture": false, "end": "00:03:53", "is_worked_example": true, "text": "This dataflow diagram highlights the required dataflow through the beta in order to properly implement the JMP instruction."}, {"start": "00:03:53", "is_lecture": false, "end": "00:04:01", "is_worked_example": true, "text": "Note that no red lines pass through the ALU or memory because the ALU and memory are not used for this instruction."}, {"start": "00:04:01", "is_lecture": false, "end": "00:04:18", "is_worked_example": true, "text": "The control signals that must be set in order to follow this path in the beta are as follows: WDSEL, or write data select, must be set to 0 in order to pass the value of PC + 4 through the WDSEL mux."}, {"start": "00:04:18", "is_lecture": false, "end": "00:04:26", "is_worked_example": true, "text": "WERF, or write enable register file, must be set to 1 in order to enable writing to the register file."}, {"start": "00:04:26", "is_lecture": false, "end": "00:04:37", "is_worked_example": true, "text": "WASEL, or write address select, must be set to 0 in order to write to the Rc register and not to the XP register."}, {"start": "00:04:37", "is_lecture": false, "end": "00:04:43", "is_worked_example": true, "text": "ASEL, BSEL, and ALUFN, are all don't cares for the JMP instruction."}, {"start": "00:04:43", "is_lecture": false, "end": "00:04:52", "is_worked_example": true, "text": "In addition MOE, which stands for memory output enable, is also a don't care because this instruction does not use the memory data."}, {"start": "00:04:52", "is_lecture": false, "end": "00:05:05", "is_worked_example": true, "text": "The one control signal related to the memory that we do need to worry about is the MWR, or memory write read, signal which must be set to 0 so that no value will be written to memory."}, {"start": "00:05:05", "is_lecture": false, "end": "00:05:18", "is_worked_example": true, "text": "Going back to our control ROM and filling in the value of WERF, we see that the control signals for the JMP instruction correspond to the dataflow diagram of the beta that we just looked at."}, {"start": "00:05:18", "is_lecture": false, "end": "00:05:25", "is_worked_example": true, "text": "Moving on to row two of our control ROM, we see that now we have PCSEL = Z in this row."}, {"start": "00:05:25", "is_lecture": false, "end": "00:05:32", "is_worked_example": true, "text": "This suggests that the instruction corresponding to this row is some kind of a branch instruction."}, {"start": "00:05:32", "is_lecture": false, "end": "00:05:38", "is_worked_example": true, "text": "Of our two branch instructions, the one that branches when Z = 1 is BEQ."}, {"start": "00:05:38", "is_lecture": false, "end": "00:05:42", "is_worked_example": true, "text": "This means that this row corresponds to a BEQ operation."}, {"start": "00:05:42", "is_lecture": false, "end": "00:05:59", "is_worked_example": true, "text": "The rest of the control signals for the BEQ operation look just like the ones for the JMP because here too, the ALU and memory are not used so the only ALU and memory related signal that must be set is MWR so we don't write to memory."}, {"start": "00:05:59", "is_lecture": false, "end": "00:06:13", "is_worked_example": true, "text": "Furthermore, like the JMP instruction, the branch instructions also store the return address in register Rc, so the behavior of the control signals related to the register file are all the same."}, {"start": "00:06:13", "is_lecture": false, "end": "00:06:18", "is_worked_example": true, "text": "We now take a look at the third row of the control ROM."}, {"start": "00:06:18", "is_lecture": false, "end": "00:06:25", "is_worked_example": true, "text": "In this row, we are actually told that the corresponding instruction is the newly added LDX instruction."}, {"start": "00:06:25", "is_lecture": false, "end": "00:06:33", "is_worked_example": true, "text": "So it is our job to determine how to set the missing control signals in order to get the desired behavior for this operation."}, {"start": "00:06:33", "is_lecture": false, "end": "00:06:45", "is_worked_example": true, "text": "Recall that the expected behavior of this instruction is that the contents of register Ra and Rb will be added together in order to produce the effective address of the load."}, {"start": "00:06:45", "is_lecture": false, "end": "00:06:49", "is_worked_example": true, "text": "This means that we need to perform an ADD as our ALUFN."}, {"start": "00:06:49", "is_lecture": false, "end": "00:06:58", "is_worked_example": true, "text": "We also need ASEL and BSEL equal to zero in order to pass the values of registers Ra and Rb to the ALU."}, {"start": "00:06:58", "is_lecture": false, "end": "00:07:05", "is_worked_example": true, "text": "The complete dataflow through the register file, ALU, and memory is shown here."}, {"start": "00:07:05", "is_lecture": false, "end": "00:07:11", "is_worked_example": true, "text": "In order to read register Rb rather than Rc, RA2SEL must be set to 0."}, {"start": "00:07:11", "is_lecture": false, "end": "00:07:19", "is_worked_example": true, "text": "As we just mentioned, ASEL and BSEL are set to 0 and ALUFN is set to ADD."}, {"start": "00:07:19", "is_lecture": false, "end": "00:07:24", "is_worked_example": true, "text": "The result of adding registers Ra and Rb is used as the address of the load."}, {"start": "00:07:24", "is_lecture": false, "end": "00:07:29", "is_worked_example": true, "text": "This is called MA, or memory address in the beta diagram."}, {"start": "00:07:29", "is_lecture": false, "end": "00:07:37", "is_worked_example": true, "text": "In order to enable reading from memory, we set MWR to 0 and MOE to 1."}, {"start": "00:07:37", "is_lecture": false, "end": "00:07:44", "is_worked_example": true, "text": "This sets the read/write functionality to read, and enables an output to be read from the read port of the memory."}, {"start": "00:07:44", "is_lecture": false, "end": "00:07:49", "is_worked_example": true, "text": "On the beta diagram, the read data is labeled MRD, or memory read data."}, {"start": "00:07:49", "is_lecture": false, "end": "00:07:56", "is_worked_example": true, "text": "The data that is read from the memory is then passed along to the register file by setting WDSEL = 2."}, {"start": "00:07:56", "is_lecture": false, "end": "00:08:04", "is_worked_example": true, "text": "In order to write this result to register Rc, WERF = 1, and WASEL = 0."}, {"start": "00:08:04", "is_lecture": false, "end": "00:08:11", "is_worked_example": true, "text": "So the completed control ROM for the LDX operation is shown here."}, {"start": "00:08:11", "is_lecture": false, "end": "00:08:15", "is_worked_example": true, "text": "We now move on to the fourth instruction."}, {"start": "00:08:15", "is_lecture": false, "end": "00:08:21", "is_worked_example": true, "text": "Here we see that the ALUFN just passes operand B through the register file."}, {"start": "00:08:21", "is_lecture": false, "end": "00:08:25", "is_worked_example": true, "text": "We also see that WERF is dependent on the value of Z."}, {"start": "00:08:25", "is_lecture": false, "end": "00:08:37", "is_worked_example": true, "text": "This means that the instruction that corresponds to this row is MVZC which moves a constant into register Rc if the contents of register Ra = 0."}, {"start": "00:08:37", "is_lecture": false, "end": "00:08:51", "is_worked_example": true, "text": "The way this instruction works is that BSEL = 1 in order to pass the constant through as the B operand, and ALUFN = B to pass that constant through the ALU."}, {"start": "00:08:51", "is_lecture": false, "end": "00:08:58", "is_worked_example": true, "text": "WDSEL = 1 so that the output of the ALU is fed back as the write value for the register file."}, {"start": "00:08:58", "is_lecture": false, "end": "00:09:08", "is_worked_example": true, "text": "Because WDSEL = 1 and not 2, we know that the data coming out of the memory will be ignored so MOE can be a don't care."}, {"start": "00:09:08", "is_lecture": false, "end": "00:09:16", "is_worked_example": true, "text": "Of course, MWR still must be set to 0 in order to ensure that we don't write any random values into our memory."}, {"start": "00:09:16", "is_lecture": false, "end": "00:09:29", "is_worked_example": true, "text": "RA2SEL is also a don't care because we don't care whether Register Rb or Register Rc are passed through as the second read argument of the register file, RD2."}, {"start": "00:09:29", "is_lecture": false, "end": "00:09:41", "is_worked_example": true, "text": "The reason we don't care is because the BSEL = 1 will ignore the RD2 value and pass through the constant that comes directly from the instruction after sign extending it."}, {"start": "00:09:41", "is_lecture": false, "end": "00:09:49", "is_worked_example": true, "text": "ASEL is also a don't care because the ALU will ignore the A input when ALUFN = B."}, {"start": "00:09:49", "is_lecture": false, "end": "00:09:57", "is_worked_example": true, "text": "WASEL must be 0 so that the result of the operation is written into register Rc."}, {"start": "00:09:57", "is_lecture": false, "end": "00:10:08", "is_worked_example": true, "text": "Finally, PCSEL = 0 to load PC + 4 into the PC register so that the next instruction will get fetched after this one."}, {"start": "00:10:08", "is_lecture": false, "end": "00:10:12", "is_worked_example": true, "text": "We are now on the last row of our control ROM."}, {"start": "00:10:12", "is_lecture": false, "end": "00:10:20", "is_worked_example": true, "text": "We know that this row must correspond to our third added instruction which is STR, or store relative."}, {"start": "00:10:20", "is_lecture": false, "end": "00:10:29", "is_worked_example": true, "text": "Recall that this instruction writes the contents of register Rc into memory at the address that is computed by the effective address line."}, {"start": "00:10:29", "is_lecture": false, "end": "00:10:37", "is_worked_example": true, "text": "The effective address for this instruction is PC + 4 + 4 * SEXT(C)."}, {"start": "00:10:37", "is_lecture": false, "end": "00:10:47", "is_worked_example": true, "text": "The extra adder, just under the instruction memory, is used to calculate PC + 4 + 4 * SEXT(C)."}, {"start": "00:10:47", "is_lecture": false, "end": "00:10:54", "is_worked_example": true, "text": "This value is then fed to the ALU via the A operand by setting ASEL = 1."}, {"start": "00:10:54", "is_lecture": false, "end": "00:11:04", "is_worked_example": true, "text": "Setting ALUFN = A passes this value as the output of the ALU in order to be used as the memory address."}, {"start": "00:11:04", "is_lecture": false, "end": "00:11:07", "is_worked_example": true, "text": "This is the address that the store will write to in memory."}, {"start": "00:11:07", "is_lecture": false, "end": "00:11:13", "is_worked_example": true, "text": "The value that will be written to this address in memory is the contents of register Rc."}, {"start": "00:11:13", "is_lecture": false, "end": "00:11:20", "is_worked_example": true, "text": "Register Rc is fed through the register file by setting RA2SEL = 1."}, {"start": "00:11:20", "is_lecture": false, "end": "00:11:25", "is_worked_example": true, "text": "This makes RD2 have the contents of register Rc."}, {"start": "00:11:25", "is_lecture": false, "end": "00:11:35", "is_worked_example": true, "text": "This value then becomes the MWD, or memory write data which is the data that will be stored in the memory address that was produced by the ALU."}, {"start": "00:11:35", "is_lecture": false, "end": "00:11:40", "is_worked_example": true, "text": "In order to enable writing to the memory, MWR must be set to 1."}, {"start": "00:11:40", "is_lecture": false, "end": "00:11:45", "is_worked_example": true, "text": "Since WERF = 0, nothing can be written to the register file."}, {"start": "00:11:45", "is_lecture": false, "end": "00:11:54", "is_worked_example": true, "text": "This means that the value of MASEL and MDSEL are don't cares since the register file won't be affected regardless of their values."}, {"start": "00:11:54", "is_lecture": false, "end": "00:12:00", "is_worked_example": true, "text": "Finally, the PC is incremented by 4 to fetch the next instruction."}, {"start": "00:12:00", "is_lecture": false, "end": "00:12:08", "is_worked_example": true, "text": "So our completed Control ROM for the STR operation is shown here."}]}, "C06S01B06-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c6/c6s1/6?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c6s1v6", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:11", "is_worked_example": false, "text": "A modern compiler starts by analyzing the source program text to produce an equivalent sequence of operations expressed in a language- and machine-independent intermediate representation (IR)."}, {"start": "00:00:11", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "The analysis, or frontend, phase checks that program is well-formed, i.e., that the syntax of each high-level language statement is correct."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:25", "is_worked_example": false, "text": "It understands the meaning (semantics) of each statement."}, {"start": "00:00:25", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "Many high-level languages include declarations of the type -- e.g., integer, floating point, string, etc. -- of each variable,"}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:45", "is_worked_example": false, "text": "and the frontend verifies that all operations are correctly applied, ensuring that numeric operations have numeric-type operands, string operations have string-type operands, and so on."}, {"start": "00:00:45", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "Basically the analysis phase converts the text of the source program into an internal data structure that specifies the sequence and type of operations to be performed."}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:09", "is_worked_example": false, "text": "Often there are families of frontend programs that translate a variety of high-level languages (e.g, C, C++, Java) into a common IR."}, {"start": "00:01:09", "is_lecture": true, "end": "00:01:19", "is_worked_example": false, "text": "The synthesis, or backend, phase then optimizes the IR to reduce the number of operations that will be executed when the final code is run."}, {"start": "00:01:19", "is_lecture": true, "end": "00:01:31", "is_worked_example": false, "text": "For example, it might find operations inside of a loop that are independent of the loop index and can moved outside the loop, where they are performed once instead of repeatedly inside the loop."}, {"start": "00:01:31", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "Once the IR is in its final optimized form, the backend generates code sequences for the target ISA and looks for further optimizations that take advantage of particular features of the ISA."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "For example, for the Beta ISA we saw how a CMOVE followed by an arithmetic operation can be shorted to a single operation with a constant operand."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:06", "is_worked_example": false, "text": "The analysis phase starts by scanning the source text and generating a sequence of token objects that identify the type of each piece of the source text."}, {"start": "00:02:06", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "While spaces, tabs, newlines, and so on were needed to separate tokens in the source text, they've all been removed during the scanning process."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "To enable useful error reporting, token objects also include information about where in the source text each token was found, e.g., the file name, line number, and column number."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "The scanning phase reports illegal tokens, e.g., the token \"3x\" would cause an error since in C it would not be a legal number or a legal variable name."}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "The parsing phase processes the sequence of tokens to build the syntax tree, which captures the structure of the original program in a convenient data structure."}, {"start": "00:02:50", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "The operands have been organized for each unary and binary operation."}, {"start": "00:02:55", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "The components of each statement have been found and labeled."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "The role of each source token has been determined and the information captured in the syntax tree."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:11", "is_worked_example": false, "text": "Compare the labels of the nodes in the tree to the templates we discussed in the previous segment."}, {"start": "00:03:11", "is_lecture": true, "end": "00:03:21", "is_worked_example": false, "text": "We can see that it would be easy to write a program that did a depth-first tree walk, using the label of each tree node to select the appropriate code generation template."}, {"start": "00:03:21", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "We won't do that quite yet since there's still some work to be done analyzing and transforming the tree."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:37", "is_worked_example": false, "text": "The syntax tree makes it easy to verify that the program is semantically correct, e.g., to check that the types of the operands are compatible with the requested operation."}, {"start": "00:03:37", "is_lecture": true, "end": "00:03:42", "is_worked_example": false, "text": "For example, consider the statement x = \"bananas\"."}, {"start": "00:03:42", "is_lecture": true, "end": "00:03:50", "is_worked_example": false, "text": "The syntax of the assignment operation is correct: there's a variable on the left-hand side and an expression on the right-hand side."}, {"start": "00:03:50", "is_lecture": true, "end": "00:03:53", "is_worked_example": false, "text": "But the semantics is not correct, at least in the C language!"}, {"start": "00:03:53", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "By looking in its symbol table to check the declared type for the variable x (int) and comparing it to the type of the expression (string),"}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:15", "is_worked_example": false, "text": "the semantic checker for the \"op =\" tree node will detect that the types are not compatible, i.e., that we can't store a string value into an integer variable."}, {"start": "00:04:15", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "When the semantic analysis is complete, we know that the syntax tree represents a syntactically correct program with valid semantics, and we've finished converting the source program into an equivalent, language-independent sequence of operations."}]}, "C04S03B10-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c4/c4s1/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c4s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "This video is optional, but we wanted to answer the question \"Are there uncomputable functions?\""}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "Yes, there are well-defined discrete functions that cannot be computed by any TM, i.e., no algorithm can compute f(x) for arbitrary finite x in a finite number of steps."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:27", "is_worked_example": false, "text": "It's not that we don't know the algorithm, we can actually prove that no algorithm exists."}, {"start": "00:00:27", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "So the finite memory limitations of FSMs wasn't the only barrier as to whether we can solve a problem."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:41", "is_worked_example": false, "text": "The most famous uncomputable function is the so-called Halting function."}, {"start": "00:00:41", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "When TMs undertake a computation there two possible outcomes."}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:52", "is_worked_example": false, "text": "Either the TM writes an answer onto the tape and halts, or the TM loops forever."}, {"start": "00:00:52", "is_lecture": true, "end": "00:00:56", "is_worked_example": false, "text": "The Halting function tells which outcome we'll get:"}, {"start": "00:00:56", "is_lecture": true, "end": "00:01:08", "is_worked_example": false, "text": "given two integer arguments k and j, the Halting function determines if the kth TM halts when given a tape containing j as the input."}, {"start": "00:01:08", "is_lecture": true, "end": "00:01:14", "is_worked_example": false, "text": "Let's quick sketch an argument as to why the Halting function is not computable."}, {"start": "00:01:14", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "Well, suppose it was computable, then it would be equivalent to some TM, say T_H."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "So we can use T_H to build another TM, T_N (the \"N\" stands for nasty!) that processes its single argument and either LOOPs or HALTs."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "T_N[X] is designed to loop if TM X given input X halts."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "And vice versa: T_N[X] halts if TM X given input X loops."}, {"start": "00:01:48", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "The idea is that T_N[X] does the opposite of whatever T_X[X] does."}, {"start": "00:01:56", "is_lecture": true, "end": "00:02:02", "is_worked_example": false, "text": "T_N is easy to implement assuming that we have T_H to answer the \"halts or loops\" question."}, {"start": "00:02:02", "is_lecture": true, "end": "00:02:09", "is_worked_example": false, "text": "Now consider what happens if we give N as the argument to T_N."}, {"start": "00:02:09", "is_lecture": true, "end": "00:02:20", "is_worked_example": false, "text": "From the definition of T_N, T_N[N] will LOOP if the halting function tells us that T_N[N] halts."}, {"start": "00:02:20", "is_lecture": true, "end": "00:02:31", "is_worked_example": false, "text": "And T_N[N] will HALT if the halting function tells us that T_N[N] loops."}, {"start": "00:02:31", "is_lecture": true, "end": "00:02:37", "is_worked_example": false, "text": "Obviously T_N[N] can't both LOOP and HALT at the same time!"}, {"start": "00:02:37", "is_lecture": true, "end": "00:02:48", "is_worked_example": false, "text": "So if the Halting function is computable and T_H exists, we arrive at this impossible behavior for T_N[N]."}, {"start": "00:02:48", "is_lecture": true, "end": "00:02:56", "is_worked_example": false, "text": "This tells us that T_H cannot exist and hence that the Halting function is not computable."}]}, "C11S01B11-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/11?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v11", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "A fully-associative (FA) cache has a tag comparator for each cache line."}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:11", "is_worked_example": false, "text": "So the tag field of *every* cache line in a FA cache is compared with the tag field of the incoming address."}, {"start": "00:00:11", "is_lecture": true, "end": "00:00:22", "is_worked_example": false, "text": "Since all cache lines are searched, a particular memory location can be held in any cache line, which eliminates the problems of address conflicts causing conflict misses."}, {"start": "00:00:22", "is_lecture": true, "end": "00:00:30", "is_worked_example": false, "text": "The cache shown here can hold 4 different 4-word blocks, regardless of their address."}, {"start": "00:00:30", "is_lecture": true, "end": "00:00:39", "is_worked_example": false, "text": "The example from the end of the previous segment required a cache that could hold two 3-word blocks, one for the instructions in the loop, and one for the data words."}, {"start": "00:00:39", "is_lecture": true, "end": "00:00:52", "is_worked_example": false, "text": "This FA cache would use two of its cache lines to perform that task and achieve a 100% hit ratio regardless of the addresses of the instruction and data blocks."}, {"start": "00:00:52", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "FA caches are very flexible and have high hit ratios for most applications."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:01", "is_worked_example": false, "text": "Their only downside is cost."}, {"start": "00:01:01", "is_lecture": true, "end": "00:01:14", "is_worked_example": false, "text": "The inclusion of a tag comparator for each cache line to implement the parallel search for a tag match adds substantially the amount of circuitry required when there are many cache lines."}, {"start": "00:01:14", "is_lecture": true, "end": "00:01:25", "is_worked_example": false, "text": "Even the use of hybrid storage/comparison circuitry, called a content-addressable memory, doesn't make a big dent in the overall cost of a FA cache."}, {"start": "00:01:25", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "DM caches searched only a single cache line."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "FA caches search all cache lines."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:39", "is_worked_example": false, "text": "Is there a happy middle ground where some small number of cache lines are searched in parallel?"}, {"start": "00:01:39", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "Yes!"}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:51", "is_worked_example": false, "text": "If you look closely at the diagram of the FA cache shown here, you'll see it looks like four 1-line DM caches operating in parallel."}, {"start": "00:01:51", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "What would happen if we designed a cache with four multi-line DM caches operating in parallel?"}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:02", "is_worked_example": false, "text": "The result would be what we call an 4-way set-associative (SA) cache."}, {"start": "00:02:02", "is_lecture": true, "end": "00:02:11", "is_worked_example": false, "text": "An N-way SA cache is really just N DM caches (let's call them sub-caches) operating in parallel."}, {"start": "00:02:11", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "Each of the N sub-caches compares the tag field of the incoming address with the tag field of the cache line selected by the index bits of the incoming address."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:31", "is_worked_example": false, "text": "The N cache lines searched on a particular request form a search \"set\" and the desired location might be held in any member of the set."}, {"start": "00:02:31", "is_lecture": true, "end": "00:02:47", "is_worked_example": false, "text": "The 4-way SA cache shown here has 8 cache lines in each sub-cache, so each set contains 4 cache lines (one from each sub-cache) and there are a total of 8 sets (one for each line of the sub-caches)."}, {"start": "00:02:47", "is_lecture": true, "end": "00:02:56", "is_worked_example": false, "text": "An N-way SA cache can accommodate up to N blocks whose addresses map to the same cache index."}, {"start": "00:02:56", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "So access to up to N blocks with conflicting addresses can still be accommodated in this cache without misses."}, {"start": "00:03:04", "is_lecture": true, "end": "00:03:15", "is_worked_example": false, "text": "This a big improvement over a DM cache where an address conflict will cause the current resident of a cache line to be evicted in favor of the new request."}, {"start": "00:03:15", "is_lecture": true, "end": "00:03:25", "is_worked_example": false, "text": "And an N-way SA cache can have a very large number of cache lines but still only have to pay the cost of N tag comparators."}, {"start": "00:03:25", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "This is a big improvement over a FA cache where a large number of cache lines would require a large number of comparators."}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:45", "is_worked_example": false, "text": "So N-way SA caches are a good compromise between a conflict-prone DM cache and the flexible but very expensive FA cache."}, {"start": "00:03:45", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "Here's a slightly more detailed diagram, in this case of a 3-way 8-set cache."}, {"start": "00:03:52", "is_lecture": true, "end": "00:04:00", "is_worked_example": false, "text": "Note that there's no constraint that the number of ways be a power of two since we aren't using any address bits to select a particular way."}, {"start": "00:04:00", "is_lecture": true, "end": "00:04:06", "is_worked_example": false, "text": "This means the cache designer can fine tune the cache capacity to fit her space budget."}, {"start": "00:04:06", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "Just to review the terminology: the N cache lines that will be searched for a particular cache index are called a set."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:18", "is_worked_example": false, "text": "And each of N sub-caches is called a way."}, {"start": "00:04:18", "is_lecture": true, "end": "00:04:23", "is_worked_example": false, "text": "The hit logic in each \"way\" operates in parallel with the logic in other ways."}, {"start": "00:04:23", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "Is it possible for a particular address to be matched by more than one way?"}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:36", "is_worked_example": false, "text": "That possibility isn't ruled out by the hardware, but the SA cache is managed so that doesn't happen."}, {"start": "00:04:36", "is_lecture": true, "end": "00:04:46", "is_worked_example": false, "text": "Assuming we write the data fetched from DRAM during a cache miss into a single sub-cache -- we'll talk about how to choose that way in a minute --"}, {"start": "00:04:46", "is_lecture": true, "end": "00:04:51", "is_worked_example": false, "text": "there's no possibility that more than one sub-cache will ever match an incoming address."}, {"start": "00:04:51", "is_lecture": true, "end": "00:04:53", "is_worked_example": false, "text": "How many ways to do we need?"}, {"start": "00:04:53", "is_lecture": true, "end": "00:04:59", "is_worked_example": false, "text": "We'd like enough ways to avoid the cache line conflicts we experienced with the DM cache."}, {"start": "00:04:59", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "Looking at the graph we saw earlier of memory accesses vs. time, we see that in any time interval there are only so many potential address conflicts that we need to worry about."}, {"start": "00:05:10", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "The mapping from addresses to cache lines is designed to avoid conflicts between neighboring locations."}, {"start": "00:05:17", "is_lecture": true, "end": "00:05:24", "is_worked_example": false, "text": "So we only need to worry about conflicts between the different regions: code, stack and data."}, {"start": "00:05:24", "is_lecture": true, "end": "00:05:33", "is_worked_example": false, "text": "In the examples shown here there are three such regions, maybe 4 if you need two data regions to support copying from one data region to another."}, {"start": "00:05:33", "is_lecture": true, "end": "00:05:42", "is_worked_example": false, "text": "If the time interval is particularly large, we might need double that number to avoid conflicts between accesses early in the time interval and accesses late in the time interval."}, {"start": "00:05:42", "is_lecture": true, "end": "00:05:49", "is_worked_example": false, "text": "The point is that a small number of ways should be sufficient to avoid most cache line conflicts in the cache."}, {"start": "00:05:49", "is_lecture": true, "end": "00:06:00", "is_worked_example": false, "text": "As with block size, it's possible to have too much of a good thing: there's an optimum number of ways that minimizes the AMAT."}, {"start": "00:06:00", "is_lecture": true, "end": "00:06:14", "is_worked_example": false, "text": "Beyond that point, the additional circuity needed to combine the hit signals from a large number of ways will start have a significant propagation delay of its own, adding directly to the cache hit time and the AMAT."}, {"start": "00:06:14", "is_lecture": true, "end": "00:06:21", "is_worked_example": false, "text": "More to the point, the chart on the left shows that there's little additional impact on the miss ratio beyond 4 to 8 ways."}, {"start": "00:06:21", "is_lecture": true, "end": "00:06:32", "is_worked_example": false, "text": "For most programs, an 8-way set-associative cache with a large number of sets will perform on a par with the much more-expensive FA cache of equivalent capacity."}, {"start": "00:06:32", "is_lecture": true, "end": "00:06:39", "is_worked_example": false, "text": "There's one final issue to resolve with SA and FA caches."}, {"start": "00:06:39", "is_lecture": true, "end": "00:06:46", "is_worked_example": false, "text": "When there's a cache miss, which cache line should be chosen to hold the data that will be fetched from main memory?"}, {"start": "00:06:46", "is_lecture": true, "end": "00:06:55", "is_worked_example": false, "text": "That's not an issue with DM caches, since each data block can only be held in one particular cache line, determined by its address."}, {"start": "00:06:55", "is_lecture": true, "end": "00:07:03", "is_worked_example": false, "text": "But in N-way SA caches, there are N possible cache lines to choose from, one in each of the ways."}, {"start": "00:07:03", "is_lecture": true, "end": "00:07:07", "is_worked_example": false, "text": "And in a FA cache, any of the cache lines can be chosen."}, {"start": "00:07:07", "is_lecture": true, "end": "00:07:10", "is_worked_example": false, "text": "So, how to choose?"}, {"start": "00:07:10", "is_lecture": true, "end": "00:07:17", "is_worked_example": false, "text": "Our goal is to choose to replace the contents of the cache line which will minimize the impact on the hit ratio in the future."}, {"start": "00:07:17", "is_lecture": true, "end": "00:07:25", "is_worked_example": false, "text": "The optimal choice is to replace the block that is accessed furthest in the future (or perhaps is never accessed again)."}, {"start": "00:07:25", "is_lecture": true, "end": "00:07:28", "is_worked_example": false, "text": "But that requires knowing the future..."}, {"start": "00:07:28", "is_lecture": true, "end": "00:07:42", "is_worked_example": false, "text": "Here's an idea: let's predict future accesses by looking a recent accesses and applying the principle of locality. d7.36 If a block has not been recently accessed, it's less likely to be accessed in the near future."}, {"start": "00:07:42", "is_lecture": true, "end": "00:07:53", "is_worked_example": false, "text": "That suggests the least-recently-used replacement strategy, usually referred to as LRU: replace the block that was accessed furthest in the past."}, {"start": "00:07:53", "is_lecture": true, "end": "00:08:05", "is_worked_example": false, "text": "LRU works well in practice, but requires us to keep a list ordered by last use for each set of cache lines, which would need to be updated on each cache access."}, {"start": "00:08:05", "is_lecture": true, "end": "00:08:11", "is_worked_example": false, "text": "When we needed to choose which member of a set to replace, we'd choose the last cache line on this list."}, {"start": "00:08:11", "is_lecture": true, "end": "00:08:23", "is_worked_example": false, "text": "For an 8-way SA cache there are 8! possible orderings, so we'd need log2(8!) = 16 state bits to encode the current ordering."}, {"start": "00:08:23", "is_lecture": true, "end": "00:08:27", "is_worked_example": false, "text": "The logic to update these state bits on each access isn't cheap."}, {"start": "00:08:27", "is_lecture": true, "end": "00:08:33", "is_worked_example": false, "text": "Basically you need a lookup table to map the current 16-bit value to the next 16-bit value."}, {"start": "00:08:33", "is_lecture": true, "end": "00:08:40", "is_worked_example": false, "text": "So most caches implement an approximation to LRU where the update function is much simpler to compute."}, {"start": "00:08:40", "is_lecture": true, "end": "00:08:44", "is_worked_example": false, "text": "There are other possible replacement policies:"}, {"start": "00:08:44", "is_lecture": true, "end": "00:08:50", "is_worked_example": false, "text": "First-in, first-out, where the oldest cache line is replaced regardless of when it was last accessed."}, {"start": "00:08:50", "is_lecture": true, "end": "00:08:56", "is_worked_example": false, "text": "And Random, where some sort of pseudo-random number generator is used to select the replacement."}, {"start": "00:08:56", "is_lecture": true, "end": "00:09:00", "is_worked_example": false, "text": "All replacement strategies except for random can be defeated."}, {"start": "00:09:00", "is_lecture": true, "end": "00:09:10", "is_worked_example": false, "text": "If you know a cache's replacement strategy you can design a program that will have an abysmal hit rate by accessing addresses you know the cache just replaced."}, {"start": "00:09:10", "is_lecture": true, "end": "00:09:24", "is_worked_example": false, "text": "I'm not sure I care about how well a program designed to get bad performance runs on my system, but the point is that most replacement strategies will occasionally cause a particular program to execute much more slowly than expected."}, {"start": "00:09:24", "is_lecture": true, "end": "00:09:32", "is_worked_example": false, "text": "When all is said and done, an LRU replacement strategy or a close approximation is a reasonable choice."}]}, "C11S01B08-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/8?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v8", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "The simplest cache hardware consists of an SRAM with a few additional pieces of logic."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "The cache hardware is designed so that each memory location in the CPU's address space maps to a particular cache line, hence the name \"direct-mapped (DM) cache\"."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "There are, of course, many more memory locations then there are cache lines, so many addresses are mapped to the same cache line and the cache will only be able to hold the data for one of those addresses at a time."}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:34", "is_worked_example": false, "text": "The operation of a DM cache is straightforward."}, {"start": "00:00:34", "is_lecture": true, "end": "00:00:40", "is_worked_example": false, "text": "We'll use part of the incoming address as an index to select a single cache line to be searched."}, {"start": "00:00:40", "is_lecture": true, "end": "00:00:47", "is_worked_example": false, "text": "The \"search\" consists of comparing the rest of the incoming address with the address tag of the selected cache line."}, {"start": "00:00:47", "is_lecture": true, "end": "00:00:56", "is_worked_example": false, "text": "If the tag matches the address, there's a cache hit and we can immediately use the data in the cache to satisfy the request."}, {"start": "00:00:56", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "In this design, we've included an additional \"valid bit\" which is 1 when the tag and data fields hold valid information."}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:14", "is_worked_example": false, "text": "The valid bit for each cache line is initialized to 0 when the cache is powered on, indicating that all cache lines are empty."}, {"start": "00:01:14", "is_lecture": true, "end": "00:01:22", "is_worked_example": false, "text": "As data is brought into the cache, the valid bit is set to 1 when the cache line's tag and data fields are filled."}, {"start": "00:01:22", "is_lecture": true, "end": "00:01:29", "is_worked_example": false, "text": "The CPU can request that the valid bit be cleared for a particular cache line -- this is called \"flushing the cache\"."}, {"start": "00:01:29", "is_lecture": true, "end": "00:01:41", "is_worked_example": false, "text": "If, for example, the CPU initiates a read from disk, the disk hardware will read its data into a block of main memory, so any cached values for that block will out-of-date."}, {"start": "00:01:41", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "So the CPU will flush those locations from the cache by marking any matching cache lines as invalid."}, {"start": "00:01:48", "is_lecture": true, "end": "00:01:59", "is_worked_example": false, "text": "Let's see how this works using a small DM cache with 8 lines where each cache line contains a single word (4 bytes) of data."}, {"start": "00:01:59", "is_lecture": true, "end": "00:02:05", "is_worked_example": false, "text": "Here's a CPU request for the location at byte address 0xE8."}, {"start": "00:02:05", "is_lecture": true, "end": "00:02:13", "is_worked_example": false, "text": "Since there 4 bytes of data in each cache line, the bottom 2 address bits indicate the appropriate byte offset into the cached word."}, {"start": "00:02:13", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "Since the cache deals only with word accesses, the byte offset bits aren't used."}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "Next, we'll need to use 3 address bits to select which of the 8 cache lines to search."}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:30", "is_worked_example": false, "text": "We choose these cache index bits from the low-order bits of the address."}, {"start": "00:02:30", "is_lecture": true, "end": "00:02:32", "is_worked_example": false, "text": "Why?"}, {"start": "00:02:32", "is_lecture": true, "end": "00:02:35", "is_worked_example": false, "text": "Well, it's because of locality."}, {"start": "00:02:35", "is_lecture": true, "end": "00:02:49", "is_worked_example": false, "text": "The principle of locality tells us that it's likely that the CPU will be requesting nearby addresses and for the cache to perform well, we'd like to arrange for nearby locations to be able to be held in the cache at the same time."}, {"start": "00:02:49", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "This means that nearby locations will have to be mapped to different cache lines."}, {"start": "00:02:55", "is_lecture": true, "end": "00:03:07", "is_worked_example": false, "text": "The addresses of nearby locations differ in their low-order address bits, so we'll use those bits as the cache index bits -- that way nearby locations will map to different cache lines."}, {"start": "00:03:07", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "The data, tag and valid bits selected by the cache line index are read from the SRAM."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:20", "is_worked_example": false, "text": "To complete the search, we check the remaining address against the tag field of the cache."}, {"start": "00:03:20", "is_lecture": true, "end": "00:03:27", "is_worked_example": false, "text": "If they're equal and the valid bit is 1, we have a cache hit, and the data field can be used to satisfy the request."}, {"start": "00:03:27", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "How come the tag field isn't 32 bits, since we have a 32-bit address?"}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:47", "is_worked_example": false, "text": "We could have done that, but since all values stored in cache line 2 will have the same index bits (0b010), we saved a few bits of SRAM and chose not save those bits in the tag."}, {"start": "00:03:47", "is_lecture": true, "end": "00:03:53", "is_worked_example": false, "text": "In other words, there's no point in using SRAM to save bits we can generate from the incoming address."}, {"start": "00:03:53", "is_lecture": true, "end": "00:04:03", "is_worked_example": false, "text": "So the cache hardware in this example is an 8-location by 60 bit SRAM plus a 27-bit comparator and a single AND gate."}, {"start": "00:04:03", "is_lecture": true, "end": "00:04:11", "is_worked_example": false, "text": "The cache access time is the access time of the SRAM plus the propagation delays of the comparator and AND gate."}, {"start": "00:04:11", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "About as simple and fast as we could hope for."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:26", "is_worked_example": false, "text": "The downside of the simplicity is that for each CPU request, we're only looking in a single cache location to see if the cache holds the desired data."}, {"start": "00:04:26", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "Not much of \"search\" is it?"}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "But the mapping of addresses to cache lines helps us out here."}, {"start": "00:04:33", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "Using the low-order address bit as the cache index, we've arranged for nearby locations to be mapped to different cache lines."}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:47", "is_worked_example": false, "text": "So, for example, if the CPU were executing an 8-instruction loop, all 8 instructions can be held in the cache at the same time."}, {"start": "00:04:47", "is_lecture": true, "end": "00:04:51", "is_worked_example": false, "text": "A more complicated search mechanism couldn't improve on that."}, {"start": "00:04:51", "is_lecture": true, "end": "00:04:59", "is_worked_example": false, "text": "The bottom line: this extremely simple \"search\" is sufficient to get good cache hit ratios for the cases we care about."}, {"start": "00:04:59", "is_lecture": true, "end": "00:05:05", "is_worked_example": false, "text": "Let's try a few more examples, in this case using a DM cache with 64 lines."}, {"start": "00:05:05", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "Suppose the cache gets a read request for location 0x400C."}, {"start": "00:05:10", "is_lecture": true, "end": "00:05:20", "is_worked_example": false, "text": "To see how the request is processed, we first write the address in binary so we can easily divide it into the offset, index and tag fields."}, {"start": "00:05:20", "is_lecture": true, "end": "00:05:30", "is_worked_example": false, "text": "For this address the offset bits have the value 0, the cache line index bits have the value 3, and the tag bits have the value 0x40."}, {"start": "00:05:30", "is_lecture": true, "end": "00:05:36", "is_worked_example": false, "text": "So the tag field of cache line 3 is compared with the tag field of the address."}, {"start": "00:05:36", "is_lecture": true, "end": "00:05:44", "is_worked_example": false, "text": "Since there's a match, we have a cache hit and the value in the data field of cache line can be used to satisfy the request."}, {"start": "00:05:44", "is_lecture": true, "end": "00:05:50", "is_worked_example": false, "text": "Would an access to location 0x4008 be a cache hit?"}, {"start": "00:05:50", "is_lecture": true, "end": "00:05:57", "is_worked_example": false, "text": "This address is similar to that in our first example, except the cache line index is now 2 instead of 3."}, {"start": "00:05:57", "is_lecture": true, "end": "00:06:08", "is_worked_example": false, "text": "Looking in cache line 2, we that its tag field (0x58) doesn't match the tag field in the address (0x40), so this access would be a cache miss."}, {"start": "00:06:08", "is_lecture": true, "end": "00:06:16", "is_worked_example": false, "text": "What are the addresses of the words held by cache lines 0, 1, and 2, all of which have the same tag field?"}, {"start": "00:06:16", "is_lecture": true, "end": "00:06:21", "is_worked_example": false, "text": "Well, we can run the address matching process backwards!"}, {"start": "00:06:21", "is_lecture": true, "end": "00:06:34", "is_worked_example": false, "text": "For an address to match these three cache lines it would have look like the binary shown here, where we've used the information in the cache tag field to fill in the high-order address bits and low-order address bits will come from the index value."}, {"start": "00:06:34", "is_lecture": true, "end": "00:06:48", "is_worked_example": false, "text": "If we fill in the indices 0, 1, and 2, then convert the resulting binary to hex we get 0x5800, 0x5804, and 0x5808 as the addresses for the data held in cache lines 0, 1, and 2."}, {"start": "00:06:48", "is_lecture": true, "end": "00:06:59", "is_worked_example": false, "text": "Note that the complete address of the cached locations is formed by combining the tag field of the cache line with the index of the cache line."}, {"start": "00:06:59", "is_lecture": true, "end": "00:07:09", "is_worked_example": false, "text": "We of course need to be able to recover the complete address from the information held in the cache so it can be correctly compared against address requests from the CPU."}]}, "C07S02B01-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c7/c7s2/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c7s2v1", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:10", "is_worked_example": true, "text": "In order to understand how procedures are implemented on the beta, we will take a look at a mystery function and its translation into beta assembly code."}, {"start": "00:00:10", "is_lecture": false, "end": "00:00:14", "is_worked_example": true, "text": "The mystery function is shown here:"}, {"start": "00:00:14", "is_lecture": false, "end": "00:00:18", "is_worked_example": true, "text": "The function f takes an argument x as an input."}, {"start": "00:00:18", "is_lecture": false, "end": "00:00:25", "is_worked_example": true, "text": "It then performs a logical AND operation on the input x and the constant 5 to produce the variable a."}, {"start": "00:00:25", "is_lecture": false, "end": "00:00:36", "is_worked_example": true, "text": "After that, it checks if the input x is equal to 0, and if so returns the value 0, otherwise it returns an unknown value which we need to determine."}, {"start": "00:00:36", "is_lecture": false, "end": "00:00:43", "is_worked_example": true, "text": "We are provided with the translation of this C code into beta assembly as shown here."}, {"start": "00:00:43", "is_lecture": false, "end": "00:00:51", "is_worked_example": true, "text": "We take a closer look at the various parts of this code to understand how this function as well as procedures in general work on the beta."}, {"start": "00:00:51", "is_lecture": false, "end": "00:00:58", "is_worked_example": true, "text": "The code that calls the procedure is responsible for pushing any arguments onto the stack."}, {"start": "00:00:58", "is_lecture": false, "end": "00:01:02", "is_worked_example": true, "text": "This is shown in pink in the code and on the stack."}, {"start": "00:01:02", "is_lecture": false, "end": "00:01:16", "is_worked_example": true, "text": "If there are multiple arguments then they are pushed in reverse order so that the first argument is always in the same location relative to the BP, or base pointer, register which we will see in a moment."}, {"start": "00:01:16", "is_lecture": false, "end": "00:01:27", "is_worked_example": true, "text": "The BR instruction branches to label f after storing the return address, which is b, into the LP, or linkage pointer, register."}, {"start": "00:01:27", "is_lecture": false, "end": "00:01:32", "is_worked_example": true, "text": "In yellow, we see the entry sequence for the procedure."}, {"start": "00:01:32", "is_lecture": false, "end": "00:01:36", "is_worked_example": true, "text": "The structure of this entry sequence is identical for all procedures."}, {"start": "00:01:36", "is_lecture": false, "end": "00:01:47", "is_worked_example": true, "text": "The first thing it does is PUSH(LP) which pushes the LP register onto the stack immediately after the arguments that were pushed onto the stack by the caller."}, {"start": "00:01:47", "is_lecture": false, "end": "00:01:56", "is_worked_example": true, "text": "Next it pushes the BP onto the stack in order to save the most recent value of the BP register before updating it."}, {"start": "00:01:56", "is_lecture": false, "end": "00:02:01", "is_worked_example": true, "text": "Now, a MOVE(SP, BP) is performed."}, {"start": "00:02:01", "is_lecture": false, "end": "00:02:07", "is_worked_example": true, "text": "SP is the stack pointer which always points to the next empty location on the stack."}, {"start": "00:02:07", "is_lecture": false, "end": "00:02:15", "is_worked_example": true, "text": "At the time that this MOVE operation is executed, the SP, points to the location immediately following the saved BP."}, {"start": "00:02:15", "is_lecture": false, "end": "00:02:27", "is_worked_example": true, "text": "This move instruction makes the BP point to the same location that the SP is currently pointing to, which is the location that is immediately following the saved BP."}, {"start": "00:02:27", "is_lecture": false, "end": "00:02:40", "is_worked_example": true, "text": "Note, that once the BP register is set up, one can always find the first argument at location BP -- 12 (or in other words, 3 words before the current BP register)."}, {"start": "00:02:40", "is_lecture": false, "end": "00:02:47", "is_worked_example": true, "text": "If there was a second argument, it could be found in location BP -- 16, and so on."}, {"start": "00:02:47", "is_lecture": false, "end": "00:02:53", "is_worked_example": true, "text": "Next, we allocate space on the stack for any local variables."}, {"start": "00:02:53", "is_lecture": false, "end": "00:02:57", "is_worked_example": true, "text": "This procedure allocates space for one local variable."}, {"start": "00:02:57", "is_lecture": false, "end": "00:03:03", "is_worked_example": true, "text": "Finally, we push all registers that are going to be modified by our procedure onto the stack."}, {"start": "00:03:03", "is_lecture": false, "end": "00:03:10", "is_worked_example": true, "text": "Doing this makes it possible to recover the registers' original values once the procedure completes execution."}, {"start": "00:03:10", "is_lecture": false, "end": "00:03:15", "is_worked_example": true, "text": "In this example, register R1 is saved onto the stack."}, {"start": "00:03:15", "is_lecture": false, "end": "00:03:23", "is_worked_example": true, "text": "Once the entry sequence is complete, the BP register still points to the location immediately following the saved BP."}, {"start": "00:03:23", "is_lecture": false, "end": "00:03:30", "is_worked_example": true, "text": "The SP, however, now points to the location immediately following the saved R1 register."}, {"start": "00:03:30", "is_lecture": false, "end": "00:03:38", "is_worked_example": true, "text": "So for this procedure, after executing the entry sequence, the stack has been modified as shown here."}, {"start": "00:03:38", "is_lecture": false, "end": "00:03:44", "is_worked_example": true, "text": "The procedure return, or exit, sequence for all beta procedures follows the same structure."}, {"start": "00:03:44", "is_lecture": false, "end": "00:03:51", "is_worked_example": true, "text": "It is assumed that the return value for the procedure has already been placed into register R0."}, {"start": "00:03:51", "is_lecture": false, "end": "00:03:58", "is_worked_example": true, "text": "Next, all registers that were used in the procedure body, are restored to their original values."}, {"start": "00:03:58", "is_lecture": false, "end": "00:04:03", "is_worked_example": true, "text": "This is followed by deallocating all of the local variables from the stack."}, {"start": "00:04:03", "is_lecture": false, "end": "00:04:07", "is_worked_example": true, "text": "We then restore the BP, followed by the LP register."}, {"start": "00:04:07", "is_lecture": false, "end": "00:04:13", "is_worked_example": true, "text": "Finally, we jump to LP which contains the return address of our procedure."}, {"start": "00:04:13", "is_lecture": false, "end": "00:04:23", "is_worked_example": true, "text": "In this case, LP contains the address b which is the address of the next instruction that should be executed following the execution of the f procedure."}, {"start": "00:04:23", "is_lecture": false, "end": "00:04:35", "is_worked_example": true, "text": "Taking a closer look at the details for our example, we see that we begin our exit sequence with POP(R1) in order to restore the original value of register R1."}, {"start": "00:04:35", "is_lecture": false, "end": "00:04:40", "is_worked_example": true, "text": "Note that this also frees up the location on the stack that was used to store the value of R1."}, {"start": "00:04:40", "is_lecture": false, "end": "00:04:46", "is_worked_example": true, "text": "Next, we get rid of the local variables we stored on the stack."}, {"start": "00:04:46", "is_lecture": false, "end": "00:05:02", "is_worked_example": true, "text": "This is achieved using the MOVE(BP, SP) instruction which makes the SP point to the same location as the BP thus specifying that all the locations following the updated SP are now considered unused."}, {"start": "00:05:02", "is_lecture": false, "end": "00:05:05", "is_worked_example": true, "text": "Next, we restore the BP register."}, {"start": "00:05:05", "is_lecture": false, "end": "00:05:10", "is_worked_example": true, "text": "Restoring the BP register is particularly important for nested procedure calls."}, {"start": "00:05:10", "is_lecture": false, "end": "00:05:27", "is_worked_example": true, "text": "If we did not restore the BP register, then upon return to the calling procedure, the calling procedure would no longer have a correct BP, so it would not be able to rely on the fact that it's first argument is located at location BP-12, for example."}, {"start": "00:05:27", "is_lecture": false, "end": "00:05:34", "is_worked_example": true, "text": "Finally, we restore the LP register and JMP to the location of the restored LP register."}, {"start": "00:05:34", "is_lecture": false, "end": "00:05:44", "is_worked_example": true, "text": "This is the return address, so by jumping to LP, we return from our procedure call and are now ready to execute the next instruction at label b."}, {"start": "00:05:44", "is_lecture": false, "end": "00:05:49", "is_worked_example": true, "text": "Now let's get back to our original procedure and its translation to beta assembly."}, {"start": "00:05:49", "is_lecture": false, "end": "00:05:58", "is_worked_example": true, "text": "We will now try to understand what this mystery function is actually doing by examining the remaining sections of our assembly code highlighted here."}, {"start": "00:05:58", "is_lecture": false, "end": "00:06:01", "is_worked_example": true, "text": "Let's zoom into the highlighted code."}, {"start": "00:06:01", "is_lecture": false, "end": "00:06:07", "is_worked_example": true, "text": "The LD instruction loads the first argument into register R0."}, {"start": "00:06:07", "is_lecture": false, "end": "00:06:17", "is_worked_example": true, "text": "Recall that the first argument can always be found at location BP -- 12, or in other words, 3 words before the current BP register."}, {"start": "00:06:17", "is_lecture": false, "end": "00:06:21", "is_worked_example": true, "text": "This means that the value x is loaded into R0."}, {"start": "00:06:21", "is_lecture": false, "end": "00:06:32", "is_worked_example": true, "text": "Next we perform a binary AND operation between R0 and the constant 5, and store the result of that operation into register R1."}, {"start": "00:06:32", "is_lecture": false, "end": "00:06:40", "is_worked_example": true, "text": "Note that its okay to overwrite R1 because the entry sequence already saved a copy of the original R1 onto the stack."}, {"start": "00:06:40", "is_lecture": false, "end": "00:06:53", "is_worked_example": true, "text": "Also, note that overwriting R0 is considered fine because we ultimately expect the result to be returned in R0, so there is no expectation of maintaining the original value of R0."}, {"start": "00:06:53", "is_lecture": false, "end": "00:07:04", "is_worked_example": true, "text": "Looking back at the c code of our function, we see that the bitwise AND of x and 5 is stored into a local variable named a."}, {"start": "00:07:04", "is_lecture": false, "end": "00:07:10", "is_worked_example": true, "text": "In our entry sequence, we allocated 1 word on the stack for our local variables."}, {"start": "00:07:10", "is_lecture": false, "end": "00:07:14", "is_worked_example": true, "text": "That is where we want to store this intermediate result."}, {"start": "00:07:14", "is_lecture": false, "end": "00:07:19", "is_worked_example": true, "text": "The address of this location is equal to the contents of the BP register."}, {"start": "00:07:19", "is_lecture": false, "end": "00:07:34", "is_worked_example": true, "text": "Since the destination of a store operation is determined by adding the contents of the last register in the instruction to the constant, the destination of this store operation is the value of BP + 0."}, {"start": "00:07:34", "is_lecture": false, "end": "00:07:39", "is_worked_example": true, "text": "So as expected, variable a is stored at the location pointed to by the BP register."}, {"start": "00:07:39", "is_lecture": false, "end": "00:07:47", "is_worked_example": true, "text": "Now we check if x equals 0 and if so we want to return the value 0."}, {"start": "00:07:47", "is_lecture": false, "end": "00:07:57", "is_worked_example": true, "text": "This is achieved in beta assembly by checking if R0 is equal to 0 since R0 was loaded with the value of x by the LD operation."}, {"start": "00:07:57", "is_lecture": false, "end": "00:08:06", "is_worked_example": true, "text": "The BEQ operation checks whether or not this condition holds and if so, it branches to label bye which is our exit sequence."}, {"start": "00:08:06", "is_lecture": false, "end": "00:08:16", "is_worked_example": true, "text": "In that situation, we just saw that R0 = 0, so R0 already contains the correct return value and we are ready to execute our return sequence."}, {"start": "00:08:16", "is_lecture": false, "end": "00:08:24", "is_worked_example": true, "text": "If x is not equal to 0, then we perform the instructions after label xx."}, {"start": "00:08:24", "is_lecture": false, "end": "00:08:32", "is_worked_example": true, "text": "By figuring out what these instructions do, we can identify the value of our mystery function labeled ?????."}, {"start": "00:08:32", "is_lecture": false, "end": "00:08:36", "is_worked_example": true, "text": "We begin by decrementing R0 by 1."}, {"start": "00:08:36", "is_lecture": false, "end": "00:08:40", "is_worked_example": true, "text": "This means that R0 will be updated to hold x-1."}, {"start": "00:08:40", "is_lecture": false, "end": "00:08:46", "is_worked_example": true, "text": "We then push this value onto the stack and make a recursive call to procedure f."}, {"start": "00:08:46", "is_lecture": false, "end": "00:08:51", "is_worked_example": true, "text": "In other words, we call f again with a new argument which is equal to x-1."}, {"start": "00:08:51", "is_lecture": false, "end": "00:08:57", "is_worked_example": true, "text": "So far we know that our mystery function will contain the term f(x-1)."}, {"start": "00:08:57", "is_lecture": false, "end": "00:09:04", "is_worked_example": true, "text": "We also see that LP gets updated with the new return address which is yy + 4."}, {"start": "00:09:04", "is_lecture": false, "end": "00:09:12", "is_worked_example": true, "text": "So just before our recursive call to f with the new argument x-1, our stack looks like this."}, {"start": "00:09:12", "is_lecture": false, "end": "00:09:21", "is_worked_example": true, "text": "After the procedure entry sequence is executed in the first recursive call, our stack looks like this."}, {"start": "00:09:21", "is_lecture": false, "end": "00:09:30", "is_worked_example": true, "text": "Note that this time the saved LP is yy + 4 because that is our return address for the recursive procedure call."}, {"start": "00:09:30", "is_lecture": false, "end": "00:09:36", "is_worked_example": true, "text": "The previous BP points to where the BP was pointing to in the original call to f."}, {"start": "00:09:36", "is_lecture": false, "end": "00:09:40", "is_worked_example": true, "text": "Another term for this group of stack elements is the activation record."}, {"start": "00:09:40", "is_lecture": false, "end": "00:09:45", "is_worked_example": true, "text": "In this example, each activation record consists of 5 elements."}, {"start": "00:09:45", "is_lecture": false, "end": "00:09:54", "is_worked_example": true, "text": "These are the argument to f, the saved LP, the saved BP, the local variable, and the saved R1."}, {"start": "00:09:54", "is_lecture": false, "end": "00:10:00", "is_worked_example": true, "text": "Each time that f is called recursively another activation record will be added to the stack."}, {"start": "00:10:00", "is_lecture": false, "end": "00:10:13", "is_worked_example": true, "text": "When we finally return from all of these recursive calls, we are back to a stack that looks like this with a single activation record left on the stack plus the first argument with which the recursive call was made."}, {"start": "00:10:13", "is_lecture": false, "end": "00:10:18", "is_worked_example": true, "text": "The DEALLOCATE(1) instruction then removes this argument from the stack."}, {"start": "00:10:18", "is_lecture": false, "end": "00:10:27", "is_worked_example": true, "text": "So the SP is now pointing to the location where we previously pushed the argument x-1."}, {"start": "00:10:27", "is_lecture": false, "end": "00:10:35", "is_worked_example": true, "text": "R0 holds the return value from the recursive call to f which is the value of f(x-1)."}, {"start": "00:10:35", "is_lecture": false, "end": "00:10:43", "is_worked_example": true, "text": "Now, we execute a LD into register R1 of the address that is the contents of register BP + 0."}, {"start": "00:10:43", "is_lecture": false, "end": "00:10:45", "is_worked_example": true, "text": "This value is a."}, {"start": "00:10:45", "is_lecture": false, "end": "00:10:50", "is_worked_example": true, "text": "We then ADD R1 to R0 to produce our final result in R0."}, {"start": "00:10:50", "is_lecture": false, "end": "00:11:00", "is_worked_example": true, "text": "R0 is now equal to a + f(x-1), so we have discovered that our mystery function is a + f(x-1)."}, {"start": "00:11:00", "is_lecture": false, "end": "00:11:08", "is_worked_example": true, "text": "Before we continue with analyzing a stack trace from this problem, let's answer a few simpler questions."}, {"start": "00:11:08", "is_lecture": false, "end": "00:11:19", "is_worked_example": true, "text": "The first question is whether or not variable a, from the statement a = x & 5, is stored on the stack and if so where is it stored relative to the BP register."}, {"start": "00:11:19", "is_lecture": false, "end": "00:11:25", "is_worked_example": true, "text": "Earlier we saw that our assembly program allocates space for one local variable on the stack."}, {"start": "00:11:25", "is_lecture": false, "end": "00:11:39", "is_worked_example": true, "text": "It then stores R1, which holds the result of performing a binary ANDC between x and the constant 5, into the location pointed to by the BP register, as shown here."}, {"start": "00:11:39", "is_lecture": false, "end": "00:11:45", "is_worked_example": true, "text": "Next, we want to translate the instruction at label yy into its binary representation."}, {"start": "00:11:45", "is_lecture": false, "end": "00:11:52", "is_worked_example": true, "text": "The instruction at label yy is BR(f, LP)."}, {"start": "00:11:52", "is_lecture": false, "end": "00:12:00", "is_worked_example": true, "text": "This instruction is actually a macro that translates to a BEQ(R31, f,  LP)."}, {"start": "00:12:00", "is_lecture": false, "end": "00:12:07", "is_worked_example": true, "text": "Note that because R31 always equals 0, this branch is always taken."}, {"start": "00:12:07", "is_lecture": false, "end": "00:12:23", "is_worked_example": true, "text": "The format of the binary representation for this instruction is a 6-bit opcode, followed by a 5 bit Rc identifier, followed by another 5 bits which specify Ra, and then followed by a 16 bit literal."}, {"start": "00:12:23", "is_lecture": false, "end": "00:12:29", "is_worked_example": true, "text": "The opcode for BEQ is 011100."}, {"start": "00:12:29", "is_lecture": false, "end": "00:12:33", "is_worked_example": true, "text": "Rc = LP which is register R28."}, {"start": "00:12:33", "is_lecture": false, "end": "00:12:38", "is_worked_example": true, "text": "The 5-bit encoding of 28 is 11100."}, {"start": "00:12:38", "is_lecture": false, "end": "00:12:44", "is_worked_example": true, "text": "Ra is R31 whose encoding is 11111."}, {"start": "00:12:44", "is_lecture": false, "end": "00:12:49", "is_worked_example": true, "text": "Now, we need to determine the value of the literal in this instruction."}, {"start": "00:12:49", "is_lecture": false, "end": "00:12:58", "is_worked_example": true, "text": "The literal in a branch instruction stores the offset measured in words from the instruction immediately following the branch, to the destination address."}, {"start": "00:12:58", "is_lecture": false, "end": "00:13:09", "is_worked_example": true, "text": "Looking at our assembly code for this function, we see that we want to count the number of words from the DEALLOCATE(1) instruction back to label f."}, {"start": "00:13:09", "is_lecture": false, "end": "00:13:18", "is_worked_example": true, "text": "Recall that the PUSH and POP macros are actually each made of up two instructions so each of those counts as 2 words."}, {"start": "00:13:18", "is_lecture": false, "end": "00:13:32", "is_worked_example": true, "text": "Counting back, and accounting for the two instructions per push and pop, we see that we have to go back 16 instructions, so our literal is -16 expressed as a 16 bit binary number."}, {"start": "00:13:32", "is_lecture": false, "end": "00:13:49", "is_worked_example": true, "text": "Positive 16 is 0000 0000 0001 0000, so -16 is 1111 1111 1111 0000."}, {"start": "00:13:49", "is_lecture": false, "end": "00:14:02", "is_worked_example": true, "text": "Now, suppose that the function f is called from an external main program, and the machine is halted when a recursive call to f is about to execute the BEQ instruction tagged xx."}, {"start": "00:14:02", "is_lecture": false, "end": "00:14:13", "is_worked_example": true, "text": "The BP register of the halted machine contains 0x174, and the hex contents of a region of memory are shown here."}, {"start": "00:14:13", "is_lecture": false, "end": "00:14:19", "is_worked_example": true, "text": "The values on the left of the stack are the addresses of each location on the stack."}, {"start": "00:14:19", "is_lecture": false, "end": "00:14:26", "is_worked_example": true, "text": "We first want to determine the current value of the SP, or stack pointer, register."}, {"start": "00:14:26", "is_lecture": false, "end": "00:14:35", "is_worked_example": true, "text": "We were told that the machine is halted when a recursive call to f is about to execute the BEQ instruction tagged xx."}, {"start": "00:14:35", "is_lecture": false, "end": "00:14:42", "is_worked_example": true, "text": "And that the BP register was 0x174 at that point."}, {"start": "00:14:42", "is_lecture": false, "end": "00:14:51", "is_worked_example": true, "text": "We see that after the BP was updated to be equal to the SP in the MOVE operation, two additional entries were made on the stack."}, {"start": "00:14:51", "is_lecture": false, "end": "00:15:14", "is_worked_example": true, "text": "The first was an ALLOCATE instruction which allocated space for one local variable, thus making the SP point to location 0x178, and then PUSH(R1), which saves a copy of R1 on the stack, thus moving the SP register one further location down to 0x17C."}, {"start": "00:15:14", "is_lecture": false, "end": "00:15:23", "is_worked_example": true, "text": "We now want to answer some questions about the stack trace itself to help us better understand its structure."}, {"start": "00:15:23", "is_lecture": false, "end": "00:15:28", "is_worked_example": true, "text": "We first want to determine the value of local variable a in the current stack frame."}, {"start": "00:15:28", "is_lecture": false, "end": "00:15:34", "is_worked_example": true, "text": "We know that a is stored at location BP + 0."}, {"start": "00:15:34", "is_lecture": false, "end": "00:15:42", "is_worked_example": true, "text": "So a is the variable stored at address 0x174, and that value is 5."}, {"start": "00:15:42", "is_lecture": false, "end": "00:15:46", "is_worked_example": true, "text": "From here, we can label all the entries in the stack trace as follows."}, {"start": "00:15:46", "is_lecture": false, "end": "00:15:59", "is_worked_example": true, "text": "We saw earlier, that each activation record consists of 5 words, the argument x followed by the saved LP, the saved BP, the local variable, and the saved register R1."}, {"start": "00:15:59", "is_lecture": false, "end": "00:16:04", "is_worked_example": true, "text": "We can apply this structure to label our stack trace."}, {"start": "00:16:04", "is_lecture": false, "end": "00:16:11", "is_worked_example": true, "text": "Now that our stack trace is fully labeled we can take a closer look at the details of implementing procedures on the beta."}, {"start": "00:16:11", "is_lecture": false, "end": "00:16:16", "is_worked_example": true, "text": "We begin by looking at the multiple LP values that were stored on the stack."}, {"start": "00:16:16", "is_lecture": false, "end": "00:16:28", "is_worked_example": true, "text": "Note that the first one at address 0x144 has a value of 0x5C whereas the following two have a value of 0xA4."}, {"start": "00:16:28", "is_lecture": false, "end": "00:16:47", "is_worked_example": true, "text": "This occurs because the LP value stored at address 0x144 is the return address from the main procedure that originally called procedure f, whereas the following two LP values are the return addresses from recursive calls to f made from within the f function itself."}, {"start": "00:16:47", "is_lecture": false, "end": "00:16:58", "is_worked_example": true, "text": "Using this information you can now answer the question: What is the address of the BR instruction that made the original call to f from the external main program?"}, {"start": "00:16:58", "is_lecture": false, "end": "00:17:07", "is_worked_example": true, "text": "Recall that the value stored in the LP register is actually the return address which is the address of the instruction immediately following the branch instruction."}, {"start": "00:17:07", "is_lecture": false, "end": "00:17:17", "is_worked_example": true, "text": "So if the original LP value was 0x5C, that means that the address of the branch instruction was 0x58."}, {"start": "00:17:17", "is_lecture": false, "end": "00:17:25", "is_worked_example": true, "text": "We can also answer the question, what is the value of the PC when the program is halted."}, {"start": "00:17:25", "is_lecture": false, "end": "00:17:30", "is_worked_example": true, "text": "We know that the program was halted just before executing the instruction at label xx."}, {"start": "00:17:30", "is_lecture": false, "end": "00:17:36", "is_worked_example": true, "text": "We also know, that the instruction at label yy makes a recursive call to f."}, {"start": "00:17:36", "is_lecture": false, "end": "00:17:42", "is_worked_example": true, "text": "We know that the LP value from the recursive calls is 0xA4."}, {"start": "00:17:42", "is_lecture": false, "end": "00:17:48", "is_worked_example": true, "text": "This means that the address of the DEALLOCATE(1) instruction is 0xA4."}, {"start": "00:17:48", "is_lecture": false, "end": "00:18:05", "is_worked_example": true, "text": "Counting backwards by 4 bytes, and accounting for the fact that a PUSH operation consists of two instructions, we see that label xx = 0x90 and that is the value of the PC when the program is halted."}, {"start": "00:18:05", "is_lecture": false, "end": "00:18:18", "is_worked_example": true, "text": "As our last question, we want to consider the following: Suppose that you are told that you could delete 4 instructions from your program without affecting the behavior of the program."}, {"start": "00:18:18", "is_lecture": false, "end": "00:18:24", "is_worked_example": true, "text": "The 4 instructions to be removed are a LD, a ST, an ALLOCATE, and a MOVE instruction."}, {"start": "00:18:24", "is_lecture": false, "end": "00:18:29", "is_worked_example": true, "text": "Removing these instructions would make our program shorter and faster."}, {"start": "00:18:29", "is_lecture": false, "end": "00:18:35", "is_worked_example": true, "text": "So, our goal is to determine whether or not this is possible without affecting the behavior of the program."}, {"start": "00:18:35", "is_lecture": false, "end": "00:18:39", "is_worked_example": true, "text": "Let's first consider removing the ALLOCATE instruction."}, {"start": "00:18:39", "is_lecture": false, "end": "00:18:46", "is_worked_example": true, "text": "If this instruction is removed, that means that we will not be saving space on the stack for local variable a."}, {"start": "00:18:46", "is_lecture": false, "end": "00:18:58", "is_worked_example": true, "text": "However, if we take a closer look at the 3 lines of code highlighted in yellow, we see that the actual value of a is first computed in R1 before storing it in local variable a."}, {"start": "00:18:58", "is_lecture": false, "end": "00:19:15", "is_worked_example": true, "text": "Since R1 is going to be saved on the stack during each recursive call, we could get away without saving a on the stack because we can find its value in the stored R1 of the next activation record as shown in the highlighted pairs of a and R1 on the stack."}, {"start": "00:19:15", "is_lecture": false, "end": "00:19:20", "is_worked_example": true, "text": "This means that we could safely remove the ALLOCATE instruction."}, {"start": "00:19:20", "is_lecture": false, "end": "00:19:31", "is_worked_example": true, "text": "As a result, this also means that we don't need the ST operation that stores a on the stack or the LD operation that reloads a into register R1."}, {"start": "00:19:31", "is_lecture": false, "end": "00:19:51", "is_worked_example": true, "text": "Finally, because there are no longer any local variables stored on the stack, then the instruction MOVE(BP,SP) which is normally used to deallocate all local variables, can be skipped because after popping R1, the BP and SP registers will already point to the same location."}, {"start": "00:19:51", "is_lecture": false, "end": "00:19:59", "is_worked_example": true, "text": "So, in conclusion the 4 operations can be removed from the program without changing the behavior of the code."}]}, "C07S01B04-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c7/c7s1/4?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c7s1v4", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "We'll use the stack to hold a procedure's activation record."}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:07", "is_worked_example": false, "text": "That includes the values of the arguments to the procedure call."}, {"start": "00:00:07", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "We'll allocate words on the stack to hold the values of the procedure's local variables, assuming we don't keep them in registers."}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "And we'll use the stack to save the return address (passed in LP) so the procedure can make nested procedure calls without overwriting its return address."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "The responsibility for allocating and deallocating the activation record will be shared between the calling procedure (the \"caller\") and the called procedure (the \"callee\")."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "The caller is responsible for evaluating the argument expressions and saving their values in the activation record being built on the stack."}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:51", "is_worked_example": false, "text": "We'll adopt the convention that the arguments are pushed in reverse order, i.e., the first argument will be the last to be pushed on the stack."}, {"start": "00:00:51", "is_lecture": true, "end": "00:00:55", "is_worked_example": false, "text": "We'll explain why we made this choice in a couple of slides..."}, {"start": "00:00:55", "is_lecture": true, "end": "00:01:06", "is_worked_example": false, "text": "The code compiled for a procedure involves a sequence of expression evaluations, each followed by a PUSH to save the calculated value on the stack."}, {"start": "00:01:06", "is_lecture": true, "end": "00:01:17", "is_worked_example": false, "text": "So when the callee starts execution, the top of the stack contains the value of the first argument, the next word down the value of the second argument, and so on."}, {"start": "00:01:17", "is_lecture": true, "end": "00:01:27", "is_worked_example": false, "text": "After the argument values, if any, have been pushed on the stack, there's a BR to transfer control to the procedure's entry point,"}, {"start": "00:01:27", "is_lecture": true, "end": "00:01:35", "is_worked_example": false, "text": "saving the address of the instruction following the BR in the linkage pointer, R28, a register that we'll dedicate to that purpose."}, {"start": "00:01:35", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "When the callee returns and execution resumes in the caller, a DEALLOCATE is used to remove all the argument values from the stack, preserving stack discipline."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "So that's the code the compiler generates for the procedure."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "The rest of the work happens in the called procedure."}, {"start": "00:01:53", "is_lecture": true, "end": "00:01:59", "is_worked_example": false, "text": "The code at the start of the called procedure completes the allocation of the activation record."}, {"start": "00:01:59", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "Since when we're done the activation record will occupy a bunch of consecutive words on the stack, we'll sometimes refer to the activation record as a \"stack frame\" to remind us of where it lives."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "The first action is to save the return address found in the LP register."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "This frees up LP to be used by any nested procedure calls in the body of the callee."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:34", "is_worked_example": false, "text": "In order to make it easy to access values stored in the activation record, we'll dedicate another register called the \"base pointer\" (BP = R27) which will point to the stack frame we're building."}, {"start": "00:02:34", "is_lecture": true, "end": "00:02:47", "is_worked_example": false, "text": "So as we enter the procedure, the code saves the pointer to the caller's stack frame, and then uses the current value of the stack pointer to make BP point to the current stack frame."}, {"start": "00:02:47", "is_lecture": true, "end": "00:02:49", "is_worked_example": false, "text": "We'll see how we use BP in just a moment."}, {"start": "00:02:49", "is_lecture": true, "end": "00:02:57", "is_worked_example": false, "text": "Now the code will allocate words in the stack frame to hold the values for the callee's local variables, if any."}, {"start": "00:02:57", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "Finally, the callee needs to save the values of any registers it will use when executing the rest of its code."}, {"start": "00:03:04", "is_lecture": true, "end": "00:03:11", "is_worked_example": false, "text": "These saved values can be used to restore the register values just before returning to the callee."}, {"start": "00:03:11", "is_lecture": true, "end": "00:03:20", "is_worked_example": false, "text": "This is called the \"callee saves\" convention where the callee guarantees that all register values will be preserved across the procedure call."}, {"start": "00:03:20", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "With this convention, the code in the caller can assume any values it placed in registers before a nested procedure call will still be there when the nested call returns."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:35", "is_worked_example": false, "text": "Note that dedicating a register as the base pointer isn't strictly necessary."}, {"start": "00:03:35", "is_lecture": true, "end": "00:03:48", "is_worked_example": false, "text": "All accesses to the values on the stack can be made relative to the stack pointer, but the offsets from SP will change as values are PUSHed and POPed from the stack, e.g., during procedure calls."}, {"start": "00:03:48", "is_lecture": true, "end": "00:03:54", "is_worked_example": false, "text": "It will be easier to understand the generated code if we use BP for all stack frame references."}, {"start": "00:03:54", "is_lecture": true, "end": "00:04:01", "is_worked_example": false, "text": "Let's return to the question about the order of argument values in the stack frame."}, {"start": "00:04:01", "is_lecture": true, "end": "00:04:08", "is_worked_example": false, "text": "We adopted the convention of PUSHing the values in reverse order, i.e., where the value of the first argument is the last one to be PUSHED."}, {"start": "00:04:08", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "So, why PUSH argument values in reverse order?"}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:24", "is_worked_example": false, "text": "With the arguments PUSHed in reverse order, the first argument (labeled \"arg 0\") will be at a fixed offset from the base pointer regardless of the number of argument values pushed on the stack."}, {"start": "00:04:24", "is_lecture": true, "end": "00:04:31", "is_worked_example": false, "text": "The compiler can use a simple formula to the determine the correct BP offset value for any particular argument."}, {"start": "00:04:31", "is_lecture": true, "end": "00:04:36", "is_worked_example": false, "text": "So the first argument is at offset -12, the second at -16, and so on."}, {"start": "00:04:36", "is_lecture": true, "end": "00:04:39", "is_worked_example": false, "text": "Why is this important?"}, {"start": "00:04:39", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "Some languages, such as C, support procedure calls with a variable number of arguments."}, {"start": "00:04:44", "is_lecture": true, "end": "00:04:50", "is_worked_example": false, "text": "Usually the procedure can determine from, say, the first argument, how many additional arguments to expect."}, {"start": "00:04:50", "is_lecture": true, "end": "00:04:59", "is_worked_example": false, "text": "The canonical example is the C printf function where the first argument is a format string that specifies how a sequence of values should be printed."}, {"start": "00:04:59", "is_lecture": true, "end": "00:05:06", "is_worked_example": false, "text": "So a call to printf includes the format string argument plus a varying number of additional arguments."}, {"start": "00:05:06", "is_lecture": true, "end": "00:05:18", "is_worked_example": false, "text": "With our calling convention the format string will always be in the same location relative to BP, so the printf code can find it without knowing the number of additional arguments in the current call."}, {"start": "00:05:18", "is_lecture": true, "end": "00:05:24", "is_worked_example": false, "text": "The local variables are also at fixed offsets from BP."}, {"start": "00:05:24", "is_lecture": true, "end": "00:05:29", "is_worked_example": false, "text": "The first local variable is at offset 0, the second at offset 4, and so on."}, {"start": "00:05:29", "is_lecture": true, "end": "00:05:39", "is_worked_example": false, "text": "So, we see that having a base pointer makes it easy to access the values of the arguments and local variables using fixed offsets that can be determined at compile time."}, {"start": "00:05:39", "is_lecture": true, "end": "00:05:48", "is_worked_example": false, "text": "The stack above the local variables is available for other uses, e.g., building the activation record for a nested procedure call!"}]}, "C11S02B01-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s2/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s2v1", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:12", "is_worked_example": true, "text": "We are going to compare the behavior of 3 different cache configurations on a benchmark program to better understand the impact of the cache configuration on the performance of the benchmark."}, {"start": "00:00:12", "is_lecture": false, "end": "00:00:18", "is_worked_example": true, "text": "The first cache we will consider is a 64-line direct mapped cache."}, {"start": "00:00:18", "is_lecture": false, "end": "00:00:29", "is_worked_example": true, "text": "The second is a 2-way set associative cache that uses the LRU, or least recently used, replacement strategy, and has a total of 64 lines."}, {"start": "00:00:29", "is_lecture": false, "end": "00:00:38", "is_worked_example": true, "text": "The third is a 4-way set associative cache that uses the LRU replacement strategy, and also has a total of 64 lines."}, {"start": "00:00:38", "is_lecture": false, "end": "00:00:47", "is_worked_example": true, "text": "Note that all three caches have the same capacity in that they can store a total of 64 words of data."}, {"start": "00:00:47", "is_lecture": false, "end": "00:00:53", "is_worked_example": true, "text": "In a direct mapped cache any particular memory address maps to exactly one line in the cache."}, {"start": "00:00:53", "is_lecture": false, "end": "00:00:58", "is_worked_example": true, "text": "Let's assume that our data is 32 bits, or 4 bytes wide."}, {"start": "00:00:58", "is_lecture": false, "end": "00:01:11", "is_worked_example": true, "text": "This means that consecutive addresses are 4 bytes apart, so we treat the bottom two address bits as always being 00 so that our address is on a data word boundary."}, {"start": "00:01:11", "is_lecture": false, "end": "00:01:16", "is_worked_example": true, "text": "Next, we want to determine which cache line this particular address maps to."}, {"start": "00:01:16", "is_lecture": false, "end": "00:01:23", "is_worked_example": true, "text": "Since there are 64 lines in this cache, we need 6 bits to select one of the 64 lines."}, {"start": "00:01:23", "is_lecture": false, "end": "00:01:26", "is_worked_example": true, "text": "These 6 bits are called the index."}, {"start": "00:01:26", "is_lecture": false, "end": "00:01:36", "is_worked_example": true, "text": "In this example, the index is 000011, so this particular address maps to line 3 of the cache."}, {"start": "00:01:36", "is_lecture": false, "end": "00:01:44", "is_worked_example": true, "text": "The data that gets stored in the cache is the tag portion of the address of the line plus the 32 bits of data."}, {"start": "00:01:44", "is_lecture": false, "end": "00:01:51", "is_worked_example": true, "text": "The tag is used for comparison when checking if a particular address is in the cache or not."}, {"start": "00:01:51", "is_lecture": false, "end": "00:01:55", "is_worked_example": true, "text": "It uniquely identifies the particular memory address."}, {"start": "00:01:55", "is_lecture": false, "end": "00:02:02", "is_worked_example": true, "text": "In addition, each cache line has a valid bit that lets you know whether the data in the cache is currently valid or not."}, {"start": "00:02:02", "is_lecture": false, "end": "00:02:11", "is_worked_example": true, "text": "This is important upon startup because without this bit there is no way to know whether the data in the cache is garbage or real data."}, {"start": "00:02:11", "is_lecture": false, "end": "00:02:20", "is_worked_example": true, "text": "In a 2-way set associative cache, the cache is divided into 2 sets each with half the number of lines."}, {"start": "00:02:20", "is_lecture": false, "end": "00:02:23", "is_worked_example": true, "text": "So we have two sets with 32 lines each."}, {"start": "00:02:23", "is_lecture": false, "end": "00:02:30", "is_worked_example": true, "text": "Since there are only 32 lines, we now only need a 5 bit index to select the line."}, {"start": "00:02:30", "is_lecture": false, "end": "00:02:36", "is_worked_example": true, "text": "However, any given index can map to two distinct locations, one in each set."}, {"start": "00:02:36", "is_lecture": false, "end": "00:02:43", "is_worked_example": true, "text": "This also means that when the tag comparisons are done, two comparisons are required, one per set."}, {"start": "00:02:43", "is_lecture": false, "end": "00:02:49", "is_worked_example": true, "text": "In a 4-way set associative cache, the cache is divided into 4 sets each with 16 lines."}, {"start": "00:02:49", "is_lecture": false, "end": "00:02:54", "is_worked_example": true, "text": "The width of the index is now 4 bits to select the cache line."}, {"start": "00:02:54", "is_lecture": false, "end": "00:03:03", "is_worked_example": true, "text": "Here, selecting a line identifies one of 4 words as possible locations for reading or writing the associated data."}, {"start": "00:03:03", "is_lecture": false, "end": "00:03:13", "is_worked_example": true, "text": "This also implies that 4 tags need to be compared when trying to read from the cache to determine if the desired address is stored in the cache or not."}, {"start": "00:03:13", "is_lecture": false, "end": "00:03:22", "is_worked_example": true, "text": "The test program begins by defining a few constants, J, A, B, and N."}, {"start": "00:03:22", "is_lecture": false, "end": "00:03:27", "is_worked_example": true, "text": "J specifies the address where the program lives."}, {"start": "00:03:27", "is_lecture": false, "end": "00:03:34", "is_worked_example": true, "text": "A is the starting address of data region 1, and B is the starting address of data region 2."}, {"start": "00:03:34", "is_lecture": false, "end": "00:03:38", "is_worked_example": true, "text": "Finally, N specifies the size of the data regions."}, {"start": "00:03:38", "is_lecture": false, "end": "00:03:46", "is_worked_example": true, "text": "Since one word consists of 4 bytes, 16 bytes of data mean that there are 4 data elements per region."}, {"start": "00:03:46", "is_lecture": false, "end": "00:03:53", "is_worked_example": true, "text": "Next the assembler is told that the beginning of the program is at address 0x1000."}, {"start": "00:03:53", "is_lecture": false, "end": "00:04:02", "is_worked_example": true, "text": "The green rectangle identifies the outer loop, and the yellow rectangle identifies the inner loop of the code."}, {"start": "00:04:02", "is_lecture": false, "end": "00:04:09", "is_worked_example": true, "text": "Before entering the outer loop, a loop counter, which is stored in register R6 is initialized to 1,000."}, {"start": "00:04:09", "is_lecture": false, "end": "00:04:19", "is_worked_example": true, "text": "Then each time through the outer loop, R6 is decremented by 1 and the loop is repeated as long as R6 is not equal to 0."}, {"start": "00:04:19", "is_lecture": false, "end": "00:04:25", "is_worked_example": true, "text": "The outer loop also resets R0 to N each time through the loop."}, {"start": "00:04:25", "is_lecture": false, "end": "00:04:29", "is_worked_example": true, "text": "R0 is used to hold the desired array offset."}, {"start": "00:04:29", "is_lecture": false, "end": "00:04:38", "is_worked_example": true, "text": "Since the last element of the array is stored at location N -- 4, the first step of the inner loop, is to decrement R0 by 4."}, {"start": "00:04:38", "is_lecture": false, "end": "00:04:50", "is_worked_example": true, "text": "R1 is then loaded with the value at address A + N -- 4 which is the address of A[3] because array indeces begin at 0."}, {"start": "00:04:50", "is_lecture": false, "end": "00:04:54", "is_worked_example": true, "text": "R2 is loaded with B[3]."}, {"start": "00:04:54", "is_lecture": false, "end": "00:05:06", "is_worked_example": true, "text": "As long as R0 is not equal to 0, the loop repeats itself, each time accessing the previous element of each array until the first element (index 0) is loaded."}, {"start": "00:05:06", "is_lecture": false, "end": "00:05:13", "is_worked_example": true, "text": "Then the outer loop decrements R6 and repeats the entire thing 1000 times."}, {"start": "00:05:13", "is_lecture": false, "end": "00:05:25", "is_worked_example": true, "text": "Now that we understand the configuration of our three caches and the behavior of our test benchmark, we can begin comparing the behavior of this benchmark on the three caches."}, {"start": "00:05:25", "is_lecture": false, "end": "00:05:33", "is_worked_example": true, "text": "The first thing we want to ask ourselves is which of the three cache configurations gets the highest hit ratio."}, {"start": "00:05:33", "is_lecture": false, "end": "00:05:43", "is_worked_example": true, "text": "Here we are not asked to calculate an actual hit ratio, instead we just need to realize that there are 3 distinct regions of data in this benchmark."}, {"start": "00:05:43", "is_lecture": false, "end": "00:05:51", "is_worked_example": true, "text": "The first holds the instructions, the second holds array A, and the third holds array B."}, {"start": "00:05:51", "is_lecture": false, "end": "00:06:00", "is_worked_example": true, "text": "If we think about the addresses of each of these regions in memory, we see that the first instruction is at address 0x1000."}, {"start": "00:06:00", "is_lecture": false, "end": "00:06:11", "is_worked_example": true, "text": "This will result in an index of 0 regardless of which cache you consider, so for all three caches the first instruction would map to the first line of the cache."}, {"start": "00:06:11", "is_lecture": false, "end": "00:06:21", "is_worked_example": true, "text": "Similarly the first element of arrays A and B are at address 0x2000 and 0x3000."}, {"start": "00:06:21", "is_lecture": false, "end": "00:06:28", "is_worked_example": true, "text": "These addresses will also result in an index of 0 regardless of which of the three caches you consider."}, {"start": "00:06:28", "is_lecture": false, "end": "00:06:36", "is_worked_example": true, "text": "So we see that the 1st CMOVE, A[0], and B[0] would all map to line 0 of the cache."}, {"start": "00:06:36", "is_lecture": false, "end": "00:06:50", "is_worked_example": true, "text": "Similarly, the 2nd CMOVE whose address is 0x1004 would map to line 1 of the cache as would array elements A[1] and B[1]."}, {"start": "00:06:50", "is_lecture": false, "end": "00:07:02", "is_worked_example": true, "text": "This tells us that if we use the direct mapped cache, or a 2-way set associative cache, then we will have cache collisions between the instructions, and the array elements."}, {"start": "00:07:02", "is_lecture": false, "end": "00:07:09", "is_worked_example": true, "text": "Collisions in the cache imply cache misses as we replace one piece of data with another in the cache."}, {"start": "00:07:09", "is_lecture": false, "end": "00:07:23", "is_worked_example": true, "text": "However, if we use a 4-way set associative cache then each region of memory can go in a distinct set in the cache thus avoiding collisions and resulting in 100% hit rate after the first time through the loop."}, {"start": "00:07:23", "is_lecture": false, "end": "00:07:34", "is_worked_example": true, "text": "Note that the first time through the loop each instruction and data access will result in a cache miss because the data needs to initially be brought into the cache."}, {"start": "00:07:34", "is_lecture": false, "end": "00:07:40", "is_worked_example": true, "text": "But when the loop is repeated, the data is already there and results in cache hits."}, {"start": "00:07:40", "is_lecture": false, "end": "00:07:51", "is_worked_example": true, "text": "Now suppose that we make a minor modification to our test program by changing B from 0x3000 to 0x2000."}, {"start": "00:07:51", "is_lecture": false, "end": "00:07:58", "is_worked_example": true, "text": "This means that array A and array B now refer to same locations in memory."}, {"start": "00:07:58", "is_lecture": false, "end": "00:08:06", "is_worked_example": true, "text": "We want to determine, which of the cache's hit rate will show a noticeable improvement as a result of this change."}, {"start": "00:08:06", "is_lecture": false, "end": "00:08:18", "is_worked_example": true, "text": "The difference between our original benchmark and this modified one is that we now have two distinct regions of memory to access, one for the instructions, and one for the data."}, {"start": "00:08:18", "is_lecture": false, "end": "00:08:30", "is_worked_example": true, "text": "This means that the 2-way set associative cache will no longer experience collisions in its cache, so its hit rate will be significantly better than with the original benchmark."}, {"start": "00:08:30", "is_lecture": false, "end": "00:08:41", "is_worked_example": true, "text": "Now suppose that we change our benchmark once again, this time making J, A and B all equal to 0, and changing N to be 64."}, {"start": "00:08:41", "is_lecture": false, "end": "00:08:47", "is_worked_example": true, "text": "This means that we now have 16 elements in our arrays instead of 4."}, {"start": "00:08:47", "is_lecture": false, "end": "00:08:56", "is_worked_example": true, "text": "It also means that the array values that we are loading for arrays A and B are actually the same as the instructions of the program."}, {"start": "00:08:56", "is_lecture": false, "end": "00:09:03", "is_worked_example": true, "text": "Another way of thinking about this is that we now only have one distinct region of memory being accessed."}, {"start": "00:09:03", "is_lecture": false, "end": "00:09:10", "is_worked_example": true, "text": "What we want to determine now, is the total number of cache misses that will occur for each of the cache configurations."}, {"start": "00:09:10", "is_lecture": false, "end": "00:09:15", "is_worked_example": true, "text": "Let's begin by considering the direct mapped cache."}, {"start": "00:09:15", "is_lecture": false, "end": "00:09:21", "is_worked_example": true, "text": "In the direct mapped cache, we would want to first access the first CMOVE instruction."}, {"start": "00:09:21", "is_lecture": false, "end": "00:09:27", "is_worked_example": true, "text": "Since this instruction is not yet in the cache, our first access is a cache miss."}, {"start": "00:09:27", "is_lecture": false, "end": "00:09:33", "is_worked_example": true, "text": "We now bring the binary equivalent of this instruction into line 0 of our cache."}, {"start": "00:09:33", "is_lecture": false, "end": "00:09:37", "is_worked_example": true, "text": "Next, we want to access the second CMOVE instruction."}, {"start": "00:09:37", "is_lecture": false, "end": "00:09:44", "is_worked_example": true, "text": "Once again the instruction is not in our cache so we get another cache miss."}, {"start": "00:09:44", "is_lecture": false, "end": "00:09:50", "is_worked_example": true, "text": "This results in our loading the 2nd CMOVE instruction to line 1 of our  cache."}, {"start": "00:09:50", "is_lecture": false, "end": "00:09:57", "is_worked_example": true, "text": "We continue in the same manner with the SUBC instruction and the first LD instruction."}, {"start": "00:09:57", "is_lecture": false, "end": "00:10:06", "is_worked_example": true, "text": "Again we get cache misses for each of those instructions and that in turn causes us to load those instructions into our cache."}, {"start": "00:10:06", "is_lecture": false, "end": "00:10:10", "is_worked_example": true, "text": "Now, we are ready to execute our first load operation."}, {"start": "00:10:10", "is_lecture": false, "end": "00:10:15", "is_worked_example": true, "text": "This operation wants to load A[15] into R1."}, {"start": "00:10:15", "is_lecture": false, "end": "00:10:23", "is_worked_example": true, "text": "Because the beginning of array A is at address 0, then A[15] maps to line 15 of our cache."}, {"start": "00:10:23", "is_lecture": false, "end": "00:10:32", "is_worked_example": true, "text": "Since we have not yet loaded anything into line 15 of our cache, this means that our first data access is a miss."}, {"start": "00:10:32", "is_lecture": false, "end": "00:10:34", "is_worked_example": true, "text": "We continue with the second load instruction."}, {"start": "00:10:34", "is_lecture": false, "end": "00:10:42", "is_worked_example": true, "text": "This instruction is not yet in the cache, so we get a cache miss and then load it into line 4 of our cache."}, {"start": "00:10:42", "is_lecture": false, "end": "00:10:45", "is_worked_example": true, "text": "We then try to access B[15]."}, {"start": "00:10:45", "is_lecture": false, "end": "00:10:57", "is_worked_example": true, "text": "B[15] corresponds to the same piece of data as A[15], so this data access is already in the cache thus resulting in a data hit for B[15]."}, {"start": "00:10:57", "is_lecture": false, "end": "00:11:04", "is_worked_example": true, "text": "So far we have gotten 5 instruction misses, 1 data miss and 1 data hit."}, {"start": "00:11:04", "is_lecture": false, "end": "00:11:08", "is_worked_example": true, "text": "Next we need to access the BNE instruction."}, {"start": "00:11:08", "is_lecture": false, "end": "00:11:16", "is_worked_example": true, "text": "Once again we get a cache miss which results in loading the BNE instruction into line 5 of our cache."}, {"start": "00:11:16", "is_lecture": false, "end": "00:11:25", "is_worked_example": true, "text": "The inner loop is now repeated with R0 = 60 which corresponds to element 14 of the arrays."}, {"start": "00:11:25", "is_lecture": false, "end": "00:11:33", "is_worked_example": true, "text": "This time through the loop, all the instructions are already in the cache and result in instruction hits."}, {"start": "00:11:33", "is_lecture": false, "end": "00:11:42", "is_worked_example": true, "text": "A[14] which maps to line 14 of our cache results in a data miss because it is not yet present in our cache."}, {"start": "00:11:42", "is_lecture": false, "end": "00:11:45", "is_worked_example": true, "text": "So we bring A[14] into the cache."}, {"start": "00:11:45", "is_lecture": false, "end": "00:11:57", "is_worked_example": true, "text": "Then as before, when we try to access B[14], we get a data hit because it corresponds to the same piece of data as A[14]."}, {"start": "00:11:57", "is_lecture": false, "end": "00:12:03", "is_worked_example": true, "text": "So in total, we have now seen 6 instruction misses and 2 data misses."}, {"start": "00:12:03", "is_lecture": false, "end": "00:12:07", "is_worked_example": true, "text": "The rest of the accesses have all been hits."}, {"start": "00:12:07", "is_lecture": false, "end": "00:12:30", "is_worked_example": true, "text": "This process repeats itself with a data miss for array element A[i], and a data hit for array element B[i] until we get to A[5] which actually results in a hit because it corresponds to the location in memory that holds the BNE(R0, R) instruction which is already in the cache at line 5."}, {"start": "00:12:30", "is_lecture": false, "end": "00:12:35", "is_worked_example": true, "text": "From then on the remaining data accesses all result in hits."}, {"start": "00:12:35", "is_lecture": false, "end": "00:12:42", "is_worked_example": true, "text": "At this point we have completed the inner loop and proceed to the remaining instructions in the outer loop."}, {"start": "00:12:42", "is_lecture": false, "end": "00:12:48", "is_worked_example": true, "text": "These instructions are the second SUBC and the second BNE instructions."}, {"start": "00:12:48", "is_lecture": false, "end": "00:12:55", "is_worked_example": true, "text": "These correspond to the data that is in lines 6 and 7 of the cache thus resulting in hits."}, {"start": "00:12:55", "is_lecture": false, "end": "00:13:06", "is_worked_example": true, "text": "The loop then repeats itself 1000 times but each time through all the instructions and all the data is in the cache so they all result in hits."}, {"start": "00:13:06", "is_lecture": false, "end": "00:13:14", "is_worked_example": true, "text": "So the total number of misses that we get when executing this benchmark on a direct mapped cache is 16."}, {"start": "00:13:14", "is_lecture": false, "end": "00:13:22", "is_worked_example": true, "text": "These are known as compulsory misses which are misses that occur when you are first loading the data into your cache."}, {"start": "00:13:22", "is_lecture": false, "end": "00:13:28", "is_worked_example": true, "text": "Recall that the direct mapped cache has one set of 64 lines in the cache."}, {"start": "00:13:28", "is_lecture": false, "end": "00:13:39", "is_worked_example": true, "text": "The 2-way set associative has 2 sets of 32 lines each, and the 4-way set associative has 4 sets of 16 lines each."}, {"start": "00:13:39", "is_lecture": false, "end": "00:14:12", "is_worked_example": true, "text": "Since only 16 lines are required to fit all the instructions and data associated with this benchmark, this means that effectively, only one set will be used in the set associative caches, and because even in the 4-way set associative cache there are 16 lines, that means that once the data is loaded into the cache it does not need to be replaced with other data so after the first miss per line, the remaining accesses in the entire benchmark will be hits."}, {"start": "00:14:12", "is_lecture": false, "end": "00:14:20", "is_worked_example": true, "text": "So the total number of misses in the 2-way and 4-way set associative caches is also 16."}]}, "C04S03B04-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c4/c4s1/4?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c4s1v4", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "Let's take a closer look at how macros work in UASM."}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:11", "is_worked_example": false, "text": "Here we see the definition of the macro \"consec\" which has a single parameter \"n\"."}, {"start": "00:00:11", "is_lecture": true, "end": "00:00:14", "is_worked_example": false, "text": "The body of the macro is a sequence of four expressions."}, {"start": "00:00:14", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "When there's an invocation of the \"consec\" macro, in this example with the argument 37, the body of the macro is expanded replacing all occurrences of \"n\" with the argument 37."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:32", "is_worked_example": false, "text": "The resulting text is then processed as if it had appeared in place of the macro invocation."}, {"start": "00:00:32", "is_lecture": true, "end": "00:00:41", "is_worked_example": false, "text": "In this example, the four expressions are evaluated to give a sequence of four values that will be placed in the next four bytes of the output array."}, {"start": "00:00:41", "is_lecture": true, "end": "00:00:51", "is_worked_example": false, "text": "Macro expansions may contain other macro invocations, which themselves will be expanded, continuing until all that's left are expressions to be evaluated."}, {"start": "00:00:51", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "Here we see the macro definition for WORD, which assembles its argument into two consecutive bytes."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "And for the macro LONG, which assembles its argument into four consecutive bytes, using the WORD macro to process the low 16 bits of the value, then the high 16 bits of the value."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:21", "is_worked_example": false, "text": "These two UASM statements cause the constant 0xDEADBEEF to converted to 4 bytes, which are then deposited in the output array starting at index 0x100."}, {"start": "00:01:21", "is_lecture": true, "end": "00:01:29", "is_worked_example": false, "text": "Note that the Beta expects the least-significant byte of a multi-byte value to be stored at the lowest byte address."}, {"start": "00:01:29", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "So the least-significant byte 0xEF is placed at address 0x100 and the most-significant byte 0xDE is placed at address 0x103."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "This is the \"little-endian\" convention for multi-byte values: the least-significant byte comes first."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "Intel's x86 architecture is also little-endian."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "There is a symmetrical \"big-endian\" convention where the most-significant byte comes first."}, {"start": "00:01:56", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "Both conventions are in active use and, in fact, some ISAs can be configured to use either convention!"}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:23", "is_worked_example": false, "text": "There is no right answer for which convention to use, but the fact that there two conventions means that we have to be alert for the need to convert the representation of multi-byte values when moving values between one ISA and another, e.g., when we send a data file to another user."}, {"start": "00:02:23", "is_lecture": true, "end": "00:02:30", "is_worked_example": false, "text": "As you can imagine there are strong advocates for both schemes who are happy to defend their point of view at great length."}, {"start": "00:02:30", "is_lecture": true, "end": "00:02:46", "is_worked_example": false, "text": "Given the heat of the discussion, it's appropriate that the names for the conventions were drawn from Jonathan Swift's \"Gulliver's Travels\" in which a civil war is fought over whether to open a soft-boiled egg at its big end or its little end."}, {"start": "00:02:46", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "Let's look at the macros used to assemble Beta instructions."}, {"start": "00:02:50", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "The BETAOP helper macro supports the 3-register instruction format, taking as arguments the values to be placed in the OPCODE, Ra, Rb, and Rc fields."}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:16", "is_worked_example": false, "text": "The \".align 4\" directive is a bit of administrative bookkeeping to ensure that instructions will have a byte address that's a multiple of 4, i.e., that they span exactly one 32-bit word in memory."}, {"start": "00:03:16", "is_lecture": true, "end": "00:03:25", "is_worked_example": false, "text": "That's followed by an invocation of the LONG macro to generate the 4 bytes of binary data representing the value of the expression shown here."}, {"start": "00:03:25", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "The expression is where the actual assembly of the fields takes place."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "Each field is limited to requisite number of bits using the modulo operator (%), then shifted left (<<) to the correct position in the 32-bit word."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:46", "is_worked_example": false, "text": "And here are the helper macros for the instructions that use a 16-bit constant as the second operand."}, {"start": "00:03:46", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "Let's follow the assembly of an ADDC instruction to see how this works."}, {"start": "00:03:52", "is_lecture": true, "end": "00:04:03", "is_worked_example": false, "text": "The ADDC macro expands into an invocation of the BETAOPC helper macro, passing along the correct value for the ADDC opcode, along with the three operands."}, {"start": "00:04:03", "is_lecture": true, "end": "00:04:07", "is_worked_example": false, "text": "The BETAOPC macro does the following arithmetic:"}, {"start": "00:04:07", "is_lecture": true, "end": "00:04:15", "is_worked_example": false, "text": "the OP argument, in this case the value 0x30, is shifted left to occupy the high-order 6 bits of the instruction."}, {"start": "00:04:15", "is_lecture": true, "end": "00:04:21", "is_worked_example": false, "text": "Then the RA argument, in this case 15, is placed in its proper location."}, {"start": "00:04:21", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "The 16-bit constant -32768 is positioned in the low 16 bits of the instruction."}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:36", "is_worked_example": false, "text": "And, finally, the Rc argument, in this case 0, is positioned in the Rc field of the instruction."}, {"start": "00:04:36", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "You can see why we call this processing \"assembling an instruction\"."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:48", "is_worked_example": false, "text": "The binary representation of an instruction is assembled from the binary values for each of the instruction fields."}, {"start": "00:04:48", "is_lecture": true, "end": "00:04:56", "is_worked_example": false, "text": "It's not a complicated process, but it requires a lot of shifting and masking, tasks that we're happy to let a computer handle."}, {"start": "00:04:56", "is_lecture": true, "end": "00:05:07", "is_worked_example": false, "text": "Here's the entire sequence of macro expansions that assemble this ADDC instruction into an appropriate 32-bit binary value in main memory."}, {"start": "00:05:07", "is_lecture": true, "end": "00:05:15", "is_worked_example": false, "text": "You can see that the knowledge of Beta instruction formats and opcode values is built into the bodies of the macro definitions."}, {"start": "00:05:15", "is_lecture": true, "end": "00:05:18", "is_worked_example": false, "text": "The UASM processing is actually quite general."}, {"start": "00:05:18", "is_lecture": true, "end": "00:05:25", "is_worked_example": false, "text": "With a different set of macro definitions it could process assembly language programs for almost any ISA!"}, {"start": "00:05:25", "is_lecture": true, "end": "00:05:36", "is_worked_example": false, "text": "All the macro definitions for the Beta ISA are provided in the beta.uasm file, which is included in each of the assembly language lab assignments."}, {"start": "00:05:36", "is_lecture": true, "end": "00:05:44", "is_worked_example": false, "text": "Note that we include some convenience macros to define shorthand representations that provide common default values for certain operands."}, {"start": "00:05:44", "is_lecture": true, "end": "00:05:53", "is_worked_example": false, "text": "For example, except for procedure calls, we don't care about the PC+4 value saved in the destination register by branch instructions,"}, {"start": "00:05:53", "is_lecture": true, "end": "00:06:03", "is_worked_example": false, "text": "so almost always would specify R31 as the Rc register, effectively discarding the PC+4 value saved by branches."}, {"start": "00:06:03", "is_lecture": true, "end": "00:06:10", "is_worked_example": false, "text": "So we define two-argument branch macros that automatically provide R31 as the destination register."}, {"start": "00:06:10", "is_lecture": true, "end": "00:06:17", "is_worked_example": false, "text": "Saves some typing, and, more importantly, it makes it easier to understand the assembly language program."}, {"start": "00:06:17", "is_lecture": true, "end": "00:06:22", "is_worked_example": false, "text": "Here are a whole set of convenience macros intended to make programs more readable."}, {"start": "00:06:22", "is_lecture": true, "end": "00:06:31", "is_worked_example": false, "text": "For example, unconditional branches can be written using the BR() macro rather than the more cumbersome BEQ(R31,...)."}, {"start": "00:06:31", "is_lecture": true, "end": "00:06:38", "is_worked_example": false, "text": "And it's more readable to use branch-false (BF) and branch-true (BT) macros when testing the results of a compare instruction."}, {"start": "00:06:38", "is_lecture": true, "end": "00:06:43", "is_worked_example": false, "text": "And note the PUSH and POP macros at the bottom of page."}, {"start": "00:06:43", "is_lecture": true, "end": "00:06:52", "is_worked_example": false, "text": "These expand into multi-instruction sequences, in this case to add and remove values from a stack data structure pointed to by the SP register."}, {"start": "00:06:52", "is_lecture": true, "end": "00:07:00", "is_worked_example": false, "text": "We call these macros \"pseudo instructions\" since they let us provide the programmer with what appears a larger instruction set,"}, {"start": "00:07:00", "is_lecture": true, "end": "00:07:07", "is_worked_example": false, "text": "although underneath the covers we've just using the same small instruction repertoire developed in Lecture 9."}, {"start": "00:07:07", "is_lecture": true, "end": "00:07:15", "is_worked_example": false, "text": "In this example we've rewritten the original code we had for the factorial computation using pseudo instructions."}, {"start": "00:07:15", "is_lecture": true, "end": "00:07:21", "is_worked_example": false, "text": "For example, CMOVE is a pseudo instruction for moving small constants into a register."}, {"start": "00:07:21", "is_lecture": true, "end": "00:07:32", "is_worked_example": false, "text": "It's easier for us to read and understand the intent of a \"constant move\" operation than an \"add a value to 0\" operation provided by the ADDC expansion of CMOVE."}, {"start": "00:07:32", "is_lecture": true, "end": "00:07:39", "is_worked_example": false, "text": "Anything we can do to remove the cognitive clutter will be very beneficial in the long run."}]}, "C04S03B05-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c4/c4s1/5?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c4s1v5", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "So far we've talked about assembling instructions."}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "What about data?"}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:13", "is_worked_example": false, "text": "How do we allocate and initialize data storage and how do we get those values into registers so that they can be used as operands?"}, {"start": "00:00:13", "is_lecture": true, "end": "00:00:19", "is_worked_example": false, "text": "Here we see a program that allocates and initializes two memory locations using the LONG macro."}, {"start": "00:00:19", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "We've used labels to remember the addresses of these locations for later reference."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:36", "is_worked_example": false, "text": "When the program is assembled the values of the label N and factN are 0 and 4 respectively, the addresses of the memory locations holding the two data values."}, {"start": "00:00:36", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "To access the first data value, the program uses a LD instruction, in this case one of convenience macros that supplies R31 as the default value of the Ra field."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:55", "is_worked_example": false, "text": "The assembler replaces the reference to the label N with its value 0 from the symbol table."}, {"start": "00:00:55", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "When the LD is executed, it computes the memory address by adding the constant (0) to the value of the Ra register (which is R31 and hence the value is 0)"}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:13", "is_worked_example": false, "text": "to get the address (0) of the memory location from which to fetch the value to be placed in R1."}, {"start": "00:01:13", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "The constants needed as values for data words and instruction fields can be written as expressions."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:27", "is_worked_example": false, "text": "These expressions are evaluated by the assembler as it assembles the program and the resulting value is used as needed."}, {"start": "00:01:27", "is_lecture": true, "end": "00:01:32", "is_worked_example": false, "text": "Note that the expressions are evaluated at the time the assembler runs."}, {"start": "00:01:32", "is_lecture": true, "end": "00:01:37", "is_worked_example": false, "text": "By the time the program runs on the Beta, the resulting value is used."}, {"start": "00:01:37", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "The assembler does NOT generate ADD and MUL instructions to compute the value during program execution."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:52", "is_worked_example": false, "text": "If a value is needed for an instruction field or initial data value, the assembler has to be able to perform the arithmetic itself."}, {"start": "00:01:52", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "If you need the program to compute a value during execution, you have to write the necessary instructions as part of your program."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:13", "is_worked_example": false, "text": "One last UASM feature: there's a special symbol \".\", called \"dot\", whose value is the address of the next main memory location to be filled by the assembler when it generates binary data."}, {"start": "00:02:13", "is_lecture": true, "end": "00:02:20", "is_worked_example": false, "text": "Initially \".\"  is 0 and it's incremented each time a new byte value is generated."}, {"start": "00:02:20", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "We can set the value of \".\" to tell the assembler where in memory we wish to place a value."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "In this example, the constant 0xDEADBEEF is placed into location 0x100 of main memory."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "And we can use \".\" in expressions to compute the values for other symbols, as shown here when defining the value for the symbol \"k\"."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "In fact, the label definition \"k:\" is exactly equivalent to the UASM statement \"k = .\""}, {"start": "00:02:50", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "We can even increment the value of \".\" to skip over locations, e.g., if we wanted to leave space for an un initialized array."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:03", "is_worked_example": false, "text": "And that's assembly language!"}, {"start": "00:03:03", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "We use assembly language as a convenient notation for generating the binary encoding for instructions and data."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:17", "is_worked_example": false, "text": "We let the assembler build the bit-level representations we need and to keep track of the addresses where these values are stored in main memory."}, {"start": "00:03:17", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "UASM itself provides support for values, symbols, labels and macros."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:29", "is_worked_example": false, "text": "Values can be written as constants or expressions involving constants."}, {"start": "00:03:29", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "We use symbols to give meaningful names to values so that our programs will be more readable and more easily modified."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "Similarly, we use labels to give meaningful names to addresses in main memory and then use the labels in referring to data locations in LD or ST instructions, or to instruction locations in branch instructions."}, {"start": "00:03:52", "is_lecture": true, "end": "00:03:58", "is_worked_example": false, "text": "Macros hide the details of how instructions are assembled from their component fields."}, {"start": "00:03:58", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "And we can use \".\" to control where the assembler places values in main memory."}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:09", "is_worked_example": false, "text": "The assembler is itself a program that runs on our computer."}, {"start": "00:04:09", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "That raises an interesting \"chicken and egg problem\":"}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:18", "is_worked_example": false, "text": "how did the first assembler program get assembled into binary so it could run on a computer?"}, {"start": "00:04:18", "is_lecture": true, "end": "00:04:21", "is_worked_example": false, "text": "Well, it was hand-assembled into binary."}, {"start": "00:04:21", "is_lecture": true, "end": "00:04:35", "is_worked_example": false, "text": "I suspect it processed a very simple language indeed, with the bells and whistles of symbols, labels, macros, expression evaluation, etc. added only after basic instructions could be assembled by the program."}, {"start": "00:04:35", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "And I'm sure they were very careful not loose the binary so they wouldn't have to do the hand-assembly a second time!"}]}, "C03S02B01-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s2/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s2v1", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:16", "is_worked_example": true, "text": "For this problem, we are going to make use of this simple datapath that consists of a four register register file, a relatively simple arithmetic logic unit that can perform ADD, SUB, MUL, and NAND operations."}, {"start": "00:00:16", "is_lecture": false, "end": "00:00:21", "is_worked_example": true, "text": "In addition, it can compare two inputs and determine whether or not they are equal."}, {"start": "00:00:21", "is_lecture": false, "end": "00:00:26", "is_worked_example": true, "text": "The result of the comparison, Z, can then be used to control what happens next."}, {"start": "00:00:26", "is_lecture": false, "end": "00:00:30", "is_worked_example": true, "text": "There are multiple control signals in this datapath."}, {"start": "00:00:30", "is_lecture": false, "end": "00:00:33", "is_worked_example": true, "text": "The first two are Asel and Bsel."}, {"start": "00:00:33", "is_lecture": false, "end": "00:00:38", "is_worked_example": true, "text": "These are used to select which register drives the corresponding multiplexer output."}, {"start": "00:00:38", "is_lecture": false, "end": "00:00:49", "is_worked_example": true, "text": "The value stored in the register selected by Asel becomes the A input to the arithmetic operations and is passed to the arithmetic units along the red wire."}, {"start": "00:00:49", "is_lecture": false, "end": "00:00:59", "is_worked_example": true, "text": "The value stored in the register selected by Bsel becomes the B input to the arithmetic operations and is passed to the arithmetic units along the blue wire."}, {"start": "00:00:59", "is_lecture": false, "end": "00:01:02", "is_worked_example": true, "text": "The next control signal is Opsel."}, {"start": "00:01:02", "is_lecture": false, "end": "00:01:11", "is_worked_example": true, "text": "It selects which of the four operation outputs should be selected by the Opsel multiplexer as the result of our operation."}, {"start": "00:01:11", "is_lecture": false, "end": "00:01:15", "is_worked_example": true, "text": "This result is fed back to the register file along the purple wire."}, {"start": "00:01:15", "is_lecture": false, "end": "00:01:27", "is_worked_example": true, "text": "The Wen is a write enable for the register file which specifies whether or not the result of our operation should be written back into the register file."}, {"start": "00:01:27", "is_lecture": false, "end": "00:01:37", "is_worked_example": true, "text": "If it is supposed to be written back to the register file, then the Wsel control signal selects to which of the registers the result should be written."}, {"start": "00:01:37", "is_lecture": false, "end": "00:01:40", "is_worked_example": true, "text": "The yellow box is the control FSM."}, {"start": "00:01:40", "is_lecture": false, "end": "00:01:47", "is_worked_example": true, "text": "It generates the control signals for the rest of the datapath based on the operations that you want to perform."}, {"start": "00:01:47", "is_lecture": false, "end": "00:01:52", "is_worked_example": true, "text": "Suppose the initial value of our 4 registers is:"}, {"start": "00:01:52", "is_lecture": false, "end": "00:01:59", "is_worked_example": true, "text": "R0 = 1, R1 = 0, R2 = -1, and R3 = N."}, {"start": "00:01:59", "is_lecture": false, "end": "00:02:07", "is_worked_example": true, "text": "We want to evaluate the result of the function 3 * N -- 2 and store the result into R3."}, {"start": "00:02:07", "is_lecture": false, "end": "00:02:15", "is_worked_example": true, "text": "Our job is to design the control FSM so that it produces the correct signals to achieve what we want."}, {"start": "00:02:15", "is_lecture": false, "end": "00:02:22", "is_worked_example": true, "text": "To help us get started, here is an incomplete listing of the code that will achieve what we want."}, {"start": "00:02:22", "is_lecture": false, "end": "00:02:27", "is_worked_example": true, "text": "The Sx labels are the names of the states corresponding to each instruction in our program."}, {"start": "00:02:27", "is_lecture": false, "end": "00:02:35", "is_worked_example": true, "text": "Our first job is to figure out the values of RX, RY, and RZ so that our code behaves as expected."}, {"start": "00:02:35", "is_lecture": false, "end": "00:02:38", "is_worked_example": true, "text": "Let's begin by looking at state S0."}, {"start": "00:02:38", "is_lecture": false, "end": "00:02:48", "is_worked_example": true, "text": "We want to end up with the value -2 in R2 by adding R2 which currently holds -1 to some register."}, {"start": "00:02:48", "is_lecture": false, "end": "00:02:55", "is_worked_example": true, "text": "In order to produce -2, we need to add -1 which means that RX = R2."}, {"start": "00:02:55", "is_lecture": false, "end": "00:03:00", "is_worked_example": true, "text": "Next, we look at state S1."}, {"start": "00:03:00", "is_lecture": false, "end": "00:03:08", "is_worked_example": true, "text": "Here we want to end up with the value 2 in R1 by adding Ry to R0 which currently holds a 1."}, {"start": "00:03:08", "is_lecture": false, "end": "00:03:14", "is_worked_example": true, "text": "In order to produce 2, we need to add 1 which means RY = R0."}, {"start": "00:03:14", "is_lecture": false, "end": "00:03:22", "is_worked_example": true, "text": "State S2 adds R0 to R1 and stores the result in R1."}, {"start": "00:03:22", "is_lecture": false, "end": "00:03:28", "is_worked_example": true, "text": "Since R0 still equals 1 and R1 = 2, then we produce R1 = 3."}, {"start": "00:03:28", "is_lecture": false, "end": "00:03:31", "is_worked_example": true, "text": "Now, let's look at state S3."}, {"start": "00:03:31", "is_lecture": false, "end": "00:03:37", "is_worked_example": true, "text": "Our goal is to multiply 3*N and store the result into R3."}, {"start": "00:03:37", "is_lecture": false, "end": "00:03:43", "is_worked_example": true, "text": "To achieve this, we multiply RZ by R3 and store the result in R3."}, {"start": "00:03:43", "is_lecture": false, "end": "00:03:50", "is_worked_example": true, "text": "Since R3 currently = N, that means that we want to multiply it by R1 which equals 3."}, {"start": "00:03:50", "is_lecture": false, "end": "00:03:53", "is_worked_example": true, "text": "So RZ = R1."}, {"start": "00:03:53", "is_lecture": false, "end": "00:04:02", "is_worked_example": true, "text": "Finally, we add R3 and R2 to produce 3*N-2 and store that result back into R3."}, {"start": "00:04:02", "is_lecture": false, "end": "00:04:08", "is_worked_example": true, "text": "S5 just executes a HALT() instruction to indicate that we are done."}, {"start": "00:04:08", "is_lecture": false, "end": "00:04:18", "is_worked_example": true, "text": "Now that we have working code, our next goal is to determine the settings for the control FSM that will make the correct operations be executed by our datapath."}, {"start": "00:04:18", "is_lecture": false, "end": "00:04:25", "is_worked_example": true, "text": "Since we have 6 states, we will need 3 state bits to encode the value of the current and next state."}, {"start": "00:04:25", "is_lecture": false, "end": "00:04:28", "is_worked_example": true, "text": "We begin with state S0."}, {"start": "00:04:28", "is_lecture": false, "end": "00:04:40", "is_worked_example": true, "text": "In order to encode that we are in state zero using 3 bits, we set our current state, S[2:0] to 000."}, {"start": "00:04:40", "is_lecture": false, "end": "00:04:47", "is_worked_example": true, "text": "In this operation we don't care about the Z signal, so Z = X which means don't care."}, {"start": "00:04:47", "is_lecture": false, "end": "00:04:54", "is_worked_example": true, "text": "The instruction that we want to execute after this first ADD, is the next ADD in state S1."}, {"start": "00:04:54", "is_lecture": false, "end": "00:04:58", "is_worked_example": true, "text": "This means that our next state is 001."}, {"start": "00:04:58", "is_lecture": false, "end": "00:05:03", "is_worked_example": true, "text": "Note that the notation S' is often used to represent the next state."}, {"start": "00:05:03", "is_lecture": false, "end": "00:05:09", "is_worked_example": true, "text": "Our register select signals each need to select one of 4 registers."}, {"start": "00:05:09", "is_lecture": false, "end": "00:05:14", "is_worked_example": true, "text": "This means that these signals must each be 2 bits wide."}, {"start": "00:05:14", "is_lecture": false, "end": "00:05:19", "is_worked_example": true, "text": "Our Asel control signal identifies the register that should be used as input A."}, {"start": "00:05:19", "is_lecture": false, "end": "00:05:24", "is_worked_example": true, "text": "This register is R2, so Asel is 10."}, {"start": "00:05:24", "is_lecture": false, "end": "00:05:28", "is_worked_example": true, "text": "Bsel identifies the second source operand."}, {"start": "00:05:28", "is_lecture": false, "end": "00:05:35", "is_worked_example": true, "text": "In this case it is also R2, so Bsel = 10 as well."}, {"start": "00:05:35", "is_lecture": false, "end": "00:05:40", "is_worked_example": true, "text": "The Opsel signal identifies which operation we want to perform."}, {"start": "00:05:40", "is_lecture": false, "end": "00:05:50", "is_worked_example": true, "text": "Since we have 4 distinct operations, we would need two bits to distinguish amongst them and we would make each operation be associated with one of the 4 encodings."}, {"start": "00:05:50", "is_lecture": false, "end": "00:05:57", "is_worked_example": true, "text": "For simplicity, let's just label Opsel as ADD to indicate that we selected the encoding for the ADD."}, {"start": "00:05:57", "is_lecture": false, "end": "00:06:06", "is_worked_example": true, "text": "The register we want to write our result to, also known as the destination register, is R2 for this operation."}, {"start": "00:06:06", "is_lecture": false, "end": "00:06:13", "is_worked_example": true, "text": "This means that Wsel = 10 and Wen = 1."}, {"start": "00:06:13", "is_lecture": false, "end": "00:06:17", "is_worked_example": true, "text": "Wen is a signal that enables writing to the register file."}, {"start": "00:06:17", "is_lecture": false, "end": "00:06:25", "is_worked_example": true, "text": "If it is set to 0, then regardless of the value of Wsel, no value will be written into the register file."}, {"start": "00:06:25", "is_lecture": false, "end": "00:06:29", "is_worked_example": true, "text": "Now let's quickly run through the rest of our instructions."}, {"start": "00:06:29", "is_lecture": false, "end": "00:06:34", "is_worked_example": true, "text": "Our current state is state S1, or 001."}, {"start": "00:06:34", "is_lecture": false, "end": "00:06:36", "is_worked_example": true, "text": "Once again Z is a don't care."}, {"start": "00:06:36", "is_lecture": false, "end": "00:06:43", "is_worked_example": true, "text": "Since the instruction that will be executed next is the one in S2, our next state is 010."}, {"start": "00:06:43", "is_lecture": false, "end": "00:06:49", "is_worked_example": true, "text": "Our Asel = 00 and Bsel = 00."}, {"start": "00:06:49", "is_lecture": false, "end": "00:06:56", "is_worked_example": true, "text": "Opsel = ADD and Wsel = 01 and Wen = 1."}, {"start": "00:06:56", "is_lecture": false, "end": "00:07:05", "is_worked_example": true, "text": "State 2 follows the same model, so current state is 010 and next state is 011."}, {"start": "00:07:05", "is_lecture": false, "end": "00:07:15", "is_worked_example": true, "text": "Here Asel = 00, Bsel = 01 and Wsel = 01 and Wen = 1."}, {"start": "00:07:15", "is_lecture": false, "end": "00:07:18", "is_worked_example": true, "text": "Once again our Opsel is an ADD."}, {"start": "00:07:18", "is_lecture": false, "end": "00:07:26", "is_worked_example": true, "text": "We move on to state 3 whose current state is 011 and next state is 100."}, {"start": "00:07:26", "is_lecture": false, "end": "00:07:36", "is_worked_example": true, "text": "Asel = 01, Bsel = 11, Wsel = 11, and Wen = 1."}, {"start": "00:07:36", "is_lecture": false, "end": "00:07:44", "is_worked_example": true, "text": "Here our Opsel is MUL to indicate that the operation to be executed here is a multiply."}, {"start": "00:07:44", "is_lecture": false, "end": "00:07:51", "is_worked_example": true, "text": "For state four, we have current state set to 100 and next state to 101."}, {"start": "00:07:51", "is_lecture": false, "end": "00:08:00", "is_worked_example": true, "text": "Asel = 11, Bsel = 10, Wsel = 11, and Wen = 1."}, {"start": "00:08:00", "is_lecture": false, "end": "00:08:03", "is_worked_example": true, "text": "Our Opsel is once again ADD."}, {"start": "00:08:03", "is_lecture": false, "end": "00:08:06", "is_worked_example": true, "text": "Finally, we reach state 5."}, {"start": "00:08:06", "is_lecture": false, "end": "00:08:11", "is_worked_example": true, "text": "This state looks a little different from the previous states so lets examine it a little more closely."}, {"start": "00:08:11", "is_lecture": false, "end": "00:08:22", "is_worked_example": true, "text": "The first thing to note, is that when we get to state 5 we want to stay there because we are done with our execution, so both the current state and the next state are 101."}, {"start": "00:08:22", "is_lecture": false, "end": "00:08:32", "is_worked_example": true, "text": "Most of the other control bits can be set to don't care because at this point we mostly don't care about what the rest of the datapath is doing."}, {"start": "00:08:32", "is_lecture": false, "end": "00:08:36", "is_worked_example": true, "text": "The only other signal that we do need to worry about is Wen."}, {"start": "00:08:36", "is_lecture": false, "end": "00:08:47", "is_worked_example": true, "text": "Since we are allowing the rest of our datapath to run in whatever way, we need to ensure that nothing produced on the datapath at this stage gets written back to any of the registers."}, {"start": "00:08:47", "is_lecture": false, "end": "00:08:52", "is_worked_example": true, "text": "In order to guarantee that, we set Wen = 0."}, {"start": "00:08:52", "is_lecture": false, "end": "00:09:02", "is_worked_example": true, "text": "Here is the complete control ROM that will execute the function 3*N-2 and store its result into R3."}]}, "C07S01B07-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c7/c7s1/7?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c7s1v7", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "Let's practice our newfound skill and see what we can determine about a running program which we've stopped somewhere in the middle of its execution."}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "We're told that a computation of fact() is in progress and that the PC of the next instruction to be executed is 0x40."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "We're also given the stack dump shown on right."}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "Since we're in the middle of a fact computation, we know that current stack frame (and possibly others) is an activation record for the fact function."}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:39", "is_worked_example": false, "text": "Using the code on the previous slide we can determine the layout of the stack frame and generate the annotations shown on the right of the stack dump."}, {"start": "00:00:39", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "With the annotations, it's easy to see that the argument to current active call is the value 3."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:52", "is_worked_example": false, "text": "Now we want to know the argument to original call to fact."}, {"start": "00:00:52", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "We'll have to label the other stack frames using the saved BP values."}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:12", "is_worked_example": false, "text": "Looking at the saved LP values for each frame (always found at an offset of -8 from the frame's BP), we see that many of the saved values are 0x40, which must be the return address for the recursive fact calls."}, {"start": "00:01:12", "is_lecture": true, "end": "00:01:23", "is_worked_example": false, "text": "Looking through the stack frames we find the first return address that's *not* 0x40, which must an return address to code that's not part of the fact procedure."}, {"start": "00:01:23", "is_lecture": true, "end": "00:01:32", "is_worked_example": false, "text": "This means we've found the stack frame created by the original call to fact and can see that argument to the original call is 6."}, {"start": "00:01:32", "is_lecture": true, "end": "00:01:36", "is_worked_example": false, "text": "What's the location of the BR that made the original call?"}, {"start": "00:01:36", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "Well, the saved LP in the stack frame of the original call to fact is 0x80."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:54", "is_worked_example": false, "text": "That's the address of the instruction following the original call, so the BR that made the original call is one instruction earlier, at location 0x7C."}, {"start": "00:01:54", "is_lecture": true, "end": "00:01:58", "is_worked_example": false, "text": "To answer these questions you have to be good at hex arithmetic!"}, {"start": "00:01:58", "is_lecture": true, "end": "00:02:02", "is_worked_example": false, "text": "What instruction is about to be executed?"}, {"start": "00:02:02", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "We were told its address is 0x40, which we notice is the saved LP value for all the recursive fact calls."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:17", "is_worked_example": false, "text": "So 0x40 must be the address of the instruction following the BR(fact,LP) instruction in the fact code."}, {"start": "00:02:17", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "Looking back a few slides at the fact code, we see that's a DEALLOCATE(1) instruction."}, {"start": "00:02:24", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "What value is in BP?"}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:35", "is_worked_example": false, "text": "Hmm.  We know BP is the address of the stack location containing the saved R1 value in the current stack frame."}, {"start": "00:02:35", "is_lecture": true, "end": "00:02:44", "is_worked_example": false, "text": "So the saved BP value in the current stack frame is the address of the saved R1 value in the *previous* stack frame."}, {"start": "00:02:44", "is_lecture": true, "end": "00:02:53", "is_worked_example": false, "text": "So the saved BP value gives us the address of a particular stack location, from which we can derive the address of all the other locations!"}, {"start": "00:02:53", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "Counting forward, we find that the value in BP must be 0x13C."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "What value is in SP?"}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "Since we're about to execute the DEALLOCATE to remove the argument of the nested call from the stack, that argument must still be on the stack right after the saved R1 value."}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "Since the SP points to first unused stack location, it points to the location after that word, so it has the value 0x144."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:27", "is_worked_example": false, "text": "Finally, what value is in R0?"}, {"start": "00:03:27", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "Since we've just returned from a call to fact(2) the value in R0 must the result from that recursive call, which is 2."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:42", "is_worked_example": false, "text": "Wow!  You can learn a lot from the stacked activation records and a little deduction!"}, {"start": "00:03:42", "is_lecture": true, "end": "00:03:55", "is_worked_example": false, "text": "Since the state of the computation is represented by the values of the PC, the registers, and main memory, once we're given that information we can tell exactly what the program has been up to."}, {"start": "00:03:55", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "Pretty neat..."}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "Wrapping up, we've been dedicating some registers to help with our various software conventions."}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "To summarize:"}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:08", "is_worked_example": false, "text": "R31 is always zero, as defined by the ISA."}, {"start": "00:04:08", "is_lecture": true, "end": "00:04:16", "is_worked_example": false, "text": "We'll also dedicate R30 to a particular function in the ISA when we discuss the implementation of the Beta in the next lecture."}, {"start": "00:04:16", "is_lecture": true, "end": "00:04:20", "is_worked_example": false, "text": "Meanwhile, don't use R30 in your code!"}, {"start": "00:04:20", "is_lecture": true, "end": "00:04:25", "is_worked_example": false, "text": "The remaining dedicated registers are connected with our software conventions:"}, {"start": "00:04:25", "is_lecture": true, "end": "00:04:30", "is_worked_example": false, "text": "R29 (SP) is used as the stack pointer,"}, {"start": "00:04:30", "is_lecture": true, "end": "00:04:34", "is_worked_example": false, "text": "R28 (LP) is used as the linkage pointer, and"}, {"start": "00:04:34", "is_lecture": true, "end": "00:04:39", "is_worked_example": false, "text": "R27 (BP) is used as the base pointer."}, {"start": "00:04:39", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "As you practice reading and writing code, you'll grow familiar with these dedicated registers."}, {"start": "00:04:44", "is_lecture": true, "end": "00:04:57", "is_worked_example": false, "text": "In thinking about how to implement procedures, we discovered the need for an activation record to store the information needed by any active procedure call."}, {"start": "00:04:57", "is_lecture": true, "end": "00:05:02", "is_worked_example": false, "text": "An activation record is created by the caller and callee at the start of a procedure call."}, {"start": "00:05:02", "is_lecture": true, "end": "00:05:06", "is_worked_example": false, "text": "And the record can be discarded when the procedure is complete."}, {"start": "00:05:06", "is_lecture": true, "end": "00:05:16", "is_worked_example": false, "text": "The activation records hold argument values, saved LP and BP values along with the caller's values in any other of the registers."}, {"start": "00:05:16", "is_lecture": true, "end": "00:05:22", "is_worked_example": false, "text": "Storage for the procedure's local variables is also allocated in the activation record."}, {"start": "00:05:22", "is_lecture": true, "end": "00:05:30", "is_worked_example": false, "text": "We use BP to point to the current activation record, giving easy access the values of the arguments and local variables."}, {"start": "00:05:30", "is_lecture": true, "end": "00:05:41", "is_worked_example": false, "text": "We adopted a \"callee saves\" convention where the called procedure is obligated to preserve the values in all registers except for R0."}, {"start": "00:05:41", "is_lecture": true, "end": "00:05:51", "is_worked_example": false, "text": "Taken together, these conventions allow us to have procedures with arbitrary numbers of arguments and local variables, with nested and recursive procedure calls."}, {"start": "00:05:51", "is_lecture": true, "end": "00:05:56", "is_worked_example": false, "text": "We're now ready to compile and execute any C program!"}]}, "C03S01B02-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s1/2?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s1v2", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:05", "is_worked_example": false, "text": "Okay, we've figured out a way to design hardware to perform a particular computation:"}, {"start": "00:00:05", "is_lecture": true, "end": "00:00:12", "is_worked_example": false, "text": "Draw the state transition diagram for an FSM that describes the sequence of operations needed to complete the computation."}, {"start": "00:00:12", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "Then construct the appropriate datapath, using registers to store values and combinational logic to implement the needed operations."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "Finally build an FSM to generate the control signals required by the datapath."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:30", "is_worked_example": false, "text": "Is the datapath plus control logic itself an FSM?"}, {"start": "00:00:30", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "Well, it has registers and some combinational logic, so, yes, it is an FSM."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:38", "is_worked_example": false, "text": "Can we draw the truth table?"}, {"start": "00:00:38", "is_lecture": true, "end": "00:00:40", "is_worked_example": false, "text": "In theory, yes."}, {"start": "00:00:40", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "In practice, there are 66 bits of registers and hence 66 bits of state, so our truth table would need 2^66 rows!"}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "Hmm, not very likely that we'd be able to draw the truth table!"}, {"start": "00:00:53", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "The difficulty comes from thinking of the registers in the datapath as part of the state of our super-FSM."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:03", "is_worked_example": false, "text": "That's why we think about the datapath as being separate from the control FSM."}, {"start": "00:01:03", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "So how do we generalize this approach so we can use one computer circuit to solve many different problems."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:17", "is_worked_example": false, "text": "Well, most problems would probably require more storage for operands and results."}, {"start": "00:01:17", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "And a larger list of allowable operations would be handy."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:26", "is_worked_example": false, "text": "This is actually a bit tricky: what's the minimum set of operations we can get away with?"}, {"start": "00:01:26", "is_lecture": true, "end": "00:01:32", "is_worked_example": false, "text": "As we'll see later, surprisingly simple hardware is sufficient to perform any realizable computation."}, {"start": "00:01:32", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "At the other extreme, many complex operations (e.g., fast fourier transform) are best implemented as sequences of simpler operations (e.g., add and multiply) rather than as a single massive combinational circuit."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:51", "is_worked_example": false, "text": "These sorts of design tradeoffs are what makes computer architecture fun!"}, {"start": "00:01:51", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "We'd then combine our larger storage with logic for our chosen set of operations into a general purpose datapath that could be reused to solve many different problems."}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:03", "is_worked_example": false, "text": "Let's see how that would work..."}, {"start": "00:02:03", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "Here's a datapath with 4 data registers to hold results."}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "The ASEL and BSEL multiplexers allow any of the data registers to be selected as either operand for our repertoire of arithmetic and boolean operations."}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "The result is selected by the OPSEL MUX and can be written back into any of the data registers by setting the WEN control signal to 1 and using the 2-bit WSEL signal to select which data register will be loaded at the next rising clock edge."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "Note that the data registers have a load-enable control input."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:46", "is_worked_example": false, "text": "When this signal is 1, the register will load a new value from its D input, otherwise it ignores the D input and simply reloads its previous value."}, {"start": "00:02:46", "is_lecture": true, "end": "00:02:53", "is_worked_example": false, "text": "And, of course, we'll add a control FSM to generate the appropriate sequence of control signals for the datapath."}, {"start": "00:02:53", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "The Z input from the datapath allows the system to perform data-dependent operations, where the sequence of operations can be influenced by the actual values in the data registers."}, {"start": "00:03:04", "is_lecture": true, "end": "00:03:15", "is_worked_example": false, "text": "Here's the state transition diagram for the control FSM we'd use if we wanted to use this datapath to compute factorial assuming the initial contents of the data registers are as shown."}, {"start": "00:03:15", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "We need a few more states than in our initial implementation since this datapath can only perform one operation at each step."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:31", "is_worked_example": false, "text": "So we need three steps for each iteration: one for the multiply, one for the decrement, and one for the test to see if we're done."}, {"start": "00:03:31", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "As seen here, it's often the case that general-purpose computer hardware will need more cycles and perhaps involve more hardware than an optimized single-purpose circuit."}, {"start": "00:03:41", "is_lecture": true, "end": "00:03:45", "is_worked_example": false, "text": "You can solve many different problems with this system:"}, {"start": "00:03:45", "is_lecture": true, "end": "00:03:54", "is_worked_example": false, "text": "exponentiation, division, square root, and so on, so long as you don't need more than four data registers to hold input data, intermediate results, or the final answer."}, {"start": "00:03:54", "is_lecture": true, "end": "00:04:03", "is_worked_example": false, "text": "By designing a control FSM, we are in effect \"programming\" our digital system, specifying the sequence of operations it will perform."}, {"start": "00:04:03", "is_lecture": true, "end": "00:04:07", "is_worked_example": false, "text": "This is exactly how the early digital computers worked!"}, {"start": "00:04:07", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "Here's a picture of the ENIAC computer built in 1943 at the University of Pennsylvania."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:23", "is_worked_example": false, "text": "The Wikipedia article on the ENIAC tells us that \"ENIAC could be programmed to perform complex sequences of operations, including loops, branches, and subroutines."}, {"start": "00:04:23", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "The task of taking a problem and mapping it onto the machine was complex, and usually took weeks."}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:38", "is_worked_example": false, "text": "After the program was figured out on paper, the process of getting the program into ENIAC by manipulating its switches and cables could take days."}, {"start": "00:04:38", "is_lecture": true, "end": "00:04:45", "is_worked_example": false, "text": "This was followed by a period of verification and debugging, aided by the ability to execute the program step by step.\""}, {"start": "00:04:45", "is_lecture": true, "end": "00:04:50", "is_worked_example": false, "text": "It's clear that we need a less cumbersome way to program our computer!"}]}, "C09S01B07-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c9/c9s1/7?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c9s1v7", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "One last bit of housekeeping, then we're done!"}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "What should our hardware do if for some reason an instruction can't be executed?"}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "For example, if a programming error has led to trying to execute some piece of data as an instruction and the opcode field doesn't correspond to a Beta instruction (a so-called \"illop\" or illegal operation)."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "Or maybe the memory address is larger than the actual amount main memory."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "Or maybe one of the operand values is not acceptable, e.g., if the B operand for a DIV instruction is 0."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:45", "is_worked_example": false, "text": "In modern computers, the accepted strategy is cease execution of the running program and transfer control to some error handler code."}, {"start": "00:00:45", "is_lecture": true, "end": "00:00:50", "is_worked_example": false, "text": "The error handler might store the program state onto disk for later debugging."}, {"start": "00:00:50", "is_lecture": true, "end": "00:01:01", "is_worked_example": false, "text": "Or, for an unimplemented but legal opcode, it might emulate the missing instruction in software and resume execution as if the instruction had been implemented in hardware!"}, {"start": "00:01:01", "is_lecture": true, "end": "00:01:08", "is_worked_example": false, "text": "There's also the need to deal with external events, like those associated with input and output."}, {"start": "00:01:08", "is_lecture": true, "end": "00:01:19", "is_worked_example": false, "text": "Here we'd like to interrupt the execution of the current program, run some code to deal with the external event, then resume execution as if the interrupt had never happened."}, {"start": "00:01:19", "is_lecture": true, "end": "00:01:27", "is_worked_example": false, "text": "To deal with these cases, we'll add hardware to treat exceptions like forced procedure calls to special code to handle the situation,"}, {"start": "00:01:27", "is_lecture": true, "end": "00:01:36", "is_worked_example": false, "text": "arranging to save the PC+4 value of the interrupted program so that the handler can resume execution if it wishes."}, {"start": "00:01:36", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "This is a very powerful feature since it allows us to transfer control to software to handle most any circumstance beyond the capability of our modest hardware."}, {"start": "00:01:46", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "As we'll see in Part 3 of the course, the exception hardware will be our key to interfacing running programs to the operating system (OS) and to allow the OS to deal with external events without any awareness on the part of the running program."}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "So our plan is to interrupt the running program, acting like the current instruction was actually a procedure call to the handler code."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:20", "is_worked_example": false, "text": "When it finishes execution, the handler can, if appropriate, use the normal procedure return sequence to resume execution of the user program."}, {"start": "00:02:20", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "We'll use the term \"exception\" to refer to exceptions caused by executing the current program."}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "Such exceptions are \"synchronous\" in the sense that they are triggered by executing a particular instruction."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "In other words, if the program was re-run with the same data, the same exception would occur."}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:49", "is_worked_example": false, "text": "We'll use the term \"interrupt\" to refer to asynchronous exceptions resulting from external events whose timing is unrelated to the currently running program."}, {"start": "00:02:49", "is_lecture": true, "end": "00:02:53", "is_worked_example": false, "text": "The implementation for both types of exceptions is the same."}, {"start": "00:02:53", "is_lecture": true, "end": "00:03:07", "is_worked_example": false, "text": "When an exception is detected, the Beta hardware will behave as if the current instruction was a taken BR to either location 0x4 (for synchronous exceptions) or location 0x8 (for asynchronous interrupts)."}, {"start": "00:03:07", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "Presumably the instructions in those locations will jump to the entry points of the appropriate handler routines."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "We'll save the PC+4 value of the interrupted program into R30, a register dedicated to that purpose."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "We'll call that register XP (\"exception pointer\") to remind ourselves of how we're using it."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:46", "is_worked_example": false, "text": "Since interrupts in particular can happen at any point during a program's execution, thus overwriting the contents of XP at any time, user programs can't use the XP register to hold values since those values might disappear at any moment!"}, {"start": "00:03:46", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "Here's how this scheme works:"}, {"start": "00:03:49", "is_lecture": true, "end": "00:03:55", "is_worked_example": false, "text": "suppose we don't include hardware to implement the DIV instruction, so it's treated as an illegal opcode."}, {"start": "00:03:55", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "The exception hardware forces a procedure call to location 0x4, which then branches to the Illop handler shown here."}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:17", "is_worked_example": false, "text": "The PC+4 value of the DIV instruction has been saved in the XP register, so the handler can fetch the illegal instruction and, if it can, emulate its operation in software."}, {"start": "00:04:17", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "When handler is complete, it can resume execution of the original program at the instruction following DIV by performing a JMP(XP)."}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "Pretty neat!"}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "To handle exceptions, we only need a few simple changes to the datapath."}, {"start": "00:04:33", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "We've added a MUX controlled by the WASEL signal to choose the write-back address for the register file."}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:47", "is_worked_example": false, "text": "When WASEL is 1, write-back will occur to the XP register, i.e., register 30."}, {"start": "00:04:47", "is_lecture": true, "end": "00:04:57", "is_worked_example": false, "text": "When WASEL is 0, write-back will occur normally, i.e., to the register specified by the RC field of the current instruction."}, {"start": "00:04:57", "is_lecture": true, "end": "00:05:04", "is_worked_example": false, "text": "The remaining two inputs of the PCSEL MUX are set to the constant addresses for the exception handlers."}, {"start": "00:05:04", "is_lecture": true, "end": "00:05:09", "is_worked_example": false, "text": "In our case, 0x4 for illegal operations, and 0x8 for interrupts."}, {"start": "00:05:09", "is_lecture": true, "end": "00:05:13", "is_worked_example": false, "text": "Here's the flow of control during an exception."}, {"start": "00:05:13", "is_lecture": true, "end": "00:05:21", "is_worked_example": false, "text": "The PC+4 value for the interrupted instruction is routed through the WDSEL MUX to be written into the XP register."}, {"start": "00:05:21", "is_lecture": true, "end": "00:05:33", "is_worked_example": false, "text": "Meanwhile the control logic chooses either 3 or 4 as the value of PCSEL to select the appropriate next instruction that will initiate the handling the exception."}, {"start": "00:05:33", "is_lecture": true, "end": "00:05:45", "is_worked_example": false, "text": "The remaining control signals are forced to their \"don't care\" values, since we no longer care about completing execution of the instruction we had fetched from main memory at the beginning of the cycle."}, {"start": "00:05:45", "is_lecture": true, "end": "00:05:50", "is_worked_example": false, "text": "Note that the interrupted instruction has not been executed."}, {"start": "00:05:50", "is_lecture": true, "end": "00:06:04", "is_worked_example": false, "text": "So if the exception handler wishes to execute the interrupted instruction, it will have to subtract 4 from the value in the XP register before performing a JMP(XP) to resume execution of the interrupted program."}]}, "C03S01B10-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s1/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:09", "is_worked_example": false, "text": "Now let's turn our attention to the second class of instructions: load (LD) and store (ST), which allow the CPU to access values in memory."}, {"start": "00:00:09", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "Note that since the Beta is a load-store architecture these instructions are the *only* mechanism for accessing memory values."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "The LD and ST instructions use the same instruction template as the ALU-with-constant instructions."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "To access memory, we'll need a memory address, which is computed by adding the value of the \"ra\" register to the sign-extended 16-bit constant from the low-order 16 bits of the instruction."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "This computation is exactly the one performed by the ADDC instruction -- so we'll reuse that hardware -- and the sum is sent to main memory as the byte address of the location to be accessed."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "For the LD instruction, the data returned by main memory is written to the \"rc\" register."}, {"start": "00:00:53", "is_lecture": true, "end": "00:01:03", "is_worked_example": false, "text": "The store instruction (ST) performs the same address calculation as LD, then reads the data value from the \"rc\" register and sends both to main memory."}, {"start": "00:01:03", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "The ST instruction is special in several ways:"}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:15", "is_worked_example": false, "text": "it's the only instruction that needs to read the value of the \"rc\" register, so we'll need to adjust the datapath hardware slightly to accommodate that need."}, {"start": "00:01:15", "is_lecture": true, "end": "00:01:26", "is_worked_example": false, "text": "And since \"rc\" is serving as a source operand, it appears as the first operand in the symbolic form of the instruction, followed by \"const\" and \"ra\" which are specifying the destination address."}, {"start": "00:01:26", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "ST is the only instruction that does *not* write a result into the register file at end of the instruction."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:45", "is_worked_example": false, "text": "Here's the example we saw earlier, where we needed to load the value of the variable x from memory, multiply it by 37 and write the result back to the memory location that holds the value of the variable y."}, {"start": "00:01:45", "is_lecture": true, "end": "00:01:52", "is_worked_example": false, "text": "Now that we have actual Beta instructions, we've expressed the computation as a sequence of three instructions."}, {"start": "00:01:52", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "To access the value of variable x, the LD instruction adds the contents of R31 to the constant 0x1008, which sums to 0x1008, the address we need to access."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "The ST instruction specifies a similar address calculation to write into the location for the variable y."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "The address calculation performed by LD and ST works well when the locations we need to access have addresses that fit into the 16-bit constant field."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "What happens when we need to access locations at addresses higher than 0x7FFF?"}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:37", "is_worked_example": false, "text": "Then we need to treat those addresses as we would any large constant, and store those large addresses in main memory so they can be loaded into a register to be used by LD and ST."}, {"start": "00:02:37", "is_lecture": true, "end": "00:02:47", "is_worked_example": false, "text": "Okay, but what if the number of large constants we need to store is greater than will fit in low memory, i.e., the addresses we can access directly?"}, {"start": "00:02:47", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "To solve this problem, the Beta includes a \"load relative\" (LDR) instruction, which we'll see in the lecture on the Beta implementation."}]}, "C11S01B10-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "We can tweak the design of the DM cache a little to take advantage of locality and save some of the overhead of tag fields and valid bits."}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:15", "is_worked_example": false, "text": "We can increase the size of the data field in a cache from 1 word to 2 words, or 4 words, etc."}, {"start": "00:00:15", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "The number of data words in each cache line is called the \"block size\" and is always a power of two."}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "Using a larger block size makes sense."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:37", "is_worked_example": false, "text": "If there's a high probability of accessing nearby words, why not fetch a larger block of words on a cache miss, trading the increased cost of the miss against the increased probability of future hits."}, {"start": "00:00:37", "is_lecture": true, "end": "00:00:47", "is_worked_example": false, "text": "Compare the 16-word DM cache shown here with a block size of 4 with a different 16-word DM cache with a block size of 1."}, {"start": "00:00:47", "is_lecture": true, "end": "00:01:01", "is_worked_example": false, "text": "In this cache for every 128 bits of data there are 27 bits of tags and valid bit, so ~17% of the SRAM bits are overhead in the sense that they're not being used to store data."}, {"start": "00:01:01", "is_lecture": true, "end": "00:01:12", "is_worked_example": false, "text": "In the cache with block size 1, for every 32 bits of data there are 27 bits of tag and valid bit, so ~46% of the SRAM bits are overhead."}, {"start": "00:01:12", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "So a larger block size means we'll be using the SRAM more efficiently."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:24", "is_worked_example": false, "text": "Since there are 16 bytes of data in each cache line, there are now 4 offset bits."}, {"start": "00:01:24", "is_lecture": true, "end": "00:01:31", "is_worked_example": false, "text": "The cache uses the high-order two bits of the offset to select which of the 4 words to return to the CPU on a cache hit."}, {"start": "00:01:31", "is_lecture": true, "end": "00:01:38", "is_worked_example": false, "text": "There are 4 cache lines, so we'll need two cache line index bits from the incoming address."}, {"start": "00:01:38", "is_lecture": true, "end": "00:01:44", "is_worked_example": false, "text": "And, finally, the remaining 26 address bits are used as the tag field."}, {"start": "00:01:44", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "Note that there's only a single valid bit for each cache line, so either the entire 4-word block is present in the cache or it's not."}, {"start": "00:01:53", "is_lecture": true, "end": "00:01:58", "is_worked_example": false, "text": "Would it be worth the extra complication to support caching partial blocks?"}, {"start": "00:01:58", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "Probably not."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:07", "is_worked_example": false, "text": "Locality tells us that we'll probably want those other words in the near future, so having them in the cache will likely improve the hit ratio."}, {"start": "00:02:07", "is_lecture": true, "end": "00:02:11", "is_worked_example": false, "text": "What's the tradeoff between block size and performance?"}, {"start": "00:02:11", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "We've argued that increasing the block size from 1 was a good idea."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:18", "is_worked_example": false, "text": "Is there a limit to how large blocks should be?"}, {"start": "00:02:18", "is_lecture": true, "end": "00:02:22", "is_worked_example": false, "text": "Let's look at the costs and benefits of an increased block size."}, {"start": "00:02:22", "is_lecture": true, "end": "00:02:31", "is_worked_example": false, "text": "With a larger block size we have to fetch more words on a cache miss and the miss penalty grows linearly with increasing block size."}, {"start": "00:02:31", "is_lecture": true, "end": "00:02:40", "is_worked_example": false, "text": "Note that since the access time for the first word from DRAM is quite high, the increased miss penalty isn't as painful as it might be."}, {"start": "00:02:40", "is_lecture": true, "end": "00:02:51", "is_worked_example": false, "text": "Increasing the block size past 1 reduces the miss ratio since we're bringing words into the cache that will then be cache hits on subsequent accesses."}, {"start": "00:02:51", "is_lecture": true, "end": "00:03:00", "is_worked_example": false, "text": "Assuming we don't increase the overall cache capacity, increasing the block size means we'll make a corresponding reduction in the number of cache lines."}, {"start": "00:03:00", "is_lecture": true, "end": "00:03:07", "is_worked_example": false, "text": "Reducing the number of lines impacts the number of separate address blocks that can be accommodated in the cache."}, {"start": "00:03:07", "is_lecture": true, "end": "00:03:19", "is_worked_example": false, "text": "As we saw in the discussion on the size of the working set of a running program, there are a certain number of separate regions we need to accommodate to achieve a high hit ratio: program, stack, data, etc."}, {"start": "00:03:19", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "So we need to ensure there are a sufficient number of blocks to hold the different addresses in the working set."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "The bottom line is that there is an optimum block size that minimizes the miss ratio and increasing the block size past that point will be counterproductive."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:48", "is_worked_example": false, "text": "Combining the information in these two graphs, we can use the formula for AMAT to choose the block size the gives us the best possible AMAT."}, {"start": "00:03:48", "is_lecture": true, "end": "00:03:54", "is_worked_example": false, "text": "In modern processors, a common block size is 64 bytes (16 words)."}, {"start": "00:03:54", "is_lecture": true, "end": "00:03:58", "is_worked_example": false, "text": "DM caches do have an Achilles heel."}, {"start": "00:03:58", "is_lecture": true, "end": "00:04:15", "is_worked_example": false, "text": "Consider running the 3-instruction LOOPA code with the instructions located starting at word address 1024 and the data starting at word address 37 where the program is making alternating accesses to instruction and data, e.g., a loop of LD instructions."}, {"start": "00:04:15", "is_lecture": true, "end": "00:04:30", "is_worked_example": false, "text": "Assuming a 1024-line DM cache with a block size of 1, the steady state hit ratio will be 100% once all six locations have been loaded into the cache since each location is mapped to a different cache line."}, {"start": "00:04:30", "is_lecture": true, "end": "00:04:39", "is_worked_example": false, "text": "Now consider the execution of the same program, but this time the data has been relocated to start at word address 2048."}, {"start": "00:04:39", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "Now the instructions and data are competing for use of the same cache lines."}, {"start": "00:04:44", "is_lecture": true, "end": "00:04:57", "is_worked_example": false, "text": "For example, the first instruction (at address 1024) and the first data word (at address 2048) both map to cache line 0, so only one them can be in the cache at a time."}, {"start": "00:04:57", "is_lecture": true, "end": "00:05:12", "is_worked_example": false, "text": "So fetching the first instruction fills cache line 0 with the contents of location 1024, but then the first data access misses and then refills cache line 0 with the contents of location 2048."}, {"start": "00:05:12", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "The data address is said to \"conflict\" with the instruction address."}, {"start": "00:05:17", "is_lecture": true, "end": "00:05:24", "is_worked_example": false, "text": "The next time through the loop, the first instruction will no longer be in the cache and it's fetch will cause a cache miss, called a \"conflict miss\"."}, {"start": "00:05:24", "is_lecture": true, "end": "00:05:31", "is_worked_example": false, "text": "So in the steady state, the cache will never contain the word requested by the CPU."}, {"start": "00:05:31", "is_lecture": true, "end": "00:05:33", "is_worked_example": false, "text": "This is very unfortunate!"}, {"start": "00:05:33", "is_lecture": true, "end": "00:05:40", "is_worked_example": false, "text": "We were hoping to design a memory system that offered the simple abstraction of a flat, uniform address space."}, {"start": "00:05:40", "is_lecture": true, "end": "00:05:49", "is_worked_example": false, "text": "But in this example we see that simply changing a few addresses results in the cache hit ratio dropping from 100% to 0%."}, {"start": "00:05:49", "is_lecture": true, "end": "00:05:54", "is_worked_example": false, "text": "The programmer will certainly notice her program running 10 times slower!"}, {"start": "00:05:54", "is_lecture": true, "end": "00:06:04", "is_worked_example": false, "text": "So while we like the simplicity of DM caches, we'll need to make some architectural changes to avoid the performance problems caused by conflict misses."}]}, "C06S02B01-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c6/c6s2/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c6s2v1", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:08", "is_worked_example": true, "text": "In this problem, we will examine how compilers translate high level language descriptions into assembly language."}, {"start": "00:00:08", "is_lecture": false, "end": "00:00:17", "is_worked_example": true, "text": "We will be given several code fragments and asked to help the compiler in figuring out the dependencies of the program so that it produces valid code."}, {"start": "00:00:17", "is_lecture": false, "end": "00:00:24", "is_worked_example": true, "text": "Let's begin with the code fragment: a = b + 3*c."}, {"start": "00:00:24", "is_lecture": false, "end": "00:00:29", "is_worked_example": true, "text": "We can assume that our variables: a, b, and c are stored in memory."}, {"start": "00:00:29", "is_lecture": false, "end": "00:00:34", "is_worked_example": true, "text": "We can also assume that registers may be used to store intermediate results."}, {"start": "00:00:34", "is_lecture": false, "end": "00:00:42", "is_worked_example": true, "text": "Given the following partially completed assembly code, let's determine the missing values that the compiler would have had to determine."}, {"start": "00:00:42", "is_lecture": false, "end": "00:00:46", "is_worked_example": true, "text": "We begin with XXX which is the first instruction."}, {"start": "00:00:46", "is_lecture": false, "end": "00:00:51", "is_worked_example": true, "text": "The first instruction is trying to put the value of c into register R1."}, {"start": "00:00:51", "is_lecture": false, "end": "00:01:00", "is_worked_example": true, "text": "Since c comes from memory, that means that instruction XXX must be a LD operation where c is the address of the variable to be loaded."}, {"start": "00:01:00", "is_lecture": false, "end": "00:01:13", "is_worked_example": true, "text": "Note that LD(c, R1) is actually a macro instruction that is equal to LD(R31, c, R1)."}, {"start": "00:01:13", "is_lecture": false, "end": "00:01:25", "is_worked_example": true, "text": "The load operation would add the constant c to the value of register R31, which is always 0, thus ending up with the address c as the source address of the load operation."}, {"start": "00:01:25", "is_lecture": false, "end": "00:01:30", "is_worked_example": true, "text": "R1 is a temporary register that will hold the value of variable c."}, {"start": "00:01:30", "is_lecture": false, "end": "00:01:34", "is_worked_example": true, "text": "Next, we need to multiply c by 3."}, {"start": "00:01:34", "is_lecture": false, "end": "00:01:46", "is_worked_example": true, "text": "Multiply operations are generally very expensive, so it is the compilers job to figure out that this operation could potentially be achieved by 2 simpler and faster operations."}, {"start": "00:01:46", "is_lecture": false, "end": "00:01:53", "is_worked_example": true, "text": "The comment tells us that it first tries to compute 2 * c and store that result into R0."}, {"start": "00:01:53", "is_lecture": false, "end": "00:02:06", "is_worked_example": true, "text": "Since R1 = c, and the constant in this operation is a 1, we need to realize that the inexpensive operation that the compiler would use for this is a logical shift to the left by one position."}, {"start": "00:02:06", "is_lecture": false, "end": "00:02:12", "is_worked_example": true, "text": "In binary, this produces the same result as multiplying a number by 2."}, {"start": "00:02:12", "is_lecture": false, "end": "00:02:16", "is_worked_example": true, "text": "So YYY = SHLC."}, {"start": "00:02:16", "is_lecture": false, "end": "00:02:29", "is_worked_example": true, "text": "Note that we use the constant version of the SHL operation since the amount to shift is given by a constant in our instruction rather than being read from another register."}, {"start": "00:02:29", "is_lecture": false, "end": "00:02:41", "is_worked_example": true, "text": "The next instruction is provided for us and it adds R0 which equals 2*c to R1 which equals c in order to produce 3*c."}, {"start": "00:02:41", "is_lecture": false, "end": "00:02:45", "is_worked_example": true, "text": "This intermediate result is then stored back into R0."}, {"start": "00:02:45", "is_lecture": false, "end": "00:02:50", "is_worked_example": true, "text": "Next we want to once again get the value of a variable from memory."}, {"start": "00:02:50", "is_lecture": false, "end": "00:02:58", "is_worked_example": true, "text": "As we saw before, XXX = LD in order to load the contents of address b into register R1."}, {"start": "00:02:58", "is_lecture": false, "end": "00:03:10", "is_worked_example": true, "text": "We are almost done, we now just need to add R1 = b to R0 = 3*c and then store the result back into memory variable a."}, {"start": "00:03:10", "is_lecture": false, "end": "00:03:21", "is_worked_example": true, "text": "Since the store instruction is using R0 as its source, that means that ZZZ must also be R0 so that the correct value ends up in variable a."}, {"start": "00:03:21", "is_lecture": false, "end": "00:03:28", "is_worked_example": true, "text": "Next, we will take a look at how a conditional statement would be compiled into assembly language."}, {"start": "00:03:28", "is_lecture": false, "end": "00:03:35", "is_worked_example": true, "text": "The statement says that if a is greater than b then c should be assigned the value 17."}, {"start": "00:03:35", "is_lecture": false, "end": "00:03:42", "is_worked_example": true, "text": "Once again we are given the semi-complete translation of the high level language code into beta assembly."}, {"start": "00:03:42", "is_lecture": false, "end": "00:03:51", "is_worked_example": true, "text": "For this example, we first load the values of our variables a and b into temporary registers R0 and R1."}, {"start": "00:03:51", "is_lecture": false, "end": "00:03:58", "is_worked_example": true, "text": "Now we want to check if a is greater than b and if so set c = 17."}, {"start": "00:03:58", "is_lecture": false, "end": "00:04:03", "is_worked_example": true, "text": "We know that XXX must be some kind of beta comparison operation."}, {"start": "00:04:03", "is_lecture": false, "end": "00:04:15", "is_worked_example": true, "text": "However, the beta does not provide a compare greater than operation, so instead we need to make use of the compare less than (CMPLT) or compare less than or equal (CMPLE) operations."}, {"start": "00:04:15", "is_lecture": false, "end": "00:04:27", "is_worked_example": true, "text": "Since we see that the store into label c is skipped when the code branches to label _L2, we want to make sure that the branch is not taken when a is greater than b."}, {"start": "00:04:27", "is_lecture": false, "end": "00:04:32", "is_worked_example": true, "text": "This is equivalent to the branch being taken when a is less than or equal to b."}, {"start": "00:04:32", "is_lecture": false, "end": "00:04:48", "is_worked_example": true, "text": "So if we make XXX = CMPLE of R0, which equals a, and R1, which equals b, then the result stored into R0 will be 1 if a <= b."}, {"start": "00:04:48", "is_lecture": false, "end": "00:05:00", "is_worked_example": true, "text": "We then set YYY to R0 to ensure that we take the branch when a <= b and we make the assignment to c when a > b."}, {"start": "00:05:00", "is_lecture": false, "end": "00:05:15", "is_worked_example": true, "text": "Finally, if we set ZZZ = 17, then when the branch is not taken, we will move 17 into R0 and then store that value into the location pointed to by address c."}, {"start": "00:05:15", "is_lecture": false, "end": "00:05:22", "is_worked_example": true, "text": "So the complete translation of this conditional statement to beta assembly is shown here."}, {"start": "00:05:22", "is_lecture": false, "end": "00:05:32", "is_worked_example": true, "text": "For this next code segment, we are going to take a look at how a compiler would convert array accesses into beta code."}, {"start": "00:05:32", "is_lecture": false, "end": "00:05:42", "is_worked_example": true, "text": "Once again we are given partially completed assembly code to help us understand how the compiler translates this high level code into beta assembly."}, {"start": "00:05:42", "is_lecture": false, "end": "00:05:48", "is_worked_example": true, "text": "We begin with a load of the value stored at location i into register R0."}, {"start": "00:05:48", "is_lecture": false, "end": "00:05:51", "is_worked_example": true, "text": "I is the index into our array."}, {"start": "00:05:51", "is_lecture": false, "end": "00:06:00", "is_worked_example": true, "text": "However, since the beta is byte addressed, but it deals with 32 bit values, that means that each array element requires 4 bytes of storage."}, {"start": "00:06:00", "is_lecture": false, "end": "00:06:06", "is_worked_example": true, "text": "So in order to point to the correct location in memory, we need to multiply i by 4."}, {"start": "00:06:06", "is_lecture": false, "end": "00:06:19", "is_worked_example": true, "text": "As we saw earlier, shifting to the left by 1 bit is equivalent to multiplying by 2, so here we shift to the left by 2 bits in order to multiply by 4."}, {"start": "00:06:19", "is_lecture": false, "end": "00:06:22", "is_worked_example": true, "text": "So XXX = 2."}, {"start": "00:06:22", "is_lecture": false, "end": "00:06:35", "is_worked_example": true, "text": "Now that R0 = 4 * i, in order to load a[i], we would load the location a + 4*i."}, {"start": "00:06:35", "is_lecture": false, "end": "00:06:47", "is_worked_example": true, "text": "In order to load a[i-1], we need to load the location that is 4 bytes before that, so location a + 4*i -- 4."}, {"start": "00:06:47", "is_lecture": false, "end": "00:06:58", "is_worked_example": true, "text": "This means that in this load operation which actually wants to load a[i-1], we need to set YYY = a-4."}, {"start": "00:06:58", "is_lecture": false, "end": "00:07:06", "is_worked_example": true, "text": "So this load operation places array element a[i-1] into R1."}, {"start": "00:07:06", "is_lecture": false, "end": "00:07:18", "is_worked_example": true, "text": "Now we want to store the contents of R1 into array element a[i] which is located at address a + 4*i."}, {"start": "00:07:18", "is_lecture": false, "end": "00:07:26", "is_worked_example": true, "text": "Since R0 already equals 4*i, then adding a to R0 will give us the desired destination address of our store."}, {"start": "00:07:26", "is_lecture": false, "end": "00:07:35", "is_worked_example": true, "text": "This means that we just need to set ZZZ to R1 since that is the value that we want to store into a[i]."}, {"start": "00:07:35", "is_lecture": false, "end": "00:07:40", "is_worked_example": true, "text": "Let's take a look at one last example."}, {"start": "00:07:40", "is_lecture": false, "end": "00:07:52", "is_worked_example": true, "text": "Here we have a variable sum that is initialized to 0, followed by a loop that increments the value of sum by i for every value of i between 0 and 9."}, {"start": "00:07:52", "is_lecture": false, "end": "00:07:58", "is_worked_example": true, "text": "Our partial mostly completed compiled code is shown here."}, {"start": "00:07:58", "is_lecture": false, "end": "00:08:04", "is_worked_example": true, "text": "The first thing that the compiler does, is it initializes the two variables sum and i to 0."}, {"start": "00:08:04", "is_lecture": false, "end": "00:08:14", "is_worked_example": true, "text": "This is done by storing the value of register R31, which is always 0 in the beta, into the locations pointed to by sum and by i."}, {"start": "00:08:14", "is_lecture": false, "end": "00:08:19", "is_worked_example": true, "text": "_L7 is a label that indicates the beginning of our loop."}, {"start": "00:08:19", "is_lecture": false, "end": "00:08:26", "is_worked_example": true, "text": "The first thing that needs to happen in the loop is to load the current values of sum and i from memory."}, {"start": "00:08:26", "is_lecture": false, "end": "00:08:29", "is_worked_example": true, "text": "Next, sum should be incremented by i."}, {"start": "00:08:29", "is_lecture": false, "end": "00:08:38", "is_worked_example": true, "text": "Since R0 is stored back into sum, we want XXX = R0 to be the destination register of the ADD."}, {"start": "00:08:38", "is_lecture": false, "end": "00:08:41", "is_worked_example": true, "text": "Now the loop index needs to be incremented."}, {"start": "00:08:41", "is_lecture": false, "end": "00:08:50", "is_worked_example": true, "text": "Since R1 = i, that means that we want to increment R1 by 1,so YYY = R1."}, {"start": "00:08:50", "is_lecture": false, "end": "00:08:56", "is_worked_example": true, "text": "Finally, we need to determine whether the loop needs to be repeated or we are done."}, {"start": "00:08:56", "is_lecture": false, "end": "00:09:00", "is_worked_example": true, "text": "This is done by checking whether i is less than 10."}, {"start": "00:09:00", "is_lecture": false, "end": "00:09:04", "is_worked_example": true, "text": "The beta provides the CMPLTC operation to do just that."}, {"start": "00:09:04", "is_lecture": false, "end": "00:09:13", "is_worked_example": true, "text": "Since R1 holds the latest value of i, comparing R1 to the constant 10 will produce the result we want in R0."}, {"start": "00:09:13", "is_lecture": false, "end": "00:09:17", "is_worked_example": true, "text": "So ZZZ = 10."}, {"start": "00:09:17", "is_lecture": false, "end": "00:09:24", "is_worked_example": true, "text": "If the comparison was true, then we need to repeat the loop so we branch back to _L7."}, {"start": "00:09:24", "is_lecture": false, "end": "00:09:29", "is_worked_example": true, "text": "If not, we proceed to the instruction after the branch."}]}, "C03S01B06-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s1/6?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s1v6", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:07", "is_worked_example": false, "text": "Having talked about the storage resources provided by the Beta ISA, let's design the Beta instructions themselves."}, {"start": "00:00:07", "is_lecture": true, "end": "00:00:15", "is_worked_example": false, "text": "This might be a good time to print a copy of the handout called the \"Summary of Beta Instruction Formats\" so you'll have it for handy reference."}, {"start": "00:00:15", "is_lecture": true, "end": "00:00:32", "is_worked_example": false, "text": "The Beta has three types of instructions: compute instructions that perform arithmetic and logic operations on register values, load and store instructions that access values in main memory, and branch instructions that change the value of the program counter."}, {"start": "00:00:32", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "We'll discuss each class of instructions in turn."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "In the Beta ISA, all the instruction encodings are the same size: each instruction is encoded in 32 bits and hence occupies exactly one 32-bit word in main memory."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "This instruction encoding leads to simpler control-unit logic for decoding instructions."}, {"start": "00:00:53", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "And computing the next value of the program counter is very simple:"}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "for most instructions, the next instruction can be found in the following memory location."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:08", "is_worked_example": false, "text": "We just need to add 4 to the current value of program counter to advance to the next instruction."}, {"start": "00:01:08", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "As we saw in Part 1 of the course, fixed-length encodings are often inefficient in the sense that the same information content (in this case, the encoded program) can be encoded using fewer bits."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:28", "is_worked_example": false, "text": "To do better we would need a variable-length encoding for instructions, where frequently-occurring instructions would use a shorter encoding."}, {"start": "00:01:28", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "But hardware to decode variable-length instructions is complex since there may be several instructions packed into one memory word, while other instructions might require loading several memory words."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "The details can be worked out, but there's a performance and energy cost associated with the more efficient encoding."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "Nowadays, advances in memory technology have made memory size less of an issue and the focus is on the higher-performance needed by today's applications."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:05", "is_worked_example": false, "text": "Our choice of a fixed-length encoding leads to larger code size, but keeps the hardware execution engine small and fast."}, {"start": "00:02:05", "is_lecture": true, "end": "00:02:11", "is_worked_example": false, "text": "The computation performed by the Beta datapath happens in the arithmetic-and-logic unit (ALU)."}, {"start": "00:02:11", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "We'll be using the ALU designed in Part 1 of the course."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "The Beta ALU instructions have 4 instruction fields."}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "There's a 6-bit field specifying the ALU operation to be performed -- this field is called the opcode."}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "The two source operands come from registers whose numbers are specified by the 5-bit \"ra\" and \"rb\" fields."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:38", "is_worked_example": false, "text": "So we can specify any register from R0 to R31 as a source operand."}, {"start": "00:02:38", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "The destination register is specified by the 5-bit \"rc\" field."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "This instruction format uses 21 bits of the 32-bit word, the remaining bits are unused and should be set to 0."}, {"start": "00:02:50", "is_lecture": true, "end": "00:02:54", "is_worked_example": false, "text": "The diagram shows how the fields are positioned in the 32-bit word."}, {"start": "00:02:54", "is_lecture": true, "end": "00:03:06", "is_worked_example": false, "text": "The choice of position for each field is somewhat arbitrary, but to keep the hardware simple, when we can we'll want to use the same field positions for similar fields in the other instruction encodings."}, {"start": "00:03:06", "is_lecture": true, "end": "00:03:12", "is_worked_example": false, "text": "For example, the opcode will always be found in bits [31:26] of the instruction."}, {"start": "00:03:12", "is_lecture": true, "end": "00:03:16", "is_worked_example": false, "text": "Here's the binary encoding of an ADD instruction."}, {"start": "00:03:16", "is_lecture": true, "end": "00:03:28", "is_worked_example": false, "text": "The opcode for ADD is the 6-bit binary value 0b100000 -- you can find the binary for each opcode in the Opcode Table in the handout mentioned before."}, {"start": "00:03:28", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "The \"rc\" field specifies that the result of the ADD will be written into R3."}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "And the \"ra\" and \"rb\" fields specify that the first and second source operands are R1 and R2 respectively."}, {"start": "00:03:41", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "So this instruction adds the 32-bit values found in R1 and R2, writing the 32-bit sum into R3."}, {"start": "00:03:49", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "Note that it's permissible to refer to a particular register several times in the same instruction."}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:03", "is_worked_example": false, "text": "So, for example, we could specify R1 as the register for both source operands AND also as the destination register."}, {"start": "00:04:03", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "If we did, we'd be adding R1 to R1 and writing the result back into R1, which would effectively multiply the value in R1 by 2."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:24", "is_worked_example": false, "text": "Since it's tedious and error-prone to transcribe 32-bit binary values, we'll often use hexadecimal notation for the binary representation of an instruction."}, {"start": "00:04:24", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "In this example, the hexadecimal notation for the encoded instruction is 0x80611000."}, {"start": "00:04:33", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "However, it's *much* easier if we describe the instructions using a functional notation, e.g., \"ADD(r1,r2,r3)\"."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:47", "is_worked_example": false, "text": "Here we use a symbolic name for each operation, called a mnemonic."}, {"start": "00:04:47", "is_lecture": true, "end": "00:04:48", "is_worked_example": false, "text": "For this instruction the mnemonic is \"ADD\", followed by a parenthesized list of operands, in this case the two source operands (r1 and r2), then the destination (r3)."}, {"start": "00:04:48", "is_lecture": true, "end": "00:05:11", "is_worked_example": false, "text": "So we'll understand that ADD(ra,rb,rc) is shorthand for asking the Beta to compute the sum of the values in registers ra and rb, writing the result as the new value of register rc."}, {"start": "00:05:11", "is_lecture": true, "end": "00:05:16", "is_worked_example": false, "text": "Here's the list of the mnemonics for all the operations supported by the Beta."}, {"start": "00:05:16", "is_lecture": true, "end": "00:05:22", "is_worked_example": false, "text": "There is a detailed description of what each instruction does in the Beta Documentation handout."}, {"start": "00:05:22", "is_lecture": true, "end": "00:05:28", "is_worked_example": false, "text": "Note that all these instructions use same 4-field template, differing only in the value of the opcode field."}, {"start": "00:05:28", "is_lecture": true, "end": "00:05:36", "is_worked_example": false, "text": "This first step was pretty straightforward -- we simply provided instruction encodings for the basic operations provided by the ALU."}, {"start": "00:05:36", "is_lecture": true, "end": "00:05:43", "is_worked_example": false, "text": "Now that we have our first group of instructions, we can create a more concrete implementation sketch."}, {"start": "00:05:43", "is_lecture": true, "end": "00:05:45", "is_worked_example": false, "text": "Here we see our proposed datapath."}, {"start": "00:05:45", "is_lecture": true, "end": "00:05:53", "is_worked_example": false, "text": "The 5-bit \"ra\" and \"rb\" fields from the instruction are used to select which of the 32 registers will be used for the two operands."}, {"start": "00:05:53", "is_lecture": true, "end": "00:06:06", "is_worked_example": false, "text": "Note that register 31 isn't actually a read/write register, it's just the 32-bit constant 0, so that selecting R31 as an operand results in using the value 0."}, {"start": "00:06:06", "is_lecture": true, "end": "00:06:12", "is_worked_example": false, "text": "The 5-bit \"rc\" field from the instruction selects which register will be written with the result from the ALU."}, {"start": "00:06:12", "is_lecture": true, "end": "00:06:25", "is_worked_example": false, "text": "Not shown is the hardware needed to translate the instruction opcode to the appropriate ALU function code -- perhaps a 64-location ROM could be used to perform the translation by table lookup."}, {"start": "00:06:25", "is_lecture": true, "end": "00:06:30", "is_worked_example": false, "text": "The program counter logic supports simple sequential execution of instructions."}, {"start": "00:06:30", "is_lecture": true, "end": "00:06:36", "is_worked_example": false, "text": "It's a 32-bit register whose value is updated at the end of each instruction by adding 4 to its current value."}, {"start": "00:06:36", "is_lecture": true, "end": "00:06:42", "is_worked_example": false, "text": "This means the next instruction will come from the memory location following the one that holds the current instruction."}, {"start": "00:06:42", "is_lecture": true, "end": "00:06:47", "is_worked_example": false, "text": "In this diagram we see one of the benefits of a RISC architecture:"}, {"start": "00:06:47", "is_lecture": true, "end": "00:06:52", "is_worked_example": false, "text": "there's not much logic needed to decode the instruction to produce the signals needed to control the datapath."}, {"start": "00:06:52", "is_lecture": true, "end": "00:06:57", "is_worked_example": false, "text": "In fact, many of the instruction fields are used as-is!"}]}, "C03S01B08-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s1/8?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s1v8", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:10", "is_worked_example": false, "text": "ISA designers receive many requests for what are affectionately known as \"features\" -- additional instructions that, in theory, will make the ISA better in some way."}, {"start": "00:00:10", "is_lecture": true, "end": "00:00:19", "is_worked_example": false, "text": "Dealing with such requests is the moment to apply our quantitive approach in order to be able to judge the tradeoffs between cost and benefits."}, {"start": "00:00:19", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "Our first \"feature request\" is to allow small constants as the second operand in ALU instructions."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:36", "is_worked_example": false, "text": "So if we replaced the 5-bit \"rb\" field, we would have room in the instruction to include a 16-bit constant as bits [15:0] of the instruction."}, {"start": "00:00:36", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "The argument in favor of this request is that small constants appear frequently in many programs and it would make programs shorter if we didn't have use load operations to read constant values from main memory."}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "The argument against the request is that we would need additional control and datapath logic to implement the feature, increasing the hardware cost and probably decreasing the performance."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:08", "is_worked_example": false, "text": "So our strategy is to modify our benchmark programs to use the ISA augmented with this feature and measure the impact on a simulated execution."}, {"start": "00:01:08", "is_lecture": true, "end": "00:01:19", "is_worked_example": false, "text": "Looking at the results, we find that there is compelling evidence that small constants are indeed very common as the second operands to many operations."}, {"start": "00:01:19", "is_lecture": true, "end": "00:01:22", "is_worked_example": false, "text": "Note that we're not so much interested in simply looking at the code."}, {"start": "00:01:22", "is_lecture": true, "end": "00:01:28", "is_worked_example": false, "text": "Instead we want to look at what instructions actually get executed while running the benchmark programs."}, {"start": "00:01:28", "is_lecture": true, "end": "00:01:38", "is_worked_example": false, "text": "This will take into account that instructions executed during each iteration of a loop might get executed 1000's of times even though they only appear in the program once."}, {"start": "00:01:38", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "Looking at the results, we see that over half of the arithmetic instructions have a small constant as their second operand."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "Comparisons involve small constants 80% of the time."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "This probably reflects the fact that during execution comparisons are used in determining whether we've reached the end of a loop."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:02", "is_worked_example": false, "text": "And small constants are often found in address calculations done by load and store operations."}, {"start": "00:02:02", "is_lecture": true, "end": "00:02:09", "is_worked_example": false, "text": "Operations involving constant operands are clearly a common case, one well worth optimizing."}, {"start": "00:02:09", "is_lecture": true, "end": "00:02:17", "is_worked_example": false, "text": "Adding support for small constant operands to the ISA resulted in programs that were measurably smaller and faster."}, {"start": "00:02:17", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "So: feature request approved!"}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "Here we see the second of the two Beta instruction formats."}, {"start": "00:02:24", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "It's a modification of the first format where we've replaced the 5-bit \"rb\" field with a 16-bit field holding a constant in two's complement format."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:49", "is_worked_example": false, "text": "This will allow us to represent constant operands in the range of 0x8000 (decimal -32768) to 0x7FFF (decimal 32767)."}, {"start": "00:02:49", "is_lecture": true, "end": "00:03:00", "is_worked_example": false, "text": "Here's an example of the add-constant (ADDC) instruction which adds the contents of R1 and the constant -3, writing the result into R3."}, {"start": "00:03:00", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "We can see that the second operand in the symbolic representation is now a constant (or, more generally, an expression that can evaluated to get a constant value)."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:20", "is_worked_example": false, "text": "One technical detail needs discussion: the instruction contains a 16-bit constant, but the datapath requires a 32-bit operand."}, {"start": "00:03:20", "is_lecture": true, "end": "00:03:29", "is_worked_example": false, "text": "How does the datapath hardware go about converting from, say, the 16-bit representation of -3 to the 32-bit representation of -3?"}, {"start": "00:03:29", "is_lecture": true, "end": "00:03:47", "is_worked_example": false, "text": "Comparing the 16-bit and 32-bit representations for various constants, we see that if the 16-bit two's-complement constant is negative (i.e., its high-order bit is 1), the high sixteen bits of the equivalent 32-bit constant are all 1's."}, {"start": "00:03:47", "is_lecture": true, "end": "00:03:57", "is_worked_example": false, "text": "And if the 16-bit constant is non-negative (i.e., its high-order bit is 0), the high sixteen bits of the 32-bit constant are all 0's."}, {"start": "00:03:57", "is_lecture": true, "end": "00:04:09", "is_worked_example": false, "text": "Thus the operation the hardware needs to perform is \"sign extension\" where the sign-bit of the 16-bit constant is replicated sixteen times to form the high half of the 32-bit constant."}, {"start": "00:04:09", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "The low half of the 32-bit constant is simply the 16-bit constant from the instruction."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:21", "is_worked_example": false, "text": "No additional logic gates will be needed to implement sign extension -- we can do it all with wiring."}, {"start": "00:04:21", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "Here are the fourteen ALU instructions in their \"with constant\" form, showing the same instruction mnemonics but with a \"C\" suffix indicate the second operand is a constant."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:39", "is_worked_example": false, "text": "Since these are additional instructions, these have different opcodes than the original ALU instructions."}, {"start": "00:04:39", "is_lecture": true, "end": "00:04:53", "is_worked_example": false, "text": "Finally, note that if we need a constant operand whose representation does NOT fit into 16 bits, then we have to store the constant as a 32-bit value in a main memory location and load it into a register for use just like we would any variable value."}, {"start": "00:04:53", "is_lecture": true, "end": "00:05:03", "is_worked_example": false, "text": "To give some sense for the additional datapath hardware that will be needed, let's update our implementation sketch to add support for constants as the second ALU operand."}, {"start": "00:05:03", "is_lecture": true, "end": "00:05:05", "is_worked_example": false, "text": "We don't have to add much hardware:"}, {"start": "00:05:05", "is_lecture": true, "end": "00:05:13", "is_worked_example": false, "text": "just a multiplexer which selects either the \"rb\" register value or the sign-extended constant from the 16-bit field in the instruction."}, {"start": "00:05:13", "is_lecture": true, "end": "00:05:22", "is_worked_example": false, "text": "The BSEL control signal that controls the multiplexer is 1 for the ALU-with-constant instructions and 0 for the regular ALU instructions."}, {"start": "00:05:22", "is_lecture": true, "end": "00:05:29", "is_worked_example": false, "text": "We'll put the hardware implementation details aside for now and revisit them in a few lectures."}]}, "C09S01B08-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c9/c9s1/8?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c9s1v8", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:01", "is_worked_example": false, "text": "Okay, we're done!"}, {"start": "00:00:01", "is_lecture": true, "end": "00:00:07", "is_worked_example": false, "text": "Here's the final datapath for executing instructions and handling exceptions."}, {"start": "00:00:07", "is_lecture": true, "end": "00:00:14", "is_worked_example": false, "text": "Please take a moment to remind yourself of what each datapath component does, i.e., why it was added to the datapath."}, {"start": "00:00:14", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "Similarly, you should understand how the control signals affect the operation of the datapath."}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "At least to my eye, this seems like a very modest amount of hardware to achieve all this functionality!"}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:34", "is_worked_example": false, "text": "It's so modest in fact, that will ask you to actually complete the logic design for the Beta in an upcoming lab assignment :)"}, {"start": "00:00:34", "is_lecture": true, "end": "00:00:40", "is_worked_example": false, "text": "How does our design compare to the processor you're using to view this course online?"}, {"start": "00:00:40", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "Modern processors have many additional complexities to increase performance:"}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:56", "is_worked_example": false, "text": "pipelined execution, the ability to execute more than instruction per cycle, fancier memory systems to reduce average memory access time, etc."}, {"start": "00:00:56", "is_lecture": true, "end": "00:01:00", "is_worked_example": false, "text": "We'll cover some of these enhancements in upcoming lectures."}, {"start": "00:01:00", "is_lecture": true, "end": "00:01:14", "is_worked_example": false, "text": "The bottom line: the Beta hardware might occupy 1 or 2 sq mm on a modern integrated circuit, while a modern Intel processor occupies 300 to 600 sq mm."}, {"start": "00:01:14", "is_lecture": true, "end": "00:01:18", "is_worked_example": false, "text": "Clearly all that extra circuitry is there for a reason!"}, {"start": "00:01:18", "is_lecture": true, "end": "00:01:23", "is_worked_example": false, "text": "If you're curious, I'd recommend taking a course on advanced processor architecture."}, {"start": "00:01:23", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "Here we've gathered up all the control signal settings for each class of instructions, including the settings needed for exceptions and during reset."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "Wherever possible, we've specified \"don't care\" for control signals whose value does not affect the actions of the datapath needed for a particular instruction."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:52", "is_worked_example": false, "text": "Note that the memory write enable signal always has a defined value, ensuring that we only write to the memory during ST instructions."}, {"start": "00:01:52", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "Similarly, the write enable for the register file is well-defined, except during RESET when presumably we're restarting the processor and don't care about preserving any register values."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:16", "is_worked_example": false, "text": "As mentioned previously, a read-only memory (ROM) indexed by the 6-bit opcode field is the easiest way to generate the appropriate control signals for the current instruction."}, {"start": "00:02:16", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "The Z and IRQ inputs to the control logic will affect the control signals and this can be accomplished with a small amount of logic to process the ROM outputs."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:34", "is_worked_example": false, "text": "One can always have fun with Karnuagh maps to generate a minimal implementation using ordinary logic gates."}, {"start": "00:02:34", "is_lecture": true, "end": "00:02:41", "is_worked_example": false, "text": "The result will be much smaller, both in terms of size and propagation delay, but requires a lot more design work!"}, {"start": "00:02:41", "is_lecture": true, "end": "00:02:47", "is_worked_example": false, "text": "My recommendation: start with the ROM implementation and get everything else working."}, {"start": "00:02:47", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "Then come back later when you feel like hacking logic gates :)"}, {"start": "00:02:50", "is_lecture": true, "end": "00:02:57", "is_worked_example": false, "text": "So that's what it takes to design the hardware for a simple 32-bit computer."}, {"start": "00:02:57", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "Of course, we made the job easy for ourselves by choosing a simple binary encoding for our instructions and limiting the hardware functionality to efficiently executing the most common operations."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "Less common and more complex functionality can be left to software."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "The exception mechanism gave us a powerful tool for transferring control to software when the hardware couldn't handle the task."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "Have fun completing the hardware design of your Beta."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:32", "is_worked_example": false, "text": "Thousands of MIT students have enjoyed that \"Yes!\" moment when their design works for the first time."}, {"start": "00:03:32", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "For their efforts we reward them with the \"Beta Inside\" sticker you see here, which you can see on laptops as you walk around the Institute."}, {"start": "00:03:41", "is_lecture": true, "end": "00:03:42", "is_worked_example": false, "text": "Good luck!"}]}, "C07S01B01-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c7/c7s1/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c7s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:09", "is_worked_example": false, "text": "One of the most useful abstractions provided by high-level languages is the notion of a procedure or subroutine, which is a sequence of instructions that perform a specific task."}, {"start": "00:00:09", "is_lecture": true, "end": "00:00:16", "is_worked_example": false, "text": "A procedure has a single named entry point, which can be used to refer to the procedure in other parts of the program."}, {"start": "00:00:16", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "In the example here, this code is defining the GCD procedure, which is declared to return an integer value."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "Procedures have zero or more formal parameters, which are the names the code inside the procedure will use to refer the values supplied when the procedure is invoked by a \"procedure call\"."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "A procedure call is an expression that has the name of the procedure followed by parenthesized list of values called \"arguments\" that will be matched up with the formal parameters."}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "For example, the value of the first argument will become the value of the first formal parameter while the procedure is executing."}, {"start": "00:00:53", "is_lecture": true, "end": "00:01:01", "is_worked_example": false, "text": "The body of the procedure may define additional variables, called \"local variables\", since they can only be accessed by statements in the procedure body."}, {"start": "00:01:01", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "Conceptually, the storage for local variables only exists while the procedure is executing."}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:12", "is_worked_example": false, "text": "They are allocated when the procedure is invoked and deallocated when the procedure returns."}, {"start": "00:01:12", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "The procedure may return a value that's the result of the procedure's computation."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:27", "is_worked_example": false, "text": "It's legal to have procedures that do not return a value, in which case the procedures would only be executed for their \"side effects\", e.g., changes they make to shared data."}, {"start": "00:01:27", "is_lecture": true, "end": "00:01:34", "is_worked_example": false, "text": "Here we see another procedure, COPRIMES, that invokes the GCD procedure to compute the greatest common divisor of two numbers."}, {"start": "00:01:34", "is_lecture": true, "end": "00:01:47", "is_worked_example": false, "text": "To use GCD, the programmer of COPRIMES only needed to know the input/output behavior of GCD, i.e., the number and types of the arguments and what type of value is returned as a result."}, {"start": "00:01:47", "is_lecture": true, "end": "00:01:55", "is_worked_example": false, "text": "The procedural abstraction has hidden the implementation of GCD, while still making its functionality available as a \"black box\"."}, {"start": "00:01:55", "is_lecture": true, "end": "00:02:02", "is_worked_example": false, "text": "This is a very powerful idea: encapsulating a complex computation so that it can be used by others."}, {"start": "00:02:02", "is_lecture": true, "end": "00:02:13", "is_worked_example": false, "text": "Every high-level language comes with a collection of pre-built procedures, called \"libraries\", which can be used to perform arithmetic functions (e.g., square root or cosine),"}, {"start": "00:02:13", "is_lecture": true, "end": "00:02:23", "is_worked_example": false, "text": "manipulate collections of data (e.g., lists or dictionaries), read data from files, and so on -- the list is nearly endless!"}, {"start": "00:02:23", "is_lecture": true, "end": "00:02:31", "is_worked_example": false, "text": "Much of the expressive power and ease-of-use provided by high-level languages comes from their libraries of \"black boxes\"."}, {"start": "00:02:31", "is_lecture": true, "end": "00:02:44", "is_worked_example": false, "text": "The procedural abstraction is at the heart of object-oriented languages, which encapsulate data and procedures as black boxes called objects that support specific operations on their internal data."}, {"start": "00:02:44", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "For example, a LIST object has procedures (called \"methods\" in this context) for indexing into the list to read or change a value, adding new elements to the list, inquiring about the length of the list, and so on."}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "The internal representation of the data and the algorithms used to implement the methods are hidden by the object abstraction."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "Indeed, there may be several different LIST implementations to choose from depending on which operations you need to be particularly efficient."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:18", "is_worked_example": false, "text": "Okay, enough about the virtues of the procedural abstraction!"}, {"start": "00:03:18", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "Let's turn our attention to how to implement procedures using the Beta ISA."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "A possible implementation is to \"inline\" the procedure, where we replace the procedure call with a copy of the statements in the procedure's body, substituting argument values for references to the formal parameters."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:45", "is_worked_example": false, "text": "In this approach we're treating procedures very much like UASM macros, i.e., a simple notational shorthand for making a copy of the procedure's body."}, {"start": "00:03:45", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "Are there any problems with this approach?"}, {"start": "00:03:49", "is_lecture": true, "end": "00:03:53", "is_worked_example": false, "text": "One obvious issue is the potential increase in the code size."}, {"start": "00:03:53", "is_lecture": true, "end": "00:04:00", "is_worked_example": false, "text": "For example, if we had a lengthy procedure that was called many times, the final expanded code would be huge!"}, {"start": "00:04:00", "is_lecture": true, "end": "00:04:10", "is_worked_example": false, "text": "Enough so that inlining isn't a practical solution except in the case of short procedures where optimizing compilers do sometimes decide to inline the code."}, {"start": "00:04:10", "is_lecture": true, "end": "00:04:19", "is_worked_example": false, "text": "A bigger difficulty is apparent when we consider a recursive procedure where there's a nested call to the procedure itself."}, {"start": "00:04:19", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "During execution the recursion will terminate for some values of the arguments and the recursive procedure will eventually return answer."}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:37", "is_worked_example": false, "text": "But at compile time, the inlining process would not terminate and so the inlining scheme fails if the language allows recursion."}, {"start": "00:04:37", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "The second option is to \"link\" to the procedure."}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:51", "is_worked_example": false, "text": "In this approach there is a single copy of the procedure code which we arrange to be run for each procedure call -- all the procedure calls are said to link to the procedure code."}, {"start": "00:04:51", "is_lecture": true, "end": "00:04:59", "is_worked_example": false, "text": "Here the body of the procedure is translated once into Beta instructions and the first instruction is identified as the procedure's entry point."}, {"start": "00:04:59", "is_lecture": true, "end": "00:05:06", "is_worked_example": false, "text": "The procedure call is compiled into a set of instructions that evaluate the argument expressions and save the values in an agreed-upon location."}, {"start": "00:05:06", "is_lecture": true, "end": "00:05:13", "is_worked_example": false, "text": "Then we'll use a BR instruction to transfer control to the entry point of the procedure."}, {"start": "00:05:13", "is_lecture": true, "end": "00:05:22", "is_worked_example": false, "text": "Recall that the BR instruction not only changes the PC but saves the address of the instruction following the branch in a specified register."}, {"start": "00:05:22", "is_lecture": true, "end": "00:05:30", "is_worked_example": false, "text": "This saved address is the \"return address\" where we want execution to resume when procedure execution is complete."}, {"start": "00:05:30", "is_lecture": true, "end": "00:05:42", "is_worked_example": false, "text": "After branching to the entry point, the procedure code runs, stores the result in an agreed-upon location and then resumes execution of the calling program by jumping to the supplied return address."}, {"start": "00:05:42", "is_lecture": true, "end": "00:05:54", "is_worked_example": false, "text": "To complete this implementation plan we need a \"calling convention\" that specifies where to store the argument values during procedure calls and where the procedure should store the return value."}, {"start": "00:05:54", "is_lecture": true, "end": "00:05:58", "is_worked_example": false, "text": "It's tempting to simply allocate specific memory locations for the job."}, {"start": "00:05:58", "is_lecture": true, "end": "00:06:00", "is_worked_example": false, "text": "How about using registers?"}, {"start": "00:06:00", "is_lecture": true, "end": "00:06:05", "is_worked_example": false, "text": "We could pass the argument value in registers starting, say, with R1."}, {"start": "00:06:05", "is_lecture": true, "end": "00:06:10", "is_worked_example": false, "text": "The return address could be stored in another register, say R28."}, {"start": "00:06:10", "is_lecture": true, "end": "00:06:17", "is_worked_example": false, "text": "As we can see, with this convention the BR and JMP instructions are just what we need to implement procedure call and return."}, {"start": "00:06:17", "is_lecture": true, "end": "00:06:21", "is_worked_example": false, "text": "It's usual to call the register holding the return address the \"linkage pointer\"."}, {"start": "00:06:21", "is_lecture": true, "end": "00:06:25", "is_worked_example": false, "text": "And finally the procedure can use, say, R0 to hold the return value."}, {"start": "00:06:25", "is_lecture": true, "end": "00:06:30", "is_worked_example": false, "text": "Let's see how this would work when executing the procedure call fact(3)."}, {"start": "00:06:30", "is_lecture": true, "end": "00:06:37", "is_worked_example": false, "text": "As shown on the right, fact(3) requires a recursive call to compute fact(2), and so on."}, {"start": "00:06:37", "is_lecture": true, "end": "00:06:47", "is_worked_example": false, "text": "Our goal is to have a uniform calling convention where all procedure calls and procedure bodies use the same convention for storing arguments, return addresses and return values."}, {"start": "00:06:47", "is_lecture": true, "end": "00:06:57", "is_worked_example": false, "text": "In particular, we'll use the same convention when compiling the recursive call fact(n-1) as we did for the initial call to fact(3)."}, {"start": "00:06:57", "is_lecture": true, "end": "00:06:59", "is_worked_example": false, "text": "Okay."}, {"start": "00:06:59", "is_lecture": true, "end": "00:07:04", "is_worked_example": false, "text": "In the code shown on the right we've used our proposed convention when compiling the Beta code for fact()."}, {"start": "00:07:04", "is_lecture": true, "end": "00:07:06", "is_worked_example": false, "text": "Let's take a quick tour."}, {"start": "00:07:06", "is_lecture": true, "end": "00:07:21", "is_worked_example": false, "text": "To compile the initial call fact(3) the compiler generated a CMOVE instruction to put the argument value in R1 and then a BR instruction to transfer control to fact's entry point while remembering the return address in R28."}, {"start": "00:07:21", "is_lecture": true, "end": "00:07:31", "is_worked_example": false, "text": "The first statement in the body of fact tests the value of the argument using CMPLEC and BT instructions."}, {"start": "00:07:31", "is_lecture": true, "end": "00:07:42", "is_worked_example": false, "text": "When n is greater than 0, the code performs a recursive call to fact, saving the value of the recursive argument n-1 in R1 as our convention requires."}, {"start": "00:07:42", "is_lecture": true, "end": "00:07:52", "is_worked_example": false, "text": "Note that we had to first save the value of the original argument n because we'll need it for the multiplication after the recursive call returns its value in R0."}, {"start": "00:07:52", "is_lecture": true, "end": "00:07:58", "is_worked_example": false, "text": "If n is not greater than 0, the value 1 is placed in R0."}, {"start": "00:07:58", "is_lecture": true, "end": "00:08:10", "is_worked_example": false, "text": "Then the two possible execution paths merge, each having generated the appropriate return value in R0, and finally there's a JMP to return control to the caller."}, {"start": "00:08:10", "is_lecture": true, "end": "00:08:17", "is_worked_example": false, "text": "The JMP instruction knows to find the return address in R28, just where the BR put it as part of the original procedure call."}, {"start": "00:08:17", "is_lecture": true, "end": "00:08:24", "is_worked_example": false, "text": "Some of you may have noticed that there are some difficulties with this particular implementation."}, {"start": "00:08:24", "is_lecture": true, "end": "00:08:31", "is_worked_example": false, "text": "The code is correct in the sense that it faithfully implements procedure call and return using our proposed convention."}, {"start": "00:08:31", "is_lecture": true, "end": "00:08:38", "is_worked_example": false, "text": "The problem is that during recursive calls we'll be overwriting register values we need later."}, {"start": "00:08:38", "is_lecture": true, "end": "00:08:47", "is_worked_example": false, "text": "For example, note that following our calling convention, the recursive call also uses R28 to store the return address."}, {"start": "00:08:47", "is_lecture": true, "end": "00:08:53", "is_worked_example": false, "text": "When executed, the code for the original call stored the address of the HALT instruction in R28."}, {"start": "00:08:53", "is_lecture": true, "end": "00:09:00", "is_worked_example": false, "text": "Inside the procedure, the recursive call will store the address of the MUL instruction in R28."}, {"start": "00:09:00", "is_lecture": true, "end": "00:09:04", "is_worked_example": false, "text": "Unfortunately that overwrites the original return address."}, {"start": "00:09:04", "is_lecture": true, "end": "00:09:14", "is_worked_example": false, "text": "Even the attempt to save the value of the argument N in R2 is doomed to fail since during the execution of the recursive call R2 will be overwritten."}, {"start": "00:09:14", "is_lecture": true, "end": "00:09:26", "is_worked_example": false, "text": "The crux of the problem is that each recursive call needs to remember the value of its argument and return address, i.e., we need two storage locations for each active call to fact()."}, {"start": "00:09:26", "is_lecture": true, "end": "00:09:38", "is_worked_example": false, "text": "And while executing fact(3), when we finally get to calling fact(0) there are four nested active calls, so we'll need 4*2 = 8 storage locations."}, {"start": "00:09:38", "is_lecture": true, "end": "00:09:43", "is_worked_example": false, "text": "In fact, the amount of storage needed varies with the depth of the recursion."}, {"start": "00:09:43", "is_lecture": true, "end": "00:09:50", "is_worked_example": false, "text": "Obviously we can't use just two registers (R2 and R28) to hold all the values we need to save."}, {"start": "00:09:50", "is_lecture": true, "end": "00:09:53", "is_worked_example": false, "text": "One fix is to disallow recursion!"}, {"start": "00:09:53", "is_lecture": true, "end": "00:09:59", "is_worked_example": false, "text": "And, in fact, some of the early programming languages such as FORTRAN did just that."}, {"start": "00:09:59", "is_lecture": true, "end": "00:10:03", "is_worked_example": false, "text": "But let's see if we can solve the problem another way."}]}, "C04S04B01-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c4/c4s2/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c4s2v1", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:07", "is_worked_example": true, "text": "As presented in lecture, in this course, we use a simple 32-bit processor called the Beta."}, {"start": "00:00:07", "is_lecture": false, "end": "00:00:11", "is_worked_example": true, "text": "The Beta works on 32-bit instruction and data words."}, {"start": "00:00:11", "is_lecture": false, "end": "00:00:15", "is_worked_example": true, "text": "However, the addresses in memory are specified in bytes."}, {"start": "00:00:15", "is_lecture": false, "end": "00:00:22", "is_worked_example": true, "text": "A byte is made up of 8 bits, so each 32-bit instruction consists of 4 bytes."}, {"start": "00:00:22", "is_lecture": false, "end": "00:00:36", "is_worked_example": true, "text": "That means that if you have two instructions A and B in consecutive memory locations, if A is at address 0x100, then B is at address 0x104."}, {"start": "00:00:36", "is_lecture": false, "end": "00:00:41", "is_worked_example": true, "text": "Now, suppose that you are given the following piece of code."}, {"start": "00:00:41", "is_lecture": false, "end": "00:00:47", "is_worked_example": true, "text": "The . = 0 notation tells you that your program begins at address 0."}, {"start": "00:00:47", "is_lecture": false, "end": "00:00:54", "is_worked_example": true, "text": "You can assume that execution begins at this location 0 and halts when the HALT() instruction is about to be executed."}, {"start": "00:00:54", "is_lecture": false, "end": "00:01:01", "is_worked_example": true, "text": "We want to determine what value ends up in R0 after this instruction sequence has been executed."}, {"start": "00:01:01", "is_lecture": false, "end": "00:01:09", "is_worked_example": true, "text": "Note that we are working with hexadecimal numbers in this code and we want our answer to also be in hexadecimal."}, {"start": "00:01:09", "is_lecture": false, "end": "00:01:14", "is_worked_example": true, "text": "This code begins with a LD operation into register R0."}, {"start": "00:01:14", "is_lecture": false, "end": "00:01:21", "is_worked_example": true, "text": "The load, uses the value of R31 + c as the source address for the load."}, {"start": "00:01:21", "is_lecture": false, "end": "00:01:28", "is_worked_example": true, "text": "Since R31 = 0, this means that the value stored at address c is being loaded into R0."}, {"start": "00:01:28", "is_lecture": false, "end": "00:01:34", "is_worked_example": true, "text": "So after the LD, R0 = 0x300."}, {"start": "00:01:34", "is_lecture": false, "end": "00:01:43", "is_worked_example": true, "text": "Next an ADDC of R0 with the constant b is performed and that result is stored back into R0."}, {"start": "00:01:43", "is_lecture": false, "end": "00:01:53", "is_worked_example": true, "text": "The .=0x200 notation immediately preceding the \"a\" label, tells us that address a = 0x200."}, {"start": "00:01:53", "is_lecture": false, "end": "00:02:01", "is_worked_example": true, "text": "This means that address b = 0x204, and c = 0x208."}, {"start": "00:02:01", "is_lecture": false, "end": "00:02:16", "is_worked_example": true, "text": "So if we are adding the constant b to R0, R0 now becomes 0x300 + 0x204 = 0x504."}, {"start": "00:02:16", "is_lecture": false, "end": "00:02:19", "is_worked_example": true, "text": "Now lets take a look at this short piece of code."}, {"start": "00:02:19", "is_lecture": false, "end": "00:02:25", "is_worked_example": true, "text": "Our goal is to determine the value left in R0 in hexadecimal."}, {"start": "00:02:25", "is_lecture": false, "end": "00:02:33", "is_worked_example": true, "text": "The . = 0 notation once again tells us that our first instruction (the branch) is at address 0."}, {"start": "00:02:33", "is_lecture": false, "end": "00:02:43", "is_worked_example": true, "text": "The branch instruction then branches to location . + 4 = 0 + 4 = 4."}, {"start": "00:02:43", "is_lecture": false, "end": "00:02:46", "is_worked_example": true, "text": "This is the address of the HALT() instruction."}, {"start": "00:02:46", "is_lecture": false, "end": "00:02:59", "is_worked_example": true, "text": "In addition to branching to the HALT() instruction, a branch instruction also stores the address of the instruction immediately following it into the destination register, R0 in this case."}, {"start": "00:02:59", "is_lecture": false, "end": "00:03:07", "is_worked_example": true, "text": "The address of the next instruction is 4, so R0 = 0x4."}, {"start": "00:03:07", "is_lecture": false, "end": "00:03:12", "is_worked_example": true, "text": "Let's take a look at what this code is doing."}, {"start": "00:03:12", "is_lecture": false, "end": "00:03:26", "is_worked_example": true, "text": "It first loads the contents of address x into R0, so R0 = 0x0FACE0FF or 0xFACEOFF for short."}, {"start": "00:03:26", "is_lecture": false, "end": "00:03:32", "is_worked_example": true, "text": "It then moves the constant 0 into R1, so R1 = 0."}, {"start": "00:03:32", "is_lecture": false, "end": "00:03:40", "is_worked_example": true, "text": "It now enters the loop where the ANDC puts into R3 the least significant bit of R0."}, {"start": "00:03:40", "is_lecture": false, "end": "00:03:45", "is_worked_example": true, "text": "The ADD increments R1 if R3 equals 1."}, {"start": "00:03:45", "is_lecture": false, "end": "00:03:54", "is_worked_example": true, "text": "This means that if the least significant bit of R0 was a 1, then R1 is incremented by 1, otherwise R1 stays the same."}, {"start": "00:03:54", "is_lecture": false, "end": "00:03:59", "is_worked_example": true, "text": "The shift right constant then shifts R0 to the right by 1."}, {"start": "00:03:59", "is_lecture": false, "end": "00:04:10", "is_worked_example": true, "text": "This makes R0 have a 0 in the most significant bit, and the top 31 bits, of what R0 used to be, are shifted over by one position to the right."}, {"start": "00:04:10", "is_lecture": false, "end": "00:04:17", "is_worked_example": true, "text": "Note that this means that the least significant bit of the old R0 is now completely gone."}, {"start": "00:04:17", "is_lecture": false, "end": "00:04:24", "is_worked_example": true, "text": "That's okay though because we already incremented R1 based on that original least significant bit of R0."}, {"start": "00:04:24", "is_lecture": false, "end": "00:04:33", "is_worked_example": true, "text": "The BNE, or branch on not equal, then branches back to loop as long as R0 is not equal to 0."}, {"start": "00:04:33", "is_lecture": false, "end": "00:04:39", "is_worked_example": true, "text": "This means that what this loop is doing is looking at the current least significant bit of R0,"}, {"start": "00:04:39", "is_lecture": false, "end": "00:04:42", "is_worked_example": true, "text": "incrementing R1 if that bit is 1,"}, {"start": "00:04:42", "is_lecture": false, "end": "00:04:46", "is_worked_example": true, "text": "and then shifting that bit out until all bits have been shifted out."}, {"start": "00:04:46", "is_lecture": false, "end": "00:04:53", "is_worked_example": true, "text": "In other words, it's counting the total number of ones in the original value loaded from address x."}, {"start": "00:04:53", "is_lecture": false, "end": "00:05:03", "is_worked_example": true, "text": "The loop ends when all the 1's have been counted at which point R0 is left with a 0 in it because all the 1's have been shifted out."}, {"start": "00:05:03", "is_lecture": false, "end": "00:05:31", "is_worked_example": true, "text": "R1 is left with the number of 1's in the data 0x0FACE0FF equals in binary 0000 1111 1010 1100 1110 0000 1111 1111."}, {"start": "00:05:31", "is_lecture": false, "end": "00:05:46", "is_worked_example": true, "text": "There are 19 ones in 0x0FACE0FF, so R1 = 19 = 16 + 3 which in hexadecimal = 0x13."}, {"start": "00:05:46", "is_lecture": false, "end": "00:05:53", "is_worked_example": true, "text": "In this piece of code, the CMOVE first sets the stack pointer to 0x1000."}, {"start": "00:05:53", "is_lecture": false, "end": "00:05:58", "is_worked_example": true, "text": "Then a PUSH(SP) operation is performed."}, {"start": "00:05:58", "is_lecture": false, "end": "00:06:01", "is_worked_example": true, "text": "Lets first understand what a PUSH instruction does."}, {"start": "00:06:01", "is_lecture": false, "end": "00:06:06", "is_worked_example": true, "text": "A PUSH instruction is actually a macro made up of two beta instructions."}, {"start": "00:06:06", "is_lecture": false, "end": "00:06:16", "is_worked_example": true, "text": "To push a value onto the stack, the stack pointer is first incremented by 4 in order to point to the next empty location on the stack."}, {"start": "00:06:16", "is_lecture": false, "end": "00:06:20", "is_worked_example": true, "text": "This sets SP = 0x1004."}, {"start": "00:06:20", "is_lecture": false, "end": "00:06:34", "is_worked_example": true, "text": "Then, the contents of register Ra, which is being pushed onto the stack, are stored at the memory location whose address is SP-4 which is address 0x1000."}, {"start": "00:06:34", "is_lecture": false, "end": "00:06:46", "is_worked_example": true, "text": "Now looking at the actual PUSH operation performed here, we are performing a PUSH of stack pointer so the Ra register is also the stack pointer."}, {"start": "00:06:46", "is_lecture": false, "end": "00:06:57", "is_worked_example": true, "text": "This means that the value stored at location 0x1000 is actually the value of SP which is 0x1004."}, {"start": "00:06:57", "is_lecture": false, "end": "00:07:05", "is_worked_example": true, "text": "So the value that got pushed onto the stack is 0x1004."}]}, "C11S01B05-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/5?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v5", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "So, how can the memory system arrange for the right data to be in the right place at the right time?"}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:11", "is_worked_example": false, "text": "Our goal is to have the frequently-used data in some fast SRAM."}, {"start": "00:00:11", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "That means the memory system will have to be able to predict which memory locations will be accessed."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "And to keep the overhead of moving data into and out of SRAM manageable, we'd like to amortize the cost of the move over many accesses."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:30", "is_worked_example": false, "text": "In other words we want any block of data we move into SRAM to be accessed many times."}, {"start": "00:00:30", "is_lecture": true, "end": "00:00:38", "is_worked_example": false, "text": "When not in SRAM, data would live in the larger, slower DRAM that serves as main memory."}, {"start": "00:00:38", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "If the system is working as planned, DRAM accesses would happen infrequently, e.g., only when it's time to bring another block of data into SRAM."}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:56", "is_worked_example": false, "text": "If we look at how programs access memory, it turns out we *can* make accurate predictions about which memory locations will be accessed."}, {"start": "00:00:56", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "The guiding principle is \"locality of reference\" which tells us that if there's an access to address X at time t, it's very probable that the program will access a nearby location in the near future."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:18", "is_worked_example": false, "text": "To understand why programs exhibit locality of reference, let's look at how a running program accesses memory."}, {"start": "00:01:18", "is_lecture": true, "end": "00:01:21", "is_worked_example": false, "text": "Instruction fetches are quite predictable."}, {"start": "00:01:21", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "Execution usually proceeds sequentially since most of the time the next instruction is fetched from the location after that of the current instruction."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:37", "is_worked_example": false, "text": "Code that loops will repeatedly fetch the same sequence of instructions, as shown here on the left of the time line."}, {"start": "00:01:37", "is_lecture": true, "end": "00:01:47", "is_worked_example": false, "text": "There will of course be branches and subroutine calls that interrupt sequential execution, but then we're back to fetching instructions from consecutive locations."}, {"start": "00:01:47", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "Some programming constructs, e.g., method dispatch in object-oriented languages, can produce scattered references to very short code sequences (as shown on the right of the time line) but order is quickly restored."}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "This agrees with our intuition about program execution."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:12", "is_worked_example": false, "text": "For example, once we execute the first instruction of a procedure, we'll almost certainly execute the remaining instructions in the procedure."}, {"start": "00:02:12", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "So if we arranged for all the code of a procedure to moved to SRAM when the procedure's first instruction was fetched, we'd expect that many subsequent instruction fetches could be satisfied by the SRAM."}, {"start": "00:02:24", "is_lecture": true, "end": "00:02:35", "is_worked_example": false, "text": "And although fetching the first word of a block from DRAM has relatively long latency, the DRAM's fast column accesses will quickly stream the remaining words from sequential addresses."}, {"start": "00:02:35", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "This will amortize the cost of the initial access over the whole sequence of transfers."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:49", "is_worked_example": false, "text": "The story is similar for accesses by a procedure to its arguments and local variables in the current stack frame."}, {"start": "00:02:49", "is_lecture": true, "end": "00:02:57", "is_worked_example": false, "text": "Again there will be many accesses to a small region of memory during the span of time we're executing the procedure's code."}, {"start": "00:02:57", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "Data accesses generated by LD and ST instructions also exhibit locality."}, {"start": "00:03:04", "is_lecture": true, "end": "00:03:08", "is_worked_example": false, "text": "The program may be accessing the components of an object or struct."}, {"start": "00:03:08", "is_lecture": true, "end": "00:03:11", "is_worked_example": false, "text": "Or it may be stepping through the elements of an array."}, {"start": "00:03:11", "is_lecture": true, "end": "00:03:19", "is_worked_example": false, "text": "Sometimes information is moved from one array or data object to another, as shown by the data accesses on the right of the timeline."}, {"start": "00:03:19", "is_lecture": true, "end": "00:03:28", "is_worked_example": false, "text": "Using simulations we can estimate the number of different locations that will be accessed over a particular span of time."}, {"start": "00:03:28", "is_lecture": true, "end": "00:03:33", "is_worked_example": false, "text": "What we discover when we do this is the notion of a \"working set\" of locations that are accessed repeatedly."}, {"start": "00:03:33", "is_lecture": true, "end": "00:03:42", "is_worked_example": false, "text": "If we plot the size of the working set as a function of the size of the time interval, we see that the size of the working set levels off."}, {"start": "00:03:42", "is_lecture": true, "end": "00:03:54", "is_worked_example": false, "text": "In other words once the time interval reaches a certain size the number of locations accessed is approximately the same independent of when in time the interval occurs."}, {"start": "00:03:54", "is_lecture": true, "end": "00:04:09", "is_worked_example": false, "text": "As we see in our plot to the left, the actual addresses accessed will change, but the number of *different* addresses during the time interval will, on the average, remain relatively constant and, surprisingly, not all that large!"}, {"start": "00:04:09", "is_lecture": true, "end": "00:04:19", "is_worked_example": false, "text": "This means that if we can arrange for our SRAM to be large enough to hold the working set of the program, most accesses will be able to be satisfied by the SRAM."}, {"start": "00:04:19", "is_lecture": true, "end": "00:04:30", "is_worked_example": false, "text": "We'll occasionally have to move new data into the SRAM and old data back to DRAM, but the DRAM access will occur less frequently than SRAM accesses."}, {"start": "00:04:30", "is_lecture": true, "end": "00:04:45", "is_worked_example": false, "text": "We'll work out the mathematics in a slide or two, but you can see that thanks to locality of reference we're on track to build a memory out of a combination of SRAM and DRAM that performs like an SRAM but has the capacity of the DRAM."}, {"start": "00:04:45", "is_lecture": true, "end": "00:04:50", "is_worked_example": false, "text": "The SRAM component of our hierarchical memory system is called a \"cache\"."}, {"start": "00:04:50", "is_lecture": true, "end": "00:04:55", "is_worked_example": false, "text": "It provides low-latency access to recently-accessed blocks of data."}, {"start": "00:04:55", "is_lecture": true, "end": "00:05:02", "is_worked_example": false, "text": "If the requested data is in the cache, we have a \"cache hit\" and the data is supplied by the SRAM."}, {"start": "00:05:02", "is_lecture": true, "end": "00:05:12", "is_worked_example": false, "text": "If the requested data is not in the cache, we have a \"cache miss\" and a block of data containing the requested location will have to be moved from DRAM into the cache."}, {"start": "00:05:12", "is_lecture": true, "end": "00:05:20", "is_worked_example": false, "text": "The locality principle tells us that we should expect cache hits to occur much more frequently than cache misses."}, {"start": "00:05:20", "is_lecture": true, "end": "00:05:25", "is_worked_example": false, "text": "Modern computer systems often use multiple levels of SRAM caches."}, {"start": "00:05:25", "is_lecture": true, "end": "00:05:35", "is_worked_example": false, "text": "The levels closest to the CPU are smaller but very fast, while the levels further away from the CPU are larger and hence slower."}, {"start": "00:05:35", "is_lecture": true, "end": "00:05:44", "is_worked_example": false, "text": "A miss at one level of the cache generates an access to the next level, and so on until a DRAM access is needed to satisfy the initial request."}, {"start": "00:05:44", "is_lecture": true, "end": "00:05:50", "is_worked_example": false, "text": "Caching is used in many applications to speed up accesses to frequently-accessed data."}, {"start": "00:05:50", "is_lecture": true, "end": "00:06:04", "is_worked_example": false, "text": "For example, your browser maintains a cache of frequently-accessed web pages and uses its local copy of the web page if it determines the data is still valid, avoiding the delay of transferring the data over the Internet."}, {"start": "00:06:04", "is_lecture": true, "end": "00:06:08", "is_worked_example": false, "text": "Here's an example memory hierarchy that might be found on a modern computer."}, {"start": "00:06:08", "is_lecture": true, "end": "00:06:17", "is_worked_example": false, "text": "There are three levels on-chip SRAM caches, followed by DRAM main memory and a flash-memory cache for the hard disk drive."}, {"start": "00:06:17", "is_lecture": true, "end": "00:06:26", "is_worked_example": false, "text": "The compiler is responsible for deciding which data values are kept in the CPU registers and which values require the use of LDs and STs."}, {"start": "00:06:26", "is_lecture": true, "end": "00:06:32", "is_worked_example": false, "text": "The 3-level cache and accesses to DRAM are managed by circuity in the memory system."}, {"start": "00:06:32", "is_lecture": true, "end": "00:06:44", "is_worked_example": false, "text": "After that the access times are long enough (many hundreds of instruction times) that the job of managing the movement of data between the lower levels of the hierarchy is turned over to software."}, {"start": "00:06:44", "is_lecture": true, "end": "00:06:48", "is_worked_example": false, "text": "Today we're discussing how the on-chip caches work."}, {"start": "00:06:48", "is_lecture": true, "end": "00:06:56", "is_worked_example": false, "text": "In Part 3 of the course, we'll discuss how the software manages main memory and non-volatile storage devices."}, {"start": "00:06:56", "is_lecture": true, "end": "00:07:07", "is_worked_example": false, "text": "Whether managed by hardware or software, each layer of the memory system is designed to provide lower-latency access to frequently-accessed locations in the next, slower layer."}, {"start": "00:07:07", "is_lecture": true, "end": "00:07:12", "is_worked_example": false, "text": "But, as we'll see, the implementation strategies will be quite different in the slower layers of the hierarchy."}]}, "C03S01B01-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s1/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "Welcome to Part 2 of 6.004x!"}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:13", "is_worked_example": false, "text": "In this part of the course, we turn our attention to the design and implementation of digital systems that can perform useful computations on different types of binary data."}, {"start": "00:00:13", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "We'll come up with a general-purpose design for these systems, we which we call \"computers\", so that they can serve as useful tools in many diverse application areas."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "Computers were first used to perform numeric calculations in science and engineering, but today they are used as the central control element in any system where complex behavior is required."}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:37", "is_worked_example": false, "text": "We have a lot to do in this chapter, so let's get started!"}, {"start": "00:00:37", "is_lecture": true, "end": "00:00:42", "is_worked_example": false, "text": "Suppose we want to design a system to compute the factorial function on some numeric argument N."}, {"start": "00:00:42", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "N! is defined as the product of N times N-1 times N-2, and so on down to 1."}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "We can use a programming language like C to describe the sequence of operations necessary to perform the factorial computation."}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:00", "is_worked_example": false, "text": "In this program there are two variables, \"a\" and \"b\"."}, {"start": "00:01:00", "is_lecture": true, "end": "00:01:04", "is_worked_example": false, "text": "\"a\" is used to accumulate the answer as we compute it step-by-step."}, {"start": "00:01:04", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "\"b\" is used to hold the next value we need to multiply."}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "\"b\" starts with the value of the numeric argument N."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:25", "is_worked_example": false, "text": "The DO loop is where the work gets done: on each loop iteration we perform one of the multiplies from the factorial formula, updating the value of the accumulator \"a\" with the result, then decrementing \"b\" in preparation for the next loop iteration."}, {"start": "00:01:25", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "If we want to implement a digital system that performs this sequence of operations, it makes sense to use sequential logic!"}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "Here's the state transition diagram for a high-level finite-state machine designed to perform the necessary computations in the desired order."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:47", "is_worked_example": false, "text": "We call this a high-level FSM since the \"outputs\" of each state are more than simple logic levels."}, {"start": "00:01:47", "is_lecture": true, "end": "00:01:54", "is_worked_example": false, "text": "They are formulas indicating operations to be performed on source variables, storing the result in a destination variable."}, {"start": "00:01:54", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "The sequence of states visited while the FSM is running mirrors the steps performed by the execution of the C program."}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:11", "is_worked_example": false, "text": "The FSM repeats the LOOP state until the new value to be stored in \"b\" is equal to 0, at which point the FSM transitions into the final DONE state."}, {"start": "00:02:11", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "The high-level FSM is useful when designing the circuitry necessary to implement the desired computation using our digital logic building blocks."}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:23", "is_worked_example": false, "text": "We'll use 32-bit D-registers to hold the \"a\" and \"b\" values."}, {"start": "00:02:23", "is_lecture": true, "end": "00:02:32", "is_worked_example": false, "text": "And we'll need a 2-bit D-register to hold the 2-bit encoding of the current state, i.e., the encoding for either START, LOOP or DONE."}, {"start": "00:02:32", "is_lecture": true, "end": "00:02:37", "is_worked_example": false, "text": "We'll include logic to compute the inputs required to implement the correct state transitions."}, {"start": "00:02:37", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "In this case, we need to know if the new value for \"b\" is zero or not."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:52", "is_worked_example": false, "text": "And, finally, we'll need logic to perform multiply and decrement, and to select which value should be loaded into the \"a\" and \"b\" registers at the end of each FSM cycle."}, {"start": "00:02:52", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "Let's start by designing the logic that implements the desired computations -- we call this part of the logic the \"datapath\"."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "First we'll need two 32-bit D-registers to hold the \"a\" and \"b\" values."}, {"start": "00:03:04", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "Then we'll draw the combinational logic blocks needed to compute the values to be stored in those registers."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:17", "is_worked_example": false, "text": "In the START state , we need the constant 1 to load into the \"a\" register and the constant N to load into the \"b\" register."}, {"start": "00:03:17", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "In the LOOP state, we need to compute a*b for the \"a\" register and b-1 for the \"b\" register."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "Finally, in the DONE state , we need to be able to reload each register with its current value."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "We'll use multiplexers to select the appropriate value to load into each of the data registers."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:47", "is_worked_example": false, "text": "These multiplexers are controlled by 2-bit select signals that choose which of the three 32-bit input values will be the 32-bit value to be loaded into the register."}, {"start": "00:03:47", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "So by choosing the appropriate values for WASEL and WBSEL, we can make the datapath compute the desired values at each step in the FSM's operation."}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "Next we'll add the combinational logic needed to control the FSM's state transitions."}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:07", "is_worked_example": false, "text": "In this case, we need to test if the new value to be loaded into the \"b\" register is zero."}, {"start": "00:04:07", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "The Z signal from the datapath will be 1 if that's the case and 0 otherwise."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:25", "is_worked_example": false, "text": "Now we're all set to add the hardware for the control FSM, which has one input (Z) from the datapath and generates two 2-bit outputs (WASEL and WBSEL) to control the datapath."}, {"start": "00:04:25", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "Here's the truth table for the FSM's combinational logic."}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:34", "is_worked_example": false, "text": "S is the current state, encoded as a 2-bit value, and S' is the next state."}, {"start": "00:04:34", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "Using our skills from Part 1 of the course, we're ready to draw a schematic for the system!"}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "We know how to design the appropriate multiplier and decrement circuitry."}, {"start": "00:04:44", "is_lecture": true, "end": "00:04:48", "is_worked_example": false, "text": "And we can use our standard register-and-ROM implementation for the control FSM."}, {"start": "00:04:48", "is_lecture": true, "end": "00:05:01", "is_worked_example": false, "text": "The Z signal from the datapath is combined with the 2 bits of current state to form the 3 inputs to the combinational logic, in this case realized by a read-only memory with 2^3=8 locations."}, {"start": "00:05:01", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "Each ROM location has the appropriate values for the 6 output bits: 2 bits each for WASEL, WBSEL, and next state."}, {"start": "00:05:10", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "The table on the right shows the ROM contents, which are easily determined from the table on the previous slide."}]}, "C03S01B14-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s1/14?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s1v14", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "Finally, our last instruction!"}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:07", "is_worked_example": false, "text": "Branches conditionally transfer control to a specific target instruction."}, {"start": "00:00:07", "is_lecture": true, "end": "00:00:18", "is_worked_example": false, "text": "But we'll also need the ability to compute the address of the target instruction -- that ability is provided by the JMP instruction which simply sets the program counter to value from register \"ra\"."}, {"start": "00:00:18", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "Like branches, JMP will write the PC+4 value into to the specified destination register."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "This capability is very useful for implementing procedures in Beta code."}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:37", "is_worked_example": false, "text": "Suppose we have a procedure \"sqrt\" that computes the square root of its argument, which is passed in, say, R0."}, {"start": "00:00:37", "is_lecture": true, "end": "00:00:42", "is_worked_example": false, "text": "We don't show the code for sqrt on the right, except for the last instruction, which is a JMP."}, {"start": "00:00:42", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "On the left we see that the programmer wants to call the sqrt procedure from two different places in his program."}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:50", "is_worked_example": false, "text": "Let's watch what happens..."}, {"start": "00:00:50", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "The first call to the sqrt procedure is implemented by the unconditional branch at location 0x100 in main memory."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:04", "is_worked_example": false, "text": "The branch target is the first instruction of the sqrt procedure, so execution continues there."}, {"start": "00:01:04", "is_lecture": true, "end": "00:01:13", "is_worked_example": false, "text": "The BEQ also writes the address of the following instruction (0x104) into its destination register, R28."}, {"start": "00:01:13", "is_lecture": true, "end": "00:01:27", "is_worked_example": false, "text": "When we reach the end of first procedure call, the JMP instruction loads the value in R28, which is 0x104, into the PC, so execution continues with the instruction following the first BEQ."}, {"start": "00:01:27", "is_lecture": true, "end": "00:01:34", "is_worked_example": false, "text": "So we've managed to return from the procedure and continue execution where we left off in the main program."}, {"start": "00:01:34", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "When we get to the second call to the sqrt procedure, the sequence of events is the same as before except that this time R28 contains 0x67C, the address of the instruction following the second BEQ."}, {"start": "00:01:48", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "So the second time we reach the end of the sqrt procedure, the JMP sets the PC to 0x67C and execution resumes with the instruction following the second procedure call."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "Neat!"}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:06", "is_worked_example": false, "text": "The BEQs and JMP have worked together to implement procedure call and return."}, {"start": "00:02:06", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "We'll discuss the implementation of procedures in detail in an upcoming lecture."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "That wraps up the design of the Beta instruction set architecture."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "In summary, the Beta has 32 registers to hold values that can be used as operands for the ALU."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "All other values, along with the binary representation of the program itself, are stored in main memory."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "The Beta supports 32-bit memory addresses and can access values in 2^32 = 4 gigabytes of main memory."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:45", "is_worked_example": false, "text": "All Beta memory access refer to 32-bit words, so all addresses will be a multiple of 4 since there are 4 bytes/word."}, {"start": "00:02:45", "is_lecture": true, "end": "00:02:48", "is_worked_example": false, "text": "The are two instruction formats."}, {"start": "00:02:48", "is_lecture": true, "end": "00:02:53", "is_worked_example": false, "text": "The first specifies an opcode, two source registers and a destination register."}, {"start": "00:02:53", "is_lecture": true, "end": "00:03:03", "is_worked_example": false, "text": "The second replaces the second source register with a 32-bit constant, derived by sign-extending a 16-bit constant stored in the instruction itself."}, {"start": "00:03:03", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "There are three classes of instructions:"}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "ALU operations, LD and ST for accessing main memory, and branches and JMPs that change the order of execution."}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "And that's it!"}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "As we'll see in the next lecture, we'll be able parlay this relatively simple repertoire of operations into a system that can execute any computation we can specify."}]}, "C06S01B04-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c6/c6s1/4?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c6s1v4", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "Now let's turn our attention compile_statement."}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "The first two statement types are pretty easy to handle."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:11", "is_worked_example": false, "text": "Unconditional statements are usually assignment expressions or procedure calls."}, {"start": "00:00:11", "is_lecture": true, "end": "00:00:15", "is_worked_example": false, "text": "We'll simply ask compile_expr to generate the appropriate code."}, {"start": "00:00:15", "is_lecture": true, "end": "00:00:18", "is_worked_example": false, "text": "Compound statements are equally easy."}, {"start": "00:00:18", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "We'll recursively call compile_statement to generate code for each statement in turn."}, {"start": "00:02:24", "is_lecture": true, "end": "00:00:28", "is_worked_example": false, "text": "The code for statement_2 will immediately follow the code generated for statement_1."}, {"start": "00:00:28", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "Execution will proceed sequentially through the code for each statement."}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "Here we see the simplest form the conditional statement, where we need to generate code to evaluate the test expression and then, if the value in the register is FALSE, skip over the code that executes the statement in the THEN clause."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "The simple assembly-language template uses recursive calls to compile_expr and compile_statement to generate code for the various parts of the IF statement."}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "The full-blown conditional statement includes an ELSE clause, which should be executed if the value of the test expression is FALSE."}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "The template uses some branches and labels to ensure the course of execution is as intended."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:29", "is_worked_example": false, "text": "You can see that the compilation process is really just the application of many small templates that break the code generation task down step-by-step into smaller and smaller tasks, generating the necessary code to glue all the pieces together in the appropriate fashion."}, {"start": "00:01:29", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "And here's the template for the WHILE statement, which looks a lot like the template for the IF statement with a branch at the end that causes the generated code to be re-executed until the value of the test expression is FALSE."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "With a bit of thought, we can improve on this template slightly."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:59", "is_worked_example": false, "text": "We've reorganized the code so that only a single branch instruction (BT) is executed each iteration, instead of the two branches (BF, BR) per iteration in the original template."}, {"start": "00:01:59", "is_lecture": true, "end": "00:02:07", "is_worked_example": false, "text": "Not a big deal, but little optimizations to code inside a loop can add up to big savings in a long-running program."}, {"start": "00:02:07", "is_lecture": true, "end": "00:02:12", "is_worked_example": false, "text": "Just a quick comment about another common iteration statement, the FOR loop."}, {"start": "00:02:12", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "The FOR loop is a shorthand way of expressing iterations where the loop index (\"i\" in the example shown) is run through a sequence of values and the body of the FOR loop is executed once for each value of the loop index."}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:34", "is_worked_example": false, "text": "The FOR loop can be transformed into the WHILE statement shown here, which can then be compiled using the templates shown above."}, {"start": "00:02:34", "is_lecture": true, "end": "00:02:43", "is_worked_example": false, "text": "In this example, we've applied our templates to generate code for the iterative implementation of the factorial function that we've seen before."}, {"start": "00:02:43", "is_lecture": true, "end": "00:02:51", "is_worked_example": false, "text": "Look through the generated code and you'll be able to match the code fragments with the templates from last couple of slides."}, {"start": "00:02:51", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "It's not the most efficient code, but not bad given the simplicity of the recursive-descent approach for compiling high-level programs."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "It's a simple matter to modify the recursive-descent process to accommodate variable values that are stored in dedicated registers rather than in main memory."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:20", "is_worked_example": false, "text": "Optimizing compilers are quite good at identifying opportunities to keep values in registers and hence avoid the LD and ST operations needed to access values in main memory."}, {"start": "00:03:20", "is_lecture": true, "end": "00:03:28", "is_worked_example": false, "text": "Using this simple optimization, the number of instructions in the loop has gone from 10 down to 4."}, {"start": "00:03:28", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "Now the generated code is looking pretty good!"}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "But rather than keep tweaking the recursive-descent approach, let's stop here."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "In the next segment, we'll see how modern compilers take a more general approach to generating code."}, {"start": "00:03:41", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "Still though, the first time I learned about recursive descent, I ran home to write a simple implementation and marveled at having authored my own compiler in an afternoon!"}]}, "C11S01B01-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:05", "is_worked_example": false, "text": "In the last lecture we completed the design of the Beta, our reduced-instruction-set computer."}, {"start": "00:00:05", "is_lecture": true, "end": "00:00:13", "is_worked_example": false, "text": "The simple organization of the Beta ISA meant that there was a lot commonality in the circuity needed to implement the instructions."}, {"start": "00:00:13", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "The final design has a few main building blocks with MUX steering logic to select input values as appropriate."}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:38", "is_worked_example": false, "text": "If we were to count MOSFETs and think about propagation delays, we'd quickly determine that our 3-port main memory (shown here as the two yellow components) was the most costly component both in terms of space and percentage of the cycle time required by the memory accesses."}, {"start": "00:00:38", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "So in many ways, we really have a \"memory machine\" instead of a \"computing machine\"."}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "The execution of every instruction starts by fetching the instruction from main memory."}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:55", "is_worked_example": false, "text": "And ultimately all the data processed by the CPU is loaded from or stored to main memory."}, {"start": "00:00:55", "is_lecture": true, "end": "00:01:09", "is_worked_example": false, "text": "A very few frequently-used variable values can be kept in the CPU's register file, but most interesting programs manipulate *much* more data than can be accommodated by the storage available as part of the CPU datapath."}, {"start": "00:01:09", "is_lecture": true, "end": "00:01:23", "is_worked_example": false, "text": "In fact, the performance of most modern computers is limited by the bandwidth, i.e., bytes/second, of the connection between the CPU and main memory, the so-called \"memory bottleneck\"."}, {"start": "00:01:23", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "The goal of this lecture is to understand the nature of the bottleneck and to see if there architectural improvements we might make to minimize the problem as much as possible."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "We have a number of memory technologies at our disposal, varying widely in their capacity, latency, bandwidth, energy efficiency and their cost."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:49", "is_worked_example": false, "text": "Not surprisingly, we find that each is useful for different applications in our overall system architecture."}, {"start": "00:01:49", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "Our registers are built from sequential logic and provide very low latency access (20ps or so) to at most a few thousands of bits of data."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "Static and dynamic memories, which we'll discuss further in the coming slides, offer larger capacities at the cost of longer access latencies."}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:18", "is_worked_example": false, "text": "Static random-access memories (SRAMs) are designed to provide low latencies (a few nanoseconds at most) to many thousands of locations."}, {"start": "00:02:18", "is_lecture": true, "end": "00:02:29", "is_worked_example": false, "text": "Already we see that more locations means longer access latencies -- this is a fundamental size vs. performance tradeoff of our current memory architectures."}, {"start": "00:02:29", "is_lecture": true, "end": "00:02:43", "is_worked_example": false, "text": "The tradeoff comes about because increasing the number of bits will increase the area needed for the memory circuitry, which will in turn lead to longer signal lines and slower circuit performance due to increased capacitive loads."}, {"start": "00:02:43", "is_lecture": true, "end": "00:02:52", "is_worked_example": false, "text": "Dynamic random-access memories (DRAMs) are optimized for capacity and low cost, sacrificing access latency."}, {"start": "00:02:52", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "As we'll see in this lecture, we'll use both SRAMs and DRAMs to build a hybrid memory hierarchy that provides low average latency and high capacity -- an attempt to get the best of both worlds!"}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:10", "is_worked_example": false, "text": "Notice that the word \"average\" has snuck into the performance claims."}, {"start": "00:03:10", "is_lecture": true, "end": "00:03:18", "is_worked_example": false, "text": "This means that we'll be relying on statistical properties of memory accesses to achieve our goals of low latency and high capacity."}, {"start": "00:03:18", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "In the worst case, we'll still be stuck with the capacity limitations of SRAMs and the long latencies of DRAMs, but we'll work hard to ensure that the worst case occurs infrequently!"}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:37", "is_worked_example": false, "text": "Flash memory and hard-disk drives provide non-volatile storage."}, {"start": "00:03:37", "is_lecture": true, "end": "00:03:42", "is_worked_example": false, "text": "\"Non-volatile\" means that the memory contents are preserved even when the power is turned off."}, {"start": "00:03:42", "is_lecture": true, "end": "00:03:50", "is_worked_example": false, "text": "Hard disks are at the bottom of the memory hierarchy, providing massive amounts of long-term storage for very little cost."}, {"start": "00:03:50", "is_lecture": true, "end": "00:04:08", "is_worked_example": false, "text": "Flash memories, with a 100-fold improvement in access latency, are often used in concert with hard-disk drives in the same way that SRAMs are used in concert with DRAMs, i.e., to provide a hybrid system for non-volatile storage that has improved latency *and* high capacity."}, {"start": "00:04:08", "is_lecture": true, "end": "00:04:16", "is_worked_example": false, "text": "Let's learn a bit more about each of these four memory technologies, then we'll return to the job of building our memory system."}]}, "C11S01B13-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/13?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v13", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "Okay, one more cache design decision to make, then we're done!"}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "How should we handle memory writes in the cache?"}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:14", "is_worked_example": false, "text": "Ultimately we'll need update main memory with the new data, but when should that happen?"}, {"start": "00:00:14", "is_lecture": true, "end": "00:00:18", "is_worked_example": false, "text": "The most obvious choice is to perform the write immediately."}, {"start": "00:00:18", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "In other words, whenever the CPU sends a write request to the cache, the cache then performs the same write to main memory."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:28", "is_worked_example": false, "text": "This is called \"write-through\"."}, {"start": "00:00:28", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "That way main memory always has the most up-to-date value for all locations."}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:41", "is_worked_example": false, "text": "But this can be slow if the CPU has to wait for a DRAM write access -- writes could become a real bottleneck!"}, {"start": "00:00:41", "is_lecture": true, "end": "00:00:51", "is_worked_example": false, "text": "And what if the program is constantly writing a particular memory location, e.g., updating the value of a local variable in the current stack frame?"}, {"start": "00:00:51", "is_lecture": true, "end": "00:00:55", "is_worked_example": false, "text": "In the end we only need to write the last value to main memory."}, {"start": "00:00:55", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "Writing all the earlier values is waste of memory bandwidth."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:09", "is_worked_example": false, "text": "Suppose we let the CPU continue execution while the cache waits for the write to main memory to complete -- this is called \"write-behind\"."}, {"start": "00:01:09", "is_lecture": true, "end": "00:01:14", "is_worked_example": false, "text": "This will overlap execution of the program with the slow writes to main memory."}, {"start": "00:01:14", "is_lecture": true, "end": "00:01:28", "is_worked_example": false, "text": "Of course, if there's another cache miss while the write is still pending, everything will have to wait at that point until both the write and subsequent refill read finish, since the CPU can't proceed until the cache miss is resolved."}, {"start": "00:01:28", "is_lecture": true, "end": "00:01:37", "is_worked_example": false, "text": "The best strategy is called \"write-back\" where the contents of the cache are updated and the CPU continues execution immediately."}, {"start": "00:01:37", "is_lecture": true, "end": "00:01:45", "is_worked_example": false, "text": "The updated cache value is only written to main memory when the cache line is chosen as the replacement line for a cache miss."}, {"start": "00:01:45", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "This strategy minimizes the number of accesses to main memory, preserving the memory bandwidth for other operations."}, {"start": "00:01:53", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "This is the strategy used by most modern processors."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "Write-back is easy to implement."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "Returning to our original cache recipe, we simply eliminate the start of the write to main memory when there's a write request to the cache."}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:11", "is_worked_example": false, "text": "We just update the cache contents and leave it at that."}, {"start": "00:02:11", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "However, replacing a cache line becomes a more complex operation, since we can't reuse the cache line without first writing its contents back to main memory in case they had been modified by an earlier write access."}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "Hmm."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:32", "is_worked_example": false, "text": "Seems like this does a write-back of all replaced cache lines whether or not they've been written to."}, {"start": "00:02:32", "is_lecture": true, "end": "00:02:40", "is_worked_example": false, "text": "We can avoid unnecessary write-backs by adding another state bit to each cache line: the \"dirty\" bit."}, {"start": "00:02:40", "is_lecture": true, "end": "00:02:45", "is_worked_example": false, "text": "The dirty bit is set to 0 when a cache line is filled during a cache miss."}, {"start": "00:02:45", "is_lecture": true, "end": "00:02:57", "is_worked_example": false, "text": "If a subsequent write operation changes the data in a cache line, the dirty bit is set to 1, indicating that value in the cache now differs from the value in main memory."}, {"start": "00:02:57", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "When a cache line is selected for replacement, we only need to write its data back to main memory if its dirty bit is 1."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:19", "is_worked_example": false, "text": "So a write-back strategy with a dirty bit gives an elegant solution that minimizes the number of writes to main memory and only delays the CPU on a cache miss if a dirty cache line needs to be written back to memory."}, {"start": "00:03:19", "is_lecture": true, "end": "00:03:33", "is_worked_example": false, "text": "That concludes our discussion of caches, which was motivated by our desire to minimize the average memory access time by building a hierarchical memory system that had both low latency and high capacity."}, {"start": "00:03:33", "is_lecture": true, "end": "00:03:37", "is_worked_example": false, "text": "There were a number of strategies we employed to achieve our goal."}, {"start": "00:03:37", "is_lecture": true, "end": "00:03:44", "is_worked_example": false, "text": "Increasing the number of cache lines decreases AMAT by decreasing the miss ratio."}, {"start": "00:03:44", "is_lecture": true, "end": "00:03:55", "is_worked_example": false, "text": "Increasing the block size of the cache let us take advantage of the fast column accesses in a DRAM to efficiently load a whole block of data on a cache miss."}, {"start": "00:03:55", "is_lecture": true, "end": "00:04:05", "is_worked_example": false, "text": "The expectation was that this would improve AMAT by increasing the number of hits in the future as accesses were made to nearby locations."}, {"start": "00:04:05", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "Increasing the number of ways in the cache reduced the possibility of cache line conflicts, lowering the miss ratio."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:20", "is_worked_example": false, "text": "Choosing the least-recently used cache line for replacement minimized the impact of replacement on the hit ratio."}, {"start": "00:04:20", "is_lecture": true, "end": "00:04:26", "is_worked_example": false, "text": "And, finally, we chose to handle writes using a write-back strategy with dirty bits."}, {"start": "00:04:26", "is_lecture": true, "end": "00:04:30", "is_worked_example": false, "text": "How do we make the tradeoffs among all these architectural choices?"}, {"start": "00:04:30", "is_lecture": true, "end": "00:04:41", "is_worked_example": false, "text": "As usual, we'll simulate different cache organizations and chose the architectural mix that provides the best performance on our benchmark programs."}]}, "C04S03B07-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c4/c4s1/7?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c4s1v7", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "An interesting question for computer architects is what capabilities must be included in the ISA?"}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "When we studied Boolean gates in Part 1 of the course, we were able to prove that NAND gates were universal, i.e., that we could implement any Boolean function using only circuits constructed from NAND gates."}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "We can ask the corresponding question of our ISA:"}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "is it universal, i.e., can it be used to perform any computation?"}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:32", "is_worked_example": false, "text": "What problems can we solve with a von Neumann computer?"}, {"start": "00:00:32", "is_lecture": true, "end": "00:00:36", "is_worked_example": false, "text": "Can the Beta solve any problem FSMs can solve?"}, {"start": "00:00:36", "is_lecture": true, "end": "00:00:40", "is_worked_example": false, "text": "Are there problems FSMs can't solve?"}, {"start": "00:00:40", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "If so, can the Beta solve those problems?"}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:47", "is_worked_example": false, "text": "Do the answers to these questions depend on the particular ISA?"}, {"start": "00:00:47", "is_lecture": true, "end": "00:00:52", "is_worked_example": false, "text": "To provide some answers, we need a mathematical model of computation."}, {"start": "00:00:52", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "Reasoning about the model, we should be able to prove what can be computed and what can't."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "And hopefully we can ensure that the Beta ISA has the functionality needed to perform any computation."}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "The roots of computer science stem from the evaluation of many alternative mathematical models of computation to determine the classes of computation each could represent."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:24", "is_worked_example": false, "text": "An elusive goal was to find a universal model, capable of representing *all* realizable computations."}, {"start": "00:01:24", "is_lecture": true, "end": "00:01:35", "is_worked_example": false, "text": "In other words if a computation could be described using some other well-formed model, we should also be able to describe the same computation using the universal model."}, {"start": "00:01:35", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "One candidate model might be finite state machines (FSMs), which can be built using sequential logic."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:55", "is_worked_example": false, "text": "Using Boolean logic and state transition diagrams we can reason about how an FSM will operate on any given input, predicting the output with 100% certainty."}, {"start": "00:01:55", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "Are FSMs the universal digital computing device?"}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "In other words, can we come up with FSM implementations that implement all computations that can be solved by any digital device?"}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:16", "is_worked_example": false, "text": "Despite their usefulness and flexibility, there are common problems that cannot be solved by any FSM."}, {"start": "00:02:16", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "For example, can we build an FSM to determine if a string of parentheses (properly encoded into a binary sequence) is well-formed?"}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "A parenthesis string is well-formed if the parentheses balance, i.e., for every open parenthesis there is a matching close parenthesis later in the string."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "In the example shown here, the input string on the top is well-formed, but the input string on the bottom is not."}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:53", "is_worked_example": false, "text": "After processing the input string, the FSM would output a 1 if the string is well-formed, 0 otherwise."}, {"start": "00:02:53", "is_lecture": true, "end": "00:02:57", "is_worked_example": false, "text": "Can this problem be solved using an FSM?"}, {"start": "00:02:57", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "No, it can't."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "The difficulty is that the FSM uses its internal state to encode what it knows about the history of the inputs."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:18", "is_worked_example": false, "text": "In the paren checker, the FSM would need to count the number of unbalanced open parens seen so far, so it can determine if future input contains the required number of close parens."}, {"start": "00:03:18", "is_lecture": true, "end": "00:03:27", "is_worked_example": false, "text": "But in a finite state machine there are only a fixed number of states, so a particular FSM has a maximum count it can reach."}, {"start": "00:03:27", "is_lecture": true, "end": "00:03:38", "is_worked_example": false, "text": "If we feed the FSM an input with more open parens than it has the states to count, it won't be able to check if the input string is well-formed."}, {"start": "00:03:38", "is_lecture": true, "end": "00:03:45", "is_worked_example": false, "text": "The \"finite-ness\" of FSMs limits their ability to solve problems that require unbounded counting."}, {"start": "00:03:45", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "Hmm, what other models of computation might we consider?"}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:57", "is_worked_example": false, "text": "Mathematics to the rescue, in this case in the form of a British mathematician named Alan Turing."}, {"start": "00:03:57", "is_lecture": true, "end": "00:04:06", "is_worked_example": false, "text": "In the early 1930's Alan Turing was one of many mathematicians studying the limits of proof and computation."}, {"start": "00:04:06", "is_lecture": true, "end": "00:04:18", "is_worked_example": false, "text": "He proposed a conceptual model consisting of an FSM combined with a infinite digital tape that could read and written under the control of the FSM."}, {"start": "00:04:18", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "The inputs to some computation would be encoded as symbols on the tape, then the FSM would read the tape, changing its state as it performed the computation, then write the answer onto the tape and finally halting."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:36", "is_worked_example": false, "text": "Nowadays, this model is called a Turing Machine (TM)."}, {"start": "00:04:36", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "Turing Machines, like other models of the time, solved the \"finite\" problem of FSMs."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:47", "is_worked_example": false, "text": "So how does all this relate to computation?"}, {"start": "00:04:47", "is_lecture": true, "end": "00:04:56", "is_worked_example": false, "text": "Assuming the non-blank input on the tape occupies a finite number of adjacent cells, it can be expressed as a large integer."}, {"start": "00:04:56", "is_lecture": true, "end": "00:05:07", "is_worked_example": false, "text": "Just construct a binary number using the bit encoding of the symbols from the tape, alternating between symbols to the left of the tape head and symbols to the right of the tape head."}, {"start": "00:05:07", "is_lecture": true, "end": "00:05:13", "is_worked_example": false, "text": "Eventually all the symbols will be incorporated into the (very large) integer representation."}, {"start": "00:05:13", "is_lecture": true, "end": "00:05:27", "is_worked_example": false, "text": "So both the input and output of the TM can be thought of as large integers, and the TM itself as implementing an integer function that maps input integers to output integers."}, {"start": "00:05:27", "is_lecture": true, "end": "00:05:33", "is_worked_example": false, "text": "The FSM brain of the Turing Machine can be characterized by its truth table."}, {"start": "00:05:33", "is_lecture": true, "end": "00:05:42", "is_worked_example": false, "text": "And we can systematically enumerate all the possible FSM truth tables, assigning an index to each truth table as it appears in the enumeration."}, {"start": "00:05:42", "is_lecture": true, "end": "00:05:51", "is_worked_example": false, "text": "Note that indices get very large very quickly since they essentially incorporate all the information in the truth table."}, {"start": "00:05:51", "is_lecture": true, "end": "00:05:55", "is_worked_example": false, "text": "Fortunately we have a very large supply of integers!"}, {"start": "00:05:55", "is_lecture": true, "end": "00:06:02", "is_worked_example": false, "text": "We'll use the index for a TM's FSM to identify the TM as well."}, {"start": "00:06:02", "is_lecture": true, "end": "00:06:11", "is_worked_example": false, "text": "So we can talk about TM 347 running on input 51, producing the answer 42."}]}, "C07S01B05-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c7/c7s1/5?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c7s1v5", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "Okay, here's our final contract for how procedure calls will work:"}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "The calling procedure (\"caller\") will"}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:11", "is_worked_example": false, "text": "PUSH the argument values onto the stack in reverse order"}, {"start": "00:00:11", "is_lecture": true, "end": "00:00:16", "is_worked_example": false, "text": "Branch to the entry point of the callee, putting the return address into the linkage pointer."}, {"start": "00:00:16", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "When the callee returns, remove the argument values from the stack."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:25", "is_worked_example": false, "text": "The called procedure (\"callee\") will"}, {"start": "00:00:25", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "Perform the promised computation, leaving the result in R0."}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "Jump to the return address when the computation has finished"}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:40", "is_worked_example": false, "text": "Remove any items it has placed on the stack, leaving the stack as it was when the procedure was entered."}, {"start": "00:00:40", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "Note that the arguments were PUSHed on the stack by the caller, so it will be up to the caller to remove them."}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:52", "is_worked_example": false, "text": "Preserve the values in all registers except R0, which holds the return value."}, {"start": "00:00:52", "is_lecture": true, "end": "00:01:00", "is_worked_example": false, "text": "So the caller can assume any values placed in registers before a nested call will be there when the nested call returns."}, {"start": "00:01:00", "is_lecture": true, "end": "00:01:06", "is_worked_example": false, "text": "We saw the code template for procedure calls on an earlier slide."}, {"start": "00:01:06", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "Here's the template for the entry point to a procedure F."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:22", "is_worked_example": false, "text": "The code saves the caller's LP and BP values, initializes BP for the current stack frame and allocates words on the stack to hold any local variable values."}, {"start": "00:01:22", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "The final step is to PUSH the value of any registers (besides R0) that will be used by the remainder of the procedure's code."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:39", "is_worked_example": false, "text": "The template for the exit sequence mirrors the actions of the entry sequence, restoring all the values saved by the entry sequence,"}, {"start": "00:01:39", "is_lecture": true, "end": "00:01:45", "is_worked_example": false, "text": "performing the POP operations in the reverse of the order of the PUSH operations in the entry sequence."}, {"start": "00:01:45", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "Note that in moving the BP value into SP we've reset the stack to its state at the point of the MOVE(SP,BP) in the entry sequence."}, {"start": "00:01:56", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "This implicitly undoes the effect of the ALLOCATE statement in the entry sequence, so we don't need a matching DEALLOCATE in the exit sequence."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "The last instruction in the exit sequence transfers control back to the calling procedure."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "With practice you'll become familiar with these code templates."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:20", "is_worked_example": false, "text": "Meanwhile, you can refer back to this slide whenever you need to generate code for a procedure call."}, {"start": "00:02:20", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "Here's the code our compiler would generate for the C implementation of factorial shown on the left."}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:34", "is_worked_example": false, "text": "The entry sequence saves the caller's LP and BP, then initializes BP for the current stack frame."}, {"start": "00:02:34", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "The value of R1 is saved so we can use R1 in code that follows."}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:44", "is_worked_example": false, "text": "The exit sequence restores all the saved values, including that for R1."}, {"start": "00:02:44", "is_lecture": true, "end": "00:02:52", "is_worked_example": false, "text": "The code for the body of the procedure has arranged for R0 to contain the return value by the time execution reaches the exit sequence."}, {"start": "00:02:52", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "The nested procedure call passes the argument value on the stack and removes it after the nested call returns."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "The remainder of the code is generated using the templates we saw in the previous lecture."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "Aside from computing and pushing the values of the arguments, there are approximately 10 instructions needed to implement the linking approach to a procedure call."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:21", "is_worked_example": false, "text": "That's not much for a procedure of any size, but might be significant for a trivial procedure."}, {"start": "00:03:21", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "As mentioned earlier, some optimizing compilers can make the tradeoff of inlining small non-recursive procedures saving this small amount of overhead."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:37", "is_worked_example": false, "text": "So have we solved the activation record storage issue for recursive procedures?"}, {"start": "00:03:37", "is_lecture": true, "end": "00:03:42", "is_worked_example": false, "text": "Yes!  A new stack from is allocated for each procedure call."}, {"start": "00:03:42", "is_lecture": true, "end": "00:03:46", "is_worked_example": false, "text": "In each frame we see the storage for the argument and return address."}, {"start": "00:03:46", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "And as the nested calls return the stack frames will be deallocated in inverse order."}, {"start": "00:03:52", "is_lecture": true, "end": "00:03:59", "is_worked_example": false, "text": "Interestingly we can learn a lot about the current state of execution by looking at the active stack frames."}, {"start": "00:03:59", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "The current value of BP, along the older values saved in the activation records, allow us to identify the active procedure calls and determine their arguments, the values of any local variables for active calls, and so on."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:22", "is_worked_example": false, "text": "If we print out all this information at any given time we would have a \"stack trace\" showing the progress of the computation."}, {"start": "00:04:22", "is_lecture": true, "end": "00:04:31", "is_worked_example": false, "text": "In fact, when an problem occurs, many language runtimes will print out that stack trace to help the programmer determine what happened."}, {"start": "00:04:31", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "And, of course, if you can interpret the information in the stack frames, you can show you understand our conventions for procedure call and return."}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "Don't be surprised to find such a question on a quiz :)"}]}, "C11S01B04-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/4?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v4", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "Non-volatile memories are used to maintain system state even when the system is powered down."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:15", "is_worked_example": false, "text": "In flash memories, long-term storage is achieved by storing charge on an well-insulated conductor called a floating gate, where it will remain stable for years."}, {"start": "00:00:15", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "The floating gate is incorporated in a standard MOSFET, placed between the MOSFET's gate and the MOSFET's channel."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:39", "is_worked_example": false, "text": "If there is no charge stored on the floating gate, the MOSFET can be turned on, i.e., be made to conduct, by placing a voltage V_1 on the gate terminal, creating an inversion layer that connects the MOSFET's source and drain terminals."}, {"start": "00:00:39", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "If there is a charge stored on the floating gate, a higher voltage V_2 is required to turn on the MOSFET."}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:56", "is_worked_example": false, "text": "By setting the gate terminal to a voltage between V_1 and V_2, we can determine if the floating gate is charged by testing to see if the MOSFET is conducting."}, {"start": "00:00:56", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "In fact, if we can measure the current flowing through the MOSFET, we can determine how much charge is stored on the floating gate, making it possible to store multiple bits of information in one flash cell by varying the amount of charge on its floating gate."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:24", "is_worked_example": false, "text": "Flash cells can be connected in parallel or series to form circuits resembling CMOS NOR or NAND gates, allowing for a variety of access architectures suitable for either random or sequential access."}, {"start": "00:01:24", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "Flash memories are very dense, approaching the areal density of DRAMs, particularly when each cell holds multiple bits of information."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "Read access times for NOR flash memories are similar to that of DRAMs, several tens of nanoseconds."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "Read times for NAND flash memories are much longer, on the order of 10 microseconds."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "Write times for all types of flash memories are quite long since high voltages have to be used to force electrons to cross the insulating barrier surrounding the floating gate."}, {"start": "00:01:56", "is_lecture": true, "end": "00:02:07", "is_worked_example": false, "text": "Flash memories can only be written some number of times before the insulating layer is damaged to the point that the floating gate will no longer reliably store charge."}, {"start": "00:02:07", "is_lecture": true, "end": "00:01:00", "is_worked_example": false, "text": "Currently the number of guaranteed writes varies between 100,000 and"}, {"start": "00:02:12", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "To work around this limitation, flash chips contain clever address mapping algorithms so that writes to the same address actually are mapped to different flash cells on each successive write."}, {"start": "00:02:24", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "The bottom line is that flash memories are a higher-performance but higher-cost replacement for the hard-disk drive, the long-time technology of choice for non-volatile storage."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "A hard-disk drive (HDD) contains one or more rotating platters coated with a magnetic material."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:48", "is_worked_example": false, "text": "The platters rotate at speeds ranging from 5400 to 15000 RPM."}, {"start": "00:02:48", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "A read/write head positioned above the surface of a platter can detect or change the orientation of the magnetization of the magnetic material below."}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "The read/write head is mounted an actuator that allows it to be positioned over different circular tracks."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:16", "is_worked_example": false, "text": "To read a particular sector of data, the head must be positioned radially over the correct track, then wait for the platter to rotate until it's over the desired sector."}, {"start": "00:03:16", "is_lecture": true, "end": "00:03:25", "is_worked_example": false, "text": "The average total time required to correctly position the head is on the order of 10 milliseconds, so hard disk access times are quite long."}, {"start": "00:03:25", "is_lecture": true, "end": "00:03:33", "is_worked_example": false, "text": "However, once the read/write head is in the correct position, data can be transferred at the respectable rate of 100 megabytes/second."}, {"start": "00:03:33", "is_lecture": true, "end": "00:03:43", "is_worked_example": false, "text": "If the head has to be repositioned between each access, the effective transfer rate drops 1000-fold, limited by the time it takes to reposition the head."}, {"start": "00:03:43", "is_lecture": true, "end": "00:03:53", "is_worked_example": false, "text": "Hard disk drives provide cost-effective non-volatile storage for terabytes of data, albeit at the cost of slow access times."}, {"start": "00:03:53", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "This completes our whirlwind tour of memory technologies."}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "If you'd like to learn a bit more, Wikipedia has useful articles on each type of device."}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:09", "is_worked_example": false, "text": "SRAM sizes and access times have kept pace with the improvements in the size and speed of integrated circuits."}, {"start": "00:04:09", "is_lecture": true, "end": "00:04:19", "is_worked_example": false, "text": "Interestingly, although capacities and transfer rates for DRAMs and HDDs have improved, their initial access times have not improved nearly as rapidly."}, {"start": "00:04:19", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "Thankfully over the past decade flash memories have helped to fill the performance gap between processor speeds and HDDs."}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:39", "is_worked_example": false, "text": "But the gap between processor cycle times and DRAM access times has continued to widen, increasing the challenge of designing low-latency high-capacity memory systems."}, {"start": "00:04:39", "is_lecture": true, "end": "00:04:49", "is_worked_example": false, "text": "The capacity of the available memory technologies varies over 10 orders of magnitude, and the variation in latencies varies over 8 orders of magnitude."}, {"start": "00:04:49", "is_lecture": true, "end": "00:04:56", "is_worked_example": false, "text": "This creates a considerable challenge in figuring out how to navigate the speed vs size tradeoffs."}, {"start": "00:04:56", "is_lecture": true, "end": "00:05:05", "is_worked_example": false, "text": "Each transition in memory hierarchy shows the same fundamental design choice: we can pick smaller-and-faster or larger-and-slower."}, {"start": "00:05:05", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "This is a bit awkward actually -- can we figure how to get the best of both worlds?"}, {"start": "00:05:10", "is_lecture": true, "end": "00:05:16", "is_worked_example": false, "text": "We want our system to behave as if it had a large, fast, and cheap main memory."}, {"start": "00:05:16", "is_lecture": true, "end": "00:05:21", "is_worked_example": false, "text": "Clearly we can't achieve this goal using any single memory technology."}, {"start": "00:05:21", "is_lecture": true, "end": "00:05:32", "is_worked_example": false, "text": "Here's an idea: can we use a hierarchical system of memories with different tradeoffs to achieve close to the same results as a large, fast, cheap memory?"}, {"start": "00:05:32", "is_lecture": true, "end": "00:05:40", "is_worked_example": false, "text": "Could we arrange for memory locations we're using often to be stored, say, in SRAM and have those accesses be low latency?"}, {"start": "00:05:40", "is_lecture": true, "end": "00:05:47", "is_worked_example": false, "text": "Could the rest of the data could be stored in the larger and slower memory components, moving the between the levels when necessary?"}, {"start": "00:05:47", "is_lecture": true, "end": "00:05:51", "is_worked_example": false, "text": "Let's follow this train of thought and see where it leads us."}, {"start": "00:05:51", "is_lecture": true, "end": "00:05:54", "is_worked_example": false, "text": "There are two approaches we might take."}, {"start": "00:05:54", "is_lecture": true, "end": "00:06:05", "is_worked_example": false, "text": "The first is to expose the hierarchy, providing some amount of each type of storage and let the programmer decide how best to allocate the various memory resources for each particular computation."}, {"start": "00:06:05", "is_lecture": true, "end": "00:06:16", "is_worked_example": false, "text": "The programmer would write code that moved data into fast storage when appropriate, then back to the larger and slower memories when low-latency access was no longer required."}, {"start": "00:06:16", "is_lecture": true, "end": "00:06:25", "is_worked_example": false, "text": "There would only be a small amount of the fastest memory, so data would be constantly in motion as the focus of the computation changed."}, {"start": "00:06:25", "is_lecture": true, "end": "00:06:29", "is_worked_example": false, "text": "This approach has had notable advocates."}, {"start": "00:06:29", "is_lecture": true, "end": "00:06:34", "is_worked_example": false, "text": "Perhaps the most influential was Seymour Cray, the \"Steve Jobs\" of supercomputers."}, {"start": "00:06:34", "is_lecture": true, "end": "00:06:45", "is_worked_example": false, "text": "Cray was the architect of the world's fastest computers in each of three decades, inventing many of the technologies that form the foundation of high-performance computing."}, {"start": "00:06:45", "is_lecture": true, "end": "00:06:55", "is_worked_example": false, "text": "His insight to managing the memory hierarchy was to organize data as vectors and move vectors in and out of fast memory under program control."}, {"start": "00:06:55", "is_lecture": true, "end": "00:07:05", "is_worked_example": false, "text": "This was actually a good data abstraction for certain types of scientific computing and his vector machines had the top computing benchmarks for many years."}, {"start": "00:07:05", "is_lecture": true, "end": "00:07:14", "is_worked_example": false, "text": "The second alternative is to hide the hierarchy and simply tell the programmer they have a large, uniform address space to use as they wish."}, {"start": "00:07:14", "is_lecture": true, "end": "00:07:24", "is_worked_example": false, "text": "The memory system would, behind the scenes, move data between the various levels of the memory hierarchy, depending on the usage patterns it detected."}, {"start": "00:07:24", "is_lecture": true, "end": "00:07:34", "is_worked_example": false, "text": "This would require circuitry to examine each memory access issued by the CPU to determine where in the hierarchy to find the requested location."}, {"start": "00:07:34", "is_lecture": true, "end": "00:07:41", "is_worked_example": false, "text": "And then, if a particular region of addresses was frequently accessed -- say, when fetching instructions in a loop --"}, {"start": "00:07:41", "is_lecture": true, "end": "00:07:49", "is_worked_example": false, "text": "the memory system would arrange for those accesses to be mapped to the fastest memory component and automatically move the loop instructions there."}, {"start": "00:07:49", "is_lecture": true, "end": "00:07:59", "is_worked_example": false, "text": "All of this machinery would be transparent to the programmer: the program would simply fetch instructions and access data and the memory system would handle the rest."}, {"start": "00:07:59", "is_lecture": true, "end": "00:08:06", "is_worked_example": false, "text": "Could the memory system automatically arrange for the right data to be in the right place at the right time?"}, {"start": "00:08:06", "is_lecture": true, "end": "00:08:10", "is_worked_example": false, "text": "Cray was deeply skeptical of this approach."}, {"start": "00:08:10", "is_lecture": true, "end": "00:08:13", "is_worked_example": false, "text": "He famously quipped \"that you can't fake what you haven't got\"."}, {"start": "00:08:13", "is_lecture": true, "end": "00:08:23", "is_worked_example": false, "text": "Wouldn't the programmer, with her knowledge of how data was going to be used by a particular program, be able to do a better job by explicitly managing the memory hierarchy?"}, {"start": "00:08:23", "is_lecture": true, "end": "00:08:37", "is_worked_example": false, "text": "It turns out that when running general-purpose programs, it is possible to build an automatically managed, low-latency, high-capacity hierarchical memory system that appears as one large, uniform memory."}, {"start": "00:08:37", "is_lecture": true, "end": "00:08:40", "is_worked_example": false, "text": "What's the insight that makes this possible?"}, {"start": "00:08:40", "is_lecture": true, "end": "00:08:43", "is_worked_example": false, "text": "That's the topic of the next section."}]}, "C09S01B03-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c9/c9s1/3?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c9s1v3", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "The LD and ST instructions access main memory."}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:13", "is_worked_example": false, "text": "Note that its the same main memory that holds the instructions, even though for drafting convenience we show it has two separate boxes in our datapath diagram."}, {"start": "00:00:13", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "In the form we show it here, main memory has three ports:"}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "two read ports for fetching instructions and reading load data, and one write port used by the ST instruction to write data into main memory."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "The address calculation is exactly the same computation as performed by the ADDC instruction:"}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:41", "is_worked_example": false, "text": "the contents of the RA register are added to the sign-extended 16-bit literal from the low-order 16 bits of the instruction."}, {"start": "00:00:41", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "So we'll simply reuse the existing datapath hardware to compute the address."}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:55", "is_worked_example": false, "text": "For the LD instruction the output of the ALU is routed to main memory as the address of the location we wish to access."}, {"start": "00:00:55", "is_lecture": true, "end": "00:01:08", "is_worked_example": false, "text": "After the memory's propagation delay, the contents of the addressed location is returned by the memory and we need to route that back to the register file to be written into the RC register."}, {"start": "00:01:08", "is_lecture": true, "end": "00:01:18", "is_worked_example": false, "text": "The memory has two control signals: MOE (memory output enable), which we set to 1 when we want to read a value from the memory."}, {"start": "00:01:18", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "And MWE (memory write enable) which is set to 1 when we want main memory to store the value on its write data (WD) port into the addressed memory location."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "We need to add another MUX to select which value to write back to the register file: the output of the ALU or the data returning from main memory."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:47", "is_worked_example": false, "text": "We've used a 3-to-1 MUX and we'll see the use for the other MUX input when we get to the implementation of branches and jumps."}, {"start": "00:01:47", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "The two-bit WDSEL signal is used to select the source of the write-back value."}, {"start": "00:01:53", "is_lecture": true, "end": "00:01:59", "is_worked_example": false, "text": "Let's follow the flow of data when executing the LD instruction."}, {"start": "00:01:59", "is_lecture": true, "end": "00:02:07", "is_worked_example": false, "text": "The ALU operands are chosen just as they are for the ADDC instruction and the ALU is requested to perform an ADD operation."}, {"start": "00:02:07", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "The ALU result is connected to the address port of main memory, who's control signals are set for a read operation."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:22", "is_worked_example": false, "text": "The WDSEL control signals are set to 2 to route the returning data to the register file."}, {"start": "00:02:22", "is_lecture": true, "end": "00:02:29", "is_worked_example": false, "text": "Execution of the ST instruction is very similar to the execution of the LD instruction, with one extra complication."}, {"start": "00:02:29", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "The value to be written to memory comes from the RC register, but the RC instruction field is not connected a register file read address."}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:47", "is_worked_example": false, "text": "Happily, the RB register address isn't being used by the ST instruction since the second ALU operand comes from the literal field."}, {"start": "00:02:47", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "So we'll use a MUX to enable the RC field to be selected as the address for the register file's second read port."}, {"start": "00:02:55", "is_lecture": true, "end": "00:03:01", "is_worked_example": false, "text": "When the RA2SEL control signal is 0, the RB field is selected as the address."}, {"start": "00:03:01", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "When RA2SEL is 1, the RC field is selected."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:11", "is_worked_example": false, "text": "The output from the second read data port is connected to the write data port of main memory."}, {"start": "00:03:11", "is_lecture": true, "end": "00:03:18", "is_worked_example": false, "text": "The ST instruction is the only instruction that does not write a result into the register file."}, {"start": "00:03:18", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "So the WERF control signal will be 0 when executing ST."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:27", "is_worked_example": false, "text": "Here's the flow of data when executing ST."}, {"start": "00:03:27", "is_lecture": true, "end": "00:03:35", "is_worked_example": false, "text": "The operands are selected as for LD and the ALU performs the address computation with the result sent to main memory as the address."}, {"start": "00:03:35", "is_lecture": true, "end": "00:03:47", "is_worked_example": false, "text": "Meanwhile the RC field is selected as the address for the second register file read port and the value from the RC register becomes the write data for main memory."}, {"start": "00:03:47", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "By setting the MWR control signal to 1, the main memory will write the WD data into the selected memory location at the end of the cycle."}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:03", "is_worked_example": false, "text": "The WERF control signal is set to zero since we won't be writing a value into the register file."}, {"start": "00:04:03", "is_lecture": true, "end": "00:04:08", "is_worked_example": false, "text": "And, since we're not writing to the register file, we don't care about the value for the WDSEL signal."}, {"start": "00:04:08", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "Of course, the logic will need to supply some value for WDSEL."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:20", "is_worked_example": false, "text": "The \"don't care\" annotation is telling the logic designer that she's welcome to supply whatever value is most convenient."}, {"start": "00:04:20", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "This is particularly useful when using Karnaugh maps to optimize the control logic, where the value can be chosen as either 0 or 1, whichever results in the best minimization of the logic equations."}]}, "C06S01B01-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c6/c6s1/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c6s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "Today we're going to talk about how to translate high-level languages into code that computers can execute."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:14", "is_worked_example": false, "text": "So far we've seen the Beta ISA, which includes instructions that control the datapath operations performed on 32-bit data stored in the registers."}, {"start": "00:00:14", "is_lecture": true, "end": "00:00:19", "is_worked_example": false, "text": "There are also instructions for accessing main memory and changing the program counter."}, {"start": "00:00:19", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "The instructions are formatted as opcode, source, and destination fields that form 32-bit values in main memory."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "To make our lives easier, we developed assembly language as a way of specifying sequences of instructions."}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:38", "is_worked_example": false, "text": "Each assembly language statement corresponds to a single instruction."}, {"start": "00:00:38", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "As assembly language programmers, we're responsible for managing which values are in registers and which are in main memory, and we need to figure out how to break down complicated operations,"}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:54", "is_worked_example": false, "text": "e.g., accessing an element of an array, into the right sequence of Beta operations."}, {"start": "00:00:54", "is_lecture": true, "end": "00:01:01", "is_worked_example": false, "text": "We can go one step further and use high-level languages to describe the computations we want to perform."}, {"start": "00:01:01", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "These languages use variables and other data structures to abstract away the details of storage allocation and the movement of data to and from main memory."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "We can just refer to a data object by name and let the language processor handle the details."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:26", "is_worked_example": false, "text": "Similarly, we'll write expressions and other operators such as assignment (=) to efficiently describe what would require many statements in assembly language."}, {"start": "00:01:26", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "Today we're going to dive into how to translate high-level language programs into code that will run on the Beta."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "Here we see Euclid's algorithm for determining the greatest common divisor of two numbers, in this case the algorithm is written in the C programming language."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:47", "is_worked_example": false, "text": "We'll be using a simple subset of C as our example high-level language."}, {"start": "00:01:47", "is_lecture": true, "end": "00:01:54", "is_worked_example": false, "text": "Please see the brief overview of C in the Handouts section if you'd like an introduction to C syntax and semantics."}, {"start": "00:01:54", "is_lecture": true, "end": "00:02:03", "is_worked_example": false, "text": "C was developed by Dennis Ritchie at AT&T Bell Labs in the late 60's and early 70's to use when implementing the Unix operating system."}, {"start": "00:02:03", "is_lecture": true, "end": "00:02:14", "is_worked_example": false, "text": "Since that time many new high-level languages have been introduced providing modern abstractions like object-oriented programming along with useful new data and control structures."}, {"start": "00:02:14", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "Using C allows us describe a computation without referring to any of the details of the Beta ISA like registers, specific Beta instructions, and so on."}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "The absence of such details means there is less work required to create the program and makes it easier for others to read and understand the algorithm implemented by the program."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:40", "is_worked_example": false, "text": "There are many advantages to using a high-level language."}, {"start": "00:02:40", "is_lecture": true, "end": "00:02:45", "is_worked_example": false, "text": "They enable programmers to be very productive since the programs are concise and readable."}, {"start": "00:02:45", "is_lecture": true, "end": "00:02:49", "is_worked_example": false, "text": "These attributes also make it easy to maintain the code."}, {"start": "00:02:49", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "Often it is harder to make certain types of mistakes since the language allows us to check for silly errors like storing a string value into a numeric variable."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:07", "is_worked_example": false, "text": "And more complicated tasks like dynamically allocating and deallocating storage can be completely automated."}, {"start": "00:03:07", "is_lecture": true, "end": "00:03:15", "is_worked_example": false, "text": "The result is that it can take much less time to create a correct program in a high-level language than it would it when writing in assembly language."}, {"start": "00:03:15", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "Since the high-level language has abstracted away the details of a particular ISA, the programs are portable in the sense that we can expect to run the same code on different ISAs without having to rewrite the code."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "What do we lose by using a high-level language?"}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:42", "is_worked_example": false, "text": "Should we worry that we'll pay a price in terms of the efficiency and performance we might get by crafting each instruction by hand?"}, {"start": "00:03:42", "is_lecture": true, "end": "00:03:46", "is_worked_example": false, "text": "The answer depends on how we choose to run high-level language programs."}, {"start": "00:03:46", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "The two basic execution strategies are \"interpretation\" and \"compilation\"."}, {"start": "00:03:52", "is_lecture": true, "end": "00:04:00", "is_worked_example": false, "text": "To interpret a high-level language program, we'll write a special program called an \"interpreter\" that runs on the actual computer, M1."}, {"start": "00:04:00", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "The interpreter mimics the behavior of some abstract easy-to-program machine M2 and for each M2 operation executes sequences of M1 instructions to achieve the desired result."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "We can think of the interpreter along with M1 as an implementation of M2, i.e., given a program written for M2, the interpreter will, step-by-step, emulate the effect of M2 instructions."}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "We often use several layers of interpretation when tackling computation tasks."}, {"start": "00:04:33", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "For example, an engineer may use her laptop with an Intel CPU to run the Python interpreter."}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:49", "is_worked_example": false, "text": "In Python, she loads the SciPy toolkit, which provides a calculator-like interface for numerical analysis for matrices and data."}, {"start": "00:04:49", "is_lecture": true, "end": "00:05:02", "is_worked_example": false, "text": "For each SciPy command, e.g., \"find the maximum value of a dataset\", the SciPy tool kit executes many Python statements, e.g., to loop over each element of the array, remembering the largest value."}, {"start": "00:05:02", "is_lecture": true, "end": "00:05:12", "is_worked_example": false, "text": "For each Python statement, the Python interpreter executes many x86 instructions, e.g., to increment the loop index and check for loop termination."}, {"start": "00:05:12", "is_lecture": true, "end": "00:05:23", "is_worked_example": false, "text": "Executing a single SciPy command may require executing of tens of Python statements, which in turn each may require executing hundreds of x86 instructions."}, {"start": "00:05:23", "is_lecture": true, "end": "00:05:29", "is_worked_example": false, "text": "The engineer is very happy she didn't have to write each of those instructions herself!"}, {"start": "00:05:29", "is_lecture": true, "end": "00:05:44", "is_worked_example": false, "text": "Interpretation is an effective implementation strategy when performing a computation once, or when exploring which computational approach is most effective before making a more substantial investment in creating a more efficient implementation."}, {"start": "00:05:44", "is_lecture": true, "end": "00:05:57", "is_worked_example": false, "text": "We'll use a compilation implementation strategy when we have computational tasks that we need to execute repeatedly and hence we are willing to invest more time up-front for more efficiency in the long-term."}, {"start": "00:05:57", "is_lecture": true, "end": "00:06:01", "is_worked_example": false, "text": "In compilation, we also start with our actual computer M1."}, {"start": "00:06:01", "is_lecture": true, "end": "00:06:09", "is_worked_example": false, "text": "Then we'll take our high-level language program P2 and translate it statement-by-statement into a program for M1."}, {"start": "00:06:09", "is_lecture": true, "end": "00:06:12", "is_worked_example": false, "text": "Note that we're not actually running the P2 program."}, {"start": "00:06:12", "is_lecture": true, "end": "00:06:19", "is_worked_example": false, "text": "Instead we're using it as a template to create an equivalent P1 program that can execute directly on M1."}, {"start": "00:06:19", "is_lecture": true, "end": "00:06:27", "is_worked_example": false, "text": "The translation process is called \"compilation\" and the program that does the translation is called a \"compiler\"."}, {"start": "00:06:27", "is_lecture": true, "end": "00:06:36", "is_worked_example": false, "text": "We compile the P2 program once to get the translation P1, and then we'll run P1 on M1 whenever we want to execute P2."}, {"start": "00:06:36", "is_lecture": true, "end": "00:06:45", "is_worked_example": false, "text": "Running P1 avoids the overhead of having to process the P2 source and the costs of executing any intervening layers of interpretation."}, {"start": "00:06:45", "is_lecture": true, "end": "00:06:52", "is_worked_example": false, "text": "Instead of dynamically figuring out the necessary machine instructions for each P2 statement as it's encountered,"}, {"start": "00:06:52", "is_lecture": true, "end": "00:06:59", "is_worked_example": false, "text": "in effect we've arranged to capture that stream of machine instructions and save them as a P1 program for later execution."}, {"start": "00:06:59", "is_lecture": true, "end": "00:07:06", "is_worked_example": false, "text": "If we're willing to pay the up-front costs of compilation, we'll get more efficient execution."}, {"start": "00:07:06", "is_lecture": true, "end": "00:07:15", "is_worked_example": false, "text": "And, with different compilers, we can arrange to run P2 on many different machines -- M2, M3, etc. -- without having rewrite P2."}, {"start": "00:07:15", "is_lecture": true, "end": "00:07:24", "is_worked_example": false, "text": "So we now have two ways to execute a high-level language program: interpretation and compilation."}, {"start": "00:07:24", "is_lecture": true, "end": "00:07:27", "is_worked_example": false, "text": "Both allow us to change the original source program."}, {"start": "00:07:27", "is_lecture": true, "end": "00:07:32", "is_worked_example": false, "text": "Both allow us to abstract away the details of the actual computer we'll use to run the program."}, {"start": "00:07:32", "is_lecture": true, "end": "00:07:36", "is_worked_example": false, "text": "And both strategies are widely used in modern computer systems!"}, {"start": "00:07:36", "is_lecture": true, "end": "00:07:41", "is_worked_example": false, "text": "Let's summarize the differences between interpretation and compilation."}, {"start": "00:07:41", "is_lecture": true, "end": "00:07:46", "is_worked_example": false, "text": "Suppose the statement \"x+2\" appears in the high-level program."}, {"start": "00:07:46", "is_lecture": true, "end": "00:07:53", "is_worked_example": false, "text": "When the interpreter processes this statement it immediately fetches the value of the variable x and adds 2 to it."}, {"start": "00:07:53", "is_lecture": true, "end": "00:08:02", "is_worked_example": false, "text": "On the other hand, the compiler would generate Beta instructions that would LD the variable x into a register and then ADD 2 to that value."}, {"start": "00:08:02", "is_lecture": true, "end": "00:08:14", "is_worked_example": false, "text": "The interpreter is executing each statement as it's processed and, in fact, may process and execute the same statement many times if, e.g., it was in a loop."}, {"start": "00:08:14", "is_lecture": true, "end": "00:08:19", "is_worked_example": false, "text": "The compiler is just generating instructions to be executed at some later time."}, {"start": "00:08:19", "is_lecture": true, "end": "00:08:30", "is_worked_example": false, "text": "Interpreters have the overhead of processing the high-level source code during execution and that overhead may be incurred many times in loops."}, {"start": "00:08:30", "is_lecture": true, "end": "00:08:36", "is_worked_example": false, "text": "Compilers incur the processing overhead once, making the eventual execution more efficient."}, {"start": "00:08:36", "is_lecture": true, "end": "00:08:47", "is_worked_example": false, "text": "But during development, the programmer may have to compile and run the program many times, often incurring the cost of compilation for only a single execution of the program."}, {"start": "00:08:47", "is_lecture": true, "end": "00:08:51", "is_worked_example": false, "text": "So the compile-run-debug loop can take more time."}, {"start": "00:08:51", "is_lecture": true, "end": "00:09:02", "is_worked_example": false, "text": "The interpreter is making decisions about the data type of x and the type of operations necessary at run time, i.e., while the program is running."}, {"start": "00:09:02", "is_lecture": true, "end": "00:09:06", "is_worked_example": false, "text": "The compiler is making those decisions during the compilation process."}, {"start": "00:09:06", "is_lecture": true, "end": "00:09:08", "is_worked_example": false, "text": "Which is the better approach?"}, {"start": "00:09:08", "is_lecture": true, "end": "00:09:14", "is_worked_example": false, "text": "In general, executing compiled code is much faster than running the code interpretively."}, {"start": "00:09:14", "is_lecture": true, "end": "00:09:29", "is_worked_example": false, "text": "But since the interpreter is making decisions at run time, it can change its behavior depending, say, on the type of the data in the variable X, offering considerable flexibility in handling different types of data with the same algorithm."}, {"start": "00:09:29", "is_lecture": true, "end": "00:09:35", "is_worked_example": false, "text": "Compilers take away that flexibility in exchange for fast execution."}]}, "C11S01B02-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/2?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v2", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "SRAMs are organized as an array of memory locations, where a memory access is either reading or writing all the bits in a single location."}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:16", "is_worked_example": false, "text": "Here we see the component layout for a 8-location SRAM array where each location hold 6 bits of data."}, {"start": "00:00:16", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "You can see that the individual bit cells are organized as 8 rows (one row per location) by 6 columns (one column per bit in each memory word)."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:32", "is_worked_example": false, "text": "The circuitry around the periphery is used to decode addresses and support read and write operations."}, {"start": "00:00:32", "is_lecture": true, "end": "00:00:39", "is_worked_example": false, "text": "To access the SRAM, we need provide enough address bits to uniquely specify the location."}, {"start": "00:00:39", "is_lecture": true, "end": "00:00:44", "is_worked_example": false, "text": "In this case we need 3 address bits to select one of the 8 memory locations."}, {"start": "00:00:44", "is_lecture": true, "end": "00:00:55", "is_worked_example": false, "text": "The address decoder logic sets one of the 8 wordlines (the horizontal wires in the array) high to enable a particular row (location) for the upcoming access."}, {"start": "00:00:55", "is_lecture": true, "end": "00:01:00", "is_worked_example": false, "text": "The remaining wordlines are set low, disabling the cells they control."}, {"start": "00:01:00", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "The active wordline enables each of the SRAM bit cells on the selected row, connecting each cell to a pair of bit lines (the vertical wires in the array)."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:21", "is_worked_example": false, "text": "During read operations the bit lines carry the analog signals from the enabled bit cells to the sense amplifiers, which convert the analog signals to digital data."}, {"start": "00:01:21", "is_lecture": true, "end": "00:01:28", "is_worked_example": false, "text": "During write operations incoming data is driven onto the bit lines to be stored into the enabled bit cells."}, {"start": "00:01:28", "is_lecture": true, "end": "00:01:37", "is_worked_example": false, "text": "Larger SRAMs will have a more complex organization in order to minimize the length, and hence the capacitance, of the bit lines."}, {"start": "00:01:37", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "The heart of the SRAM are the bit cells."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "The typical cell has two CMOS inverters wired in a positive feedback loop to create a bistable storage element."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "The diagram on the right shows the two stable configurations."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:54", "is_worked_example": false, "text": "In the top configuration, the cell is storing a \"1\" bit."}, {"start": "00:01:54", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "In the bottom configuration, it's storing a 0 bit."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:09", "is_worked_example": false, "text": "The cell provides stable storage in the sense that as long as there's power, the noise immunity of the inverters will ensure that the logic values will be maintained even if there's electrical noise on either inverter input."}, {"start": "00:02:09", "is_lecture": true, "end": "00:02:16", "is_worked_example": false, "text": "Both sides of the feedback loop are connected via access FETs to the two vertical bit lines."}, {"start": "00:02:16", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "When the wordline connected to the gates of the access FETs is high, the FETs are \"on\", i.e., they will make an electrical connection between the cell's internal circuity and the bitlines."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "When the wordline is low, the access FETs are \"off\" and the bistable feedback loop is isolated from the bitlines and will happily maintain the stored value as long as there's power."}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:51", "is_worked_example": false, "text": "During a read operation, the drivers first recharge all the bitlines to Vdd (i.e., a logical \"1\" value) and then disconnect, leaving the bitlines floating at 1."}, {"start": "00:02:51", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "Then the address decoder sets one of the wordlines high, connecting a row of bit cells to their bitlines."}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:03", "is_worked_example": false, "text": "Each cell in the selected row then pulls one of its two bitlines to GND."}, {"start": "00:03:03", "is_lecture": true, "end": "00:03:06", "is_worked_example": false, "text": "In this example, it's the right bitline that's pulled low."}, {"start": "00:03:06", "is_lecture": true, "end": "00:03:17", "is_worked_example": false, "text": "Transitions on the bitlines are slow since the bitline has a large total capacitance and the MOSFETs in the two inverters are small to keep the cell has small as possible."}, {"start": "00:03:17", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "The large capacitance comes partly from the bitline's length and partly from the diffusion capacitance of the access FETs in other cells in the same column."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "Rather than wait for the bitline to reach a valid logic level, sense amplifiers are used to quickly detect the small voltage difference developing between the two bitlines and generate the appropriate digital output."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:51", "is_worked_example": false, "text": "Since detecting small changes in a voltage is very sensitive to electrical noise, the SRAM uses a pair of bitlines for each bit and a differential sense amplifier to provide greater noise immunity."}, {"start": "00:03:51", "is_lecture": true, "end": "00:04:05", "is_worked_example": false, "text": "As you can see, designing a low-latency SRAM involves a lot of expertise with the analog behavior of MOSFETs and some cleverness to ensure electrical noise will not interfere with the correct operation of the circuitry."}, {"start": "00:04:05", "is_lecture": true, "end": "00:04:10", "is_worked_example": false, "text": "Write operations start by driving the bitlines to the appropriate values."}, {"start": "00:04:10", "is_lecture": true, "end": "00:04:20", "is_worked_example": false, "text": "In the example shown here, we want to write a 0-bit into the cell, so the left bitline is set to GND and the right bitline is set to VDD."}, {"start": "00:04:20", "is_lecture": true, "end": "00:04:28", "is_worked_example": false, "text": "As before, the address decoder then sets one of the wordlines high, selecting all the cells in a particular row for the write operation."}, {"start": "00:04:28", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "The drivers have much larger MOSFETs than those in the cell's inverters, so the internal signals in the enabled cells are forced to the values on the bitlines and the bistable circuits \"flip\" into the new stable configuration."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:52", "is_worked_example": false, "text": "We're basically shorting together the outputs of the driver and the internal inverter, so this is another analog operation!"}, {"start": "00:04:52", "is_lecture": true, "end": "00:04:55", "is_worked_example": false, "text": "This would be a no-no in a strictly digital circuit."}, {"start": "00:04:55", "is_lecture": true, "end": "00:05:04", "is_worked_example": false, "text": "Since n-fets usually carry much higher source-drain currents than p-fets of the same width and given the threshold-drop of the n-fet access transistor,"}, {"start": "00:05:04", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "almost all the work of the write is performed by the large n-fet pulldown transistor connected to the bitline with the 0 value, which easily overpowers the small p-fet pullup of the inverters in the cell."}, {"start": "00:05:17", "is_lecture": true, "end": "00:05:26", "is_worked_example": false, "text": "Again, SRAM designers need a lot of expertise to correctly balance the sizes of MOSFETs to ensure fast and reliable write operations."}, {"start": "00:05:26", "is_lecture": true, "end": "00:05:34", "is_worked_example": false, "text": "It's not hard to augment the SRAM to support multiple read/write ports, a handy addition for register file circuits."}, {"start": "00:05:34", "is_lecture": true, "end": "00:05:40", "is_worked_example": false, "text": "We'll do this by adding additional sets of wordlines, bitlines, drivers, and sense amps."}, {"start": "00:05:40", "is_lecture": true, "end": "00:05:47", "is_worked_example": false, "text": "This will give us multiple paths to independently access the bistable storage elements in the various rows of the memory array."}, {"start": "00:05:47", "is_lecture": true, "end": "00:05:57", "is_worked_example": false, "text": "With an N-port SRAM, for each bit we'll need N wordlines, 2N bitlines and 2N access FETs."}, {"start": "00:05:57", "is_lecture": true, "end": "00:06:10", "is_worked_example": false, "text": "The additional wordlines increase the effective height of the cell and the additional bitlines increase the effective width of the cell and so the area required by all these wires quickly dominates the size of the SRAM."}, {"start": "00:06:10", "is_lecture": true, "end": "00:06:18", "is_worked_example": false, "text": "Since both the height and width of a cell increase when adding ports, the overall area grows as the square of the number of read/write ports."}, {"start": "00:06:18", "is_lecture": true, "end": "00:06:26", "is_worked_example": false, "text": "So one has to take care not to gratuitously add ports lest the cost of the SRAM get out of hand."}, {"start": "00:06:26", "is_lecture": true, "end": "00:06:35", "is_worked_example": false, "text": "In summary, the circuitry for the SRAM is organized as an array of bit cells, with one row for each memory location and one column for each bit in a location."}, {"start": "00:06:35", "is_lecture": true, "end": "00:06:41", "is_worked_example": false, "text": "Each bit is stored by two inverters connected to form a bistable storage element."}, {"start": "00:06:41", "is_lecture": true, "end": "00:06:47", "is_worked_example": false, "text": "Reads and writes are essentially analog operations performed via the bitlines and access FETs."}, {"start": "00:06:47", "is_lecture": true, "end": "00:06:51", "is_worked_example": false, "text": "The SRAM uses 6 MOSFETs for each bit cell."}, {"start": "00:06:51", "is_lecture": true, "end": "00:06:52", "is_worked_example": false, "text": "Can we do better?"}, {"start": "00:06:52", "is_lecture": true, "end": "00:06:58", "is_worked_example": false, "text": "What's the minimum number of MOSFETs needed to store a single bit of information?"}]}, "C11S01B03-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/3?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v3", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:07", "is_worked_example": false, "text": "Well, we'll need at least one MOSFET to serve as the access FET so we can select which bits will be affected by read and write operations."}, {"start": "00:00:07", "is_lecture": true, "end": "00:00:16", "is_worked_example": false, "text": "We can use a simple capacitor for storage, where the value of a stored bit is represented by voltage across the plates of the capacitor."}, {"start": "00:00:16", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "The resulting circuit is termed a dynamic random-access memory (DRAM) cell."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "If the capacitor voltage exceeds a certain threshold, we're storing a \"1\" bit, otherwise we're storing a \"0\"."}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:37", "is_worked_example": false, "text": "The amount of charge on the capacitor, which determines the speed and reliability of reading the stored value, is proportional to the capacitance."}, {"start": "00:00:37", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "We can increase the capacitance by increasing the dielectric constant of the insulating layer between the two plates of the capacitor, increasing the area of the plates, or by decreasing the the distance between the plates."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:52", "is_worked_example": false, "text": "All of these are constantly being improved."}, {"start": "00:00:52", "is_lecture": true, "end": "00:00:56", "is_worked_example": false, "text": "A cross section of a modern DRAM cell is shown here."}, {"start": "00:00:56", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "The capacitor is formed in a large trench dug into the substrate material of the integrated circuit."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:08", "is_worked_example": false, "text": "Increasing the depth of the trench will increase the area of the capacitor plates without increasing the cell's area."}, {"start": "00:01:08", "is_lecture": true, "end": "00:01:17", "is_worked_example": false, "text": "The wordline forms the gate of the N-FET access transistor connecting the outer plate of the capacitor to the bitline."}, {"start": "00:01:17", "is_lecture": true, "end": "00:01:26", "is_worked_example": false, "text": "A very thin insulating layer separates the outer plate from the inner plate, which is connected to some reference voltage (shown as GND in this diagram)."}, {"start": "00:01:26", "is_lecture": true, "end": "00:01:34", "is_worked_example": false, "text": "You can Google \"trench capacitor\" to get the latest information on the dimensions and materials used in the construction of the capacitor."}, {"start": "00:01:34", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "The resulting circuit is quite compact: about 20-times less area/bit than an SRAM bit cell."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "There are some challenges however."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:52", "is_worked_example": false, "text": "There's no circuitry to main the static charge on the capacitor, so stored charge will leak from the outer plate of the capacitor, hence the name \"dynamic memory\"."}, {"start": "00:01:52", "is_lecture": true, "end": "00:02:02", "is_worked_example": false, "text": "The leakage is caused by small picoamp currents through the PN junction with the surrounding substrate, or subthreshold conduction of the access FET even when it's turned \"off\"."}, {"start": "00:02:02", "is_lecture": true, "end": "00:02:09", "is_worked_example": false, "text": "This limits the amount of time we can leave the capacitor unattended and still expect to read the stored value."}, {"start": "00:02:09", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "This means we'll have to arrange to read then re-write each bit cell (called a \"refresh\" cycle) every 10ms or so, adding to the complexity of the DRAM interface circuitry."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:31", "is_worked_example": false, "text": "DRAM write operations are straightforward: simply turn on the access FET with the wordline and charge or discharge the storage capacitor through the bitline."}, {"start": "00:02:31", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "Reads are bit more complicated."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "First the bitline is precharged to some intermediate voltage, e.g., VDD/2, and then the precharge circuitry is disconnected."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:53", "is_worked_example": false, "text": "The wordline is activated, connecting the storage capacitor of the selected cell to the bitline causing the charge on the capacitor to be shared with the charge stored by the capacitance of the bitline."}, {"start": "00:02:53", "is_lecture": true, "end": "00:03:03", "is_worked_example": false, "text": "If the value stored by the cell capacitor is a \"1\", the bitline voltage will increase very slightly (e.g., a few tens of millivolts)."}, {"start": "00:03:03", "is_lecture": true, "end": "00:03:07", "is_worked_example": false, "text": "If the stored value is a \"0\", the bitline voltage will decrease slightly."}, {"start": "00:03:07", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "Sense amplifiers are used to detect this small voltage change to produce a digital output value."}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "This means that read operations wipe out the information stored in the bit cell, which must then be rewritten with the detected value at the end of the read operation."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:33", "is_worked_example": false, "text": "DRAM circuitry is usually organized to have \"wide\" rows, i.e., multiple consecutive locations are read in a single access."}, {"start": "00:03:33", "is_lecture": true, "end": "00:03:38", "is_worked_example": false, "text": "This particular block of locations is selected by the DRAM row address."}, {"start": "00:03:38", "is_lecture": true, "end": "00:03:44", "is_worked_example": false, "text": "Then the DRAM column address is used to select a particular location from the block to be returned."}, {"start": "00:03:44", "is_lecture": true, "end": "00:03:55", "is_worked_example": false, "text": "If we want to read multiple locations in a single row, then we only need to send a new column address and the DRAM will respond with that location without having to access the bit cells again."}, {"start": "00:03:55", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "The first access to a row has a long latency, but subsequent accesses to the same row have very low latency."}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:07", "is_worked_example": false, "text": "As we'll see, we'll be able to use fast column accesses to our advantage."}, {"start": "00:04:07", "is_lecture": true, "end": "00:04:17", "is_worked_example": false, "text": "In summary, DRAM bit cells consist of a single access FET connected to a storage capacitor that's cleverly constructed to take up as little area as possible."}, {"start": "00:04:17", "is_lecture": true, "end": "00:04:31", "is_worked_example": false, "text": "DRAMs must rewrite the contents of bit cells after they are read and every cell must be read and written periodically to ensure that the stored charge is refreshed before it's corrupted by leakage currents."}, {"start": "00:04:31", "is_lecture": true, "end": "00:04:46", "is_worked_example": false, "text": "DRAMs have much higher capacities than SRAMs because of the small size of the DRAM bit cells, but the complexity of the DRAM interface circuitry means that the initial access to a row of locations is quite a bit slower than an SRAM access."}, {"start": "00:04:46", "is_lecture": true, "end": "00:04:52", "is_worked_example": false, "text": "However subsequent accesses to the same row happen at speeds close to that of SRAM accesses."}, {"start": "00:04:52", "is_lecture": true, "end": "00:04:57", "is_worked_example": false, "text": "Both SRAMs and DRAMs will store values as long as their circuitry has power."}, {"start": "00:04:57", "is_lecture": true, "end": "00:05:01", "is_worked_example": false, "text": "But if the circuitry is powered down, the stored bits will be lost."}, {"start": "00:05:01", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "For long-term storage we will need to use non-volatile memory technologies, the topic of the next lecture segment."}]}, "C09S01B01-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c9/c9s1/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c9s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:05", "is_worked_example": false, "text": "Today we're going to describe the datapath and control logic needed to execute Beta instructions."}, {"start": "00:00:05", "is_lecture": true, "end": "00:00:12", "is_worked_example": false, "text": "In an upcoming lab assignment, we'll ask you to build a working implementation using our standard cell library."}, {"start": "00:00:12", "is_lecture": true, "end": "00:00:19", "is_worked_example": false, "text": "When you're done, you'll have designed and debugged a 32-bit reduced-instruction set computer!  Not bad..."}, {"start": "00:00:19", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "Before tackling a design task, it's useful to understand the goals for the design."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:31", "is_worked_example": false, "text": "Functionality, of course; in our case the correct execution of instructions from the Beta ISA."}, {"start": "00:00:31", "is_lecture": true, "end": "00:00:34", "is_worked_example": false, "text": "But there are other goals we should think about."}, {"start": "00:00:34", "is_lecture": true, "end": "00:00:41", "is_worked_example": false, "text": "An obvious goal is to maximize performance, as measured by the number of instructions executed per second."}, {"start": "00:00:41", "is_lecture": true, "end": "00:00:47", "is_worked_example": false, "text": "This is usually expressed in MIPS, an acronym for \"Millions of Instructions Per Second\"."}, {"start": "00:00:47", "is_lecture": true, "end": "00:01:00", "is_worked_example": false, "text": "When the Intel 8080 was introduced in 1974, it executed instructions at 0.29 MIPS or 290,000 instructions per second as measured by the Dhrystone benchmark."}, {"start": "00:01:00", "is_lecture": true, "end": "00:01:06", "is_worked_example": false, "text": "Modern multi-core processors are rated between 10,000 and 100,000 MIPS."}, {"start": "00:01:06", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "Another goal might be to minimize the manufacturing cost, which in integrated circuit manufacturing is proportional to the size of the circuit."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "Or we might want have the best performance for a given price."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:27", "is_worked_example": false, "text": "In our increasingly mobile world, the best performance per watt might be an important goal."}, {"start": "00:01:27", "is_lecture": true, "end": "00:01:25", "is_worked_example": false, "text": "One of the interesting challenges in computer engineering is deciding exactly how to balance performance against cost and power efficiency."}, {"start": "00:01:25", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "Clearly the designers of the Apple Watch have a different set of design goals then the designers of high-end desktop computers."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:49", "is_worked_example": false, "text": "The performance of a processor is inversely proportional to the length of time it takes to run a program."}, {"start": "00:01:49", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "The shorter the execution time, the higher the performance."}, {"start": "00:01:53", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "The execution time is determined by three factors."}, {"start": "00:01:56", "is_lecture": true, "end": "00:01:59", "is_worked_example": false, "text": "First, the number of instructions in the program."}, {"start": "00:01:59", "is_lecture": true, "end": "00:02:06", "is_worked_example": false, "text": "Second, the number of clock cycles our sequential circuit requires to execute a particular instruction."}, {"start": "00:02:06", "is_lecture": true, "end": "00:02:18", "is_worked_example": false, "text": "Complex instructions, e.g., adding two values from main memory, may make a program shorter, but may also require many clock cycles to perform the necessary memory and datapath operations."}, {"start": "00:02:18", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "Third, the amount of time needed for each clock cycle, as determined by the propagation delay of the digital logic in the datapath."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "So to increase the performance we could reduce the number of instructions to be executed."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "Or we can try to minimize the number of clock cycles needed on the average to execute our instructions."}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:43", "is_worked_example": false, "text": "There's obviously a bit of a tradeoff between these first two options:"}, {"start": "00:02:43", "is_lecture": true, "end": "00:02:49", "is_worked_example": false, "text": "more computation per instruction usually means it will take more time to execute the instruction."}, {"start": "00:02:49", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "Or we can try to keep our logic simple, minimizing its propagation delay in the hopes of having a short clock period."}, {"start": "00:02:25", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "Today we'll focus on an implementation for the Beta ISA that executes one instruction every clock cycle."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:16", "is_worked_example": false, "text": "The combinational paths in our circuit will be fairly long, but, as we learned in Part 1 of the course, this gives us the opportunity to use pipelining to increase our implementation's throughput."}, {"start": "00:03:16", "is_lecture": true, "end": "00:03:22", "is_worked_example": false, "text": "We'll talk about the implementation of a pipelined processor in some upcoming lectures."}, {"start": "00:03:22", "is_lecture": true, "end": "00:03:25", "is_worked_example": false, "text": "Here's a quick refresher on the Beta ISA."}, {"start": "00:03:25", "is_lecture": true, "end": "00:03:31", "is_worked_example": false, "text": "The Beta has thirty-two 32-bit registers that hold values for use by the datapath."}, {"start": "00:03:31", "is_lecture": true, "end": "00:03:45", "is_worked_example": false, "text": "The first class of ALU instructions, which have 0b10 as the top 2 bits of the opcode field, perform an operation on two register operands (Ra and Rb), storing the result back into a specified destination register (Rc)."}, {"start": "00:03:45", "is_lecture": true, "end": "00:03:55", "is_worked_example": false, "text": "There's a 6-bit opcode field to specify the operation and three 5-bit register fields to specify the registers to use as source and destination."}, {"start": "00:03:55", "is_lecture": true, "end": "00:04:11", "is_worked_example": false, "text": "The second class of ALU instructions, which have 0b11 in the top 2 bits of the opcode, perform the same set of operations where the second operand is a constant in the range -32768 to +32767."}, {"start": "00:04:11", "is_lecture": true, "end": "00:04:18", "is_worked_example": false, "text": "The operations include arithmetic operations, comparisons, boolean operations, and shifts."}, {"start": "00:04:18", "is_lecture": true, "end": "00:04:26", "is_worked_example": false, "text": "In assembly language, we use a \"C\" suffix added to the mnemonics shown here to indicate that the second operand is a constant."}, {"start": "00:04:26", "is_lecture": true, "end": "00:04:35", "is_worked_example": false, "text": "This second instruction format is also used by the instructions that access memory and change the normally sequential execution order."}, {"start": "00:04:35", "is_lecture": true, "end": "00:04:47", "is_worked_example": false, "text": "The use of just two instruction formats will make it very easy to build the logic responsible for translating the encoded instructions into the signals needed to control the operation of the datapath."}, {"start": "00:04:47", "is_lecture": true, "end": "00:04:52", "is_worked_example": false, "text": "In fact, we'll be able to use many of the instruction bits as-is!"}, {"start": "00:04:52", "is_lecture": true, "end": "00:05:02", "is_worked_example": false, "text": "We'll build our datapath incrementally, starting with the logic needed to perform the ALU instructions, then add additional logic to execute the memory and branch instructions."}, {"start": "00:05:02", "is_lecture": true, "end": "00:05:13", "is_worked_example": false, "text": "Finally, we'll need to add logic to handle what happens when an exception occurs and execution has to be suspended because the current instruction cannot be executed correctly."}, {"start": "00:05:13", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "We'll be using the digital logic gates we learned about in Part 1 of the course."}, {"start": "00:05:17", "is_lecture": true, "end": "00:05:24", "is_worked_example": false, "text": "In particular, we'll need multi-bit registers to hold state information from one instruction to the next."}, {"start": "00:05:24", "is_lecture": true, "end": "00:05:32", "is_worked_example": false, "text": "Recall that these memory elements load new values at the rising edge of the clock signal, then store that value until the next rising clock edge."}, {"start": "00:05:32", "is_lecture": true, "end": "00:05:39", "is_worked_example": false, "text": "We'll use a lot of multiplexers in our design to select between alternative values in the datapath."}, {"start": "00:05:39", "is_lecture": true, "end": "00:05:46", "is_worked_example": false, "text": "The actual computations will be performed by the arithmetic and logic unit (ALU) that we designed at the end of Part 1."}, {"start": "00:05:46", "is_lecture": true, "end": "00:05:54", "is_worked_example": false, "text": "It has logic to perform the arithmetic, comparison, boolean and shift operations listed on the previous slide."}, {"start": "00:05:54", "is_lecture": true, "end": "00:05:59", "is_worked_example": false, "text": "It takes in two 32-bit operands and produces a 32-bit result."}, {"start": "00:05:59", "is_lecture": true, "end": "00:06:09", "is_worked_example": false, "text": "And, finally, we'll use several different memory components to implement register storage in the datapath and also for main memory, where instructions and data are stored."}, {"start": "00:06:09", "is_lecture": true, "end": "00:06:16", "is_worked_example": false, "text": "You might find it useful to review the chapters on combinational and sequential logic in Part 1 of the course."}, {"start": "00:06:16", "is_lecture": true, "end": "00:06:21", "is_worked_example": false, "text": "The Beta ISA specifies thirty-two 32-bit registers as part of the datapath."}, {"start": "00:06:21", "is_lecture": true, "end": "00:06:25", "is_worked_example": false, "text": "These are shown as the magenta rectangles in the diagram below."}, {"start": "00:06:25", "is_lecture": true, "end": "00:06:34", "is_worked_example": false, "text": "These are implemented as load-enabled registers, which have an EN signal that controls when the register is loaded with a new value."}, {"start": "00:06:34", "is_lecture": true, "end": "00:06:40", "is_worked_example": false, "text": "If EN is 1, the register will be loaded from the D input at the next rising clock edge."}, {"start": "00:06:40", "is_lecture": true, "end": "00:06:47", "is_worked_example": false, "text": "If EN is 0, the register is reloaded with its current value and hence its value is unchanged."}, {"start": "00:06:47", "is_lecture": true, "end": "00:07:00", "is_worked_example": false, "text": "It might seem easier to add enabling logic to the clock signal, but this is almost never a good idea since any glitches in that logic might generate false edges that would cause the register to load a new value at the wrong time."}, {"start": "00:07:00", "is_lecture": true, "end": "00:07:04", "is_worked_example": false, "text": "Always remember the mantra: NO GATED CLOCKS!"}, {"start": "00:07:04", "is_lecture": true, "end": "00:07:11", "is_worked_example": false, "text": "There are multiplexers (shown underneath the registers) that let us select a value from any of the 32 registers."}, {"start": "00:07:11", "is_lecture": true, "end": "00:07:16", "is_worked_example": false, "text": "Since we need two operands for the datapath logic, there are two such multiplexers."}, {"start": "00:07:16", "is_lecture": true, "end": "00:07:26", "is_worked_example": false, "text": "Their select inputs (RA1 and RA2) function as addresses, determining which register values will be selected as operands."}, {"start": "00:07:26", "is_lecture": true, "end": "00:07:35", "is_worked_example": false, "text": "And, finally, there's a decoder that determines which of the 32 register load enables will be 1 based on the 5-bit WA input."}, {"start": "00:07:35", "is_lecture": true, "end": "00:07:42", "is_worked_example": false, "text": "For convenience, we'll package all this functionality up into a single component called a \"register file\"."}, {"start": "00:07:42", "is_lecture": true, "end": "00:07:52", "is_worked_example": false, "text": "The register file has two read ports, which, given a 5-bit address input, deliver the selected register value on the read-data ports."}, {"start": "00:07:52", "is_lecture": true, "end": "00:07:56", "is_worked_example": false, "text": "The two read ports operate independently."}, {"start": "00:07:56", "is_lecture": true, "end": "00:08:01", "is_worked_example": false, "text": "They can read from different registers or, if the addresses are the same, read from the same register."}, {"start": "00:08:01", "is_lecture": true, "end": "00:08:12", "is_worked_example": false, "text": "The signals on the left of the register file include a 5-bit value (WA) that selects a register to be written with the specified 32-bit write data (WD)."}, {"start": "00:08:12", "is_lecture": true, "end": "00:08:21", "is_worked_example": false, "text": "If the write enable signal (WE) is 1 at the rising edge of the clock (CLK) signal, the selected register will be loaded with the supplied write data."}, {"start": "00:08:21", "is_lecture": true, "end": "00:08:28", "is_worked_example": false, "text": "Note that in the BETA ISA, reading from register address 31 should always produce a zero value."}, {"start": "00:08:28", "is_lecture": true, "end": "00:08:31", "is_worked_example": false, "text": "The register file has internal logic to ensure that happens."}, {"start": "00:08:31", "is_lecture": true, "end": "00:08:35", "is_worked_example": false, "text": "Here's a timing diagram that shows the register file in operation."}, {"start": "00:08:35", "is_lecture": true, "end": "00:08:43", "is_worked_example": false, "text": "To read a value from the register file, supply a stable address input (RA) on one of read ports."}, {"start": "00:08:43", "is_lecture": true, "end": "00:08:51", "is_worked_example": false, "text": "After the register file's propagation delay, the value of the selected register will appear on the corresponding read data port (RD). [CLICK]"}, {"start": "00:08:51", "is_lecture": true, "end": "00:08:57", "is_worked_example": false, "text": "Not surprisingly, the register file write operation is very similar to writing an ordinary D-register."}, {"start": "00:08:57", "is_lecture": true, "end": "00:09:09", "is_worked_example": false, "text": "The write address (WA), write data (WD) and write enable (WE) signals must all be valid and stable for some specified setup time before the rising edge of the clock."}, {"start": "00:09:09", "is_lecture": true, "end": "00:09:16", "is_worked_example": false, "text": "And must remain stable and valid for the specified hold time after the rising clock edge."}, {"start": "00:09:16", "is_lecture": true, "end": "00:09:23", "is_worked_example": false, "text": "If those timing constraints are met, the register file will reliably update the value of the selected register. [CLICK]"}, {"start": "00:09:23", "is_lecture": true, "end": "00:09:35", "is_worked_example": false, "text": "When a register value is written at the rising clock edge, if that value is selected by a read address, the new data will appear after the propagation delay on the corresponding data port."}, {"start": "00:09:35", "is_lecture": true, "end": "00:09:44", "is_worked_example": false, "text": "In other words, the read data value changes if either the read address changes or the value of the selected register changes."}, {"start": "00:09:44", "is_lecture": true, "end": "00:09:49", "is_worked_example": false, "text": "Can we read and write the same register in a single clock cycle?"}, {"start": "00:09:49", "is_lecture": true, "end": "00:09:59", "is_worked_example": false, "text": "Yes!  If the read address becomes valid at the beginning of the cycle, the old value of the register will be appear on the data port for the rest of the cycle."}, {"start": "00:09:59", "is_lecture": true, "end": "00:10:07", "is_worked_example": false, "text": "Then, the write occurs at the *end* of the cycle and the new register value will be available in the next clock cycle."}, {"start": "00:10:07", "is_lecture": true, "end": "00:10:11", "is_worked_example": false, "text": "Okay, that's a brief run-though of the components we'll be using."}, {"start": "00:10:11", "is_lecture": true, "end": "00:10:13", "is_worked_example": false, "text": "Let's get started on the design!"}]}, "C04S03B08-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c4/c4s1/8?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c4s1v8", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:10", "is_worked_example": false, "text": "There are many other models of computation, each of which describes a class of integer functions where a computation is performed on an integer input to produce an integer answer."}, {"start": "00:00:10", "is_lecture": true, "end": "00:00:18", "is_worked_example": false, "text": "Kleene, Post and Turing were all students of Alonzo Church at Princeton University in the mid-1930's."}, {"start": "00:00:18", "is_lecture": true, "end": "00:00:22", "is_worked_example": false, "text": "They explored many other formulations for modeling computation:"}, {"start": "00:00:22", "is_lecture": true, "end": "00:00:27", "is_worked_example": false, "text": "recursive functions, rule-based systems for string rewriting, and the lambda calculus."}, {"start": "00:00:27", "is_lecture": true, "end": "00:00:36", "is_worked_example": false, "text": "They were all particularly intrigued with proving the existence of problems unsolvable by realizable machines."}, {"start": "00:00:36", "is_lecture": true, "end": "00:00:42", "is_worked_example": false, "text": "Which, of course, meant characterizing the problems that could be solved by realizable machines."}, {"start": "00:00:42", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "It turned out that each model was capable of computing *exactly* the same set of integer functions!"}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:56", "is_worked_example": false, "text": "This was proved by coming up with constructions that translated the steps in a computation between the various models."}, {"start": "00:00:56", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "It was possible to show that if a computation could be described by one model, an equivalent description exists in the other model."}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:12", "is_worked_example": false, "text": "This lead to a notion of computability that was independent of the computation scheme chosen."}, {"start": "00:01:12", "is_lecture": true, "end": "00:01:24", "is_worked_example": false, "text": "This notion is formalized by Church's Thesis, which says that every discrete function computable by any realizable machine is computable by some Turing Machine."}, {"start": "00:01:24", "is_lecture": true, "end": "00:01:38", "is_worked_example": false, "text": "So if we say the function f(x) is computable, that's equivalent to saying that there's a TM that given x as an input on its tape will write f(x) as an output on the tape and halt."}, {"start": "00:01:38", "is_lecture": true, "end": "00:01:45", "is_worked_example": false, "text": "As yet there's no proof of Church's Thesis, but it's universally accepted that it's true."}, {"start": "00:01:45", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "In general \"computable\" is taken to mean \"computable by some TM\"."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "If you're curious about the existence of uncomputable functions, please see the optional video at the end of this lecture."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "Okay, we've decided that Turing Machines can model any realizable computation."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:11", "is_worked_example": false, "text": "In other words for every computation we want to perform, there's a (different) Turing Machine that will do the job."}, {"start": "00:02:11", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "But how does this help us design a general-purpose computer?"}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "Or are there some computations that will require a special-purpose machine no matter what?"}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "What we'd like to find is a universal function U:"}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "it would take two arguments, k and j, and then compute the result of running T_k on input j."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "Is U computable, i.e., is there a universal Turing Machine T_U?"}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "If so, then instead of many ad-hoc TMs, we could just use T_U to compute the results for any computable function. .249 Surprise!  U is computable and T_U exists."}, {"start": "00:02:55", "is_lecture": true, "end": "00:03:00", "is_worked_example": false, "text": "If fact there are infinitely many universal TMs, some quite simple."}, {"start": "00:03:00", "is_lecture": true, "end": "00:03:06", "is_worked_example": false, "text": "The smallest known universal TM has 4 states and uses 6 tape symbols."}, {"start": "00:03:06", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "A universal machine is capable of performing any computation that can be performed by any TM!"}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:16", "is_worked_example": false, "text": "What's going on here?"}, {"start": "00:03:16", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "k encodes a \"program\" -- a description of some arbitrary TM that performs a particular computation."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:29", "is_worked_example": false, "text": "j encodes the input data on which to perform that computation."}, {"start": "00:03:29", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "T_U \"interprets\" the program, emulating the steps T_k will take to process the input and write out the answer."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "The notion of interpreting a coded representation of a computation is a key idea and forms the basis for our stored program computer."}, {"start": "00:03:49", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "The Universal Turing Machine is the paradigm for modern general-purpose computers."}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "Given an ISA we want to know if it's equivalent to a universal Turing Machine."}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:08", "is_worked_example": false, "text": "If so, it can emulate every other TM and hence compute any computable function."}, {"start": "00:04:08", "is_lecture": true, "end": "00:04:12", "is_worked_example": false, "text": "How do we show our computer is Turing Universal?"}, {"start": "00:04:12", "is_lecture": true, "end": "00:04:17", "is_worked_example": false, "text": "Simply demonstrate that it can emulate some known Universal Turing Machine."}, {"start": "00:04:17", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "The finite memory on actual computers will mean we can only emulate UTM operations on inputs up to a certain size"}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "but within this limitation we can show our computer can perform any computation that fits into memory."}, {"start": "00:04:33", "is_lecture": true, "end": "00:04:37", "is_worked_example": false, "text": "As it turns out this is not a high bar:"}, {"start": "00:04:37", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "so long as the ISA has conditional branches and some simple arithmetic, it will be Turing Universal."}, {"start": "00:04:44", "is_lecture": true, "end": "00:04:51", "is_worked_example": false, "text": "This notion of encoding a program in a way that allows it to be data to some other program is a key idea in computer science."}, {"start": "00:04:51", "is_lecture": true, "end": "00:05:06", "is_worked_example": false, "text": "We often translate a program Px written to run on some abstract high-level machine (eg, a program in C or Java) into, say, an assembly language program Py that can be interpreted by our CPU."}, {"start": "00:05:06", "is_lecture": true, "end": "00:05:09", "is_worked_example": false, "text": "This translation is called compilation."}, {"start": "00:05:09", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "Much of software engineering is based on the idea of taking a program and using it as as component in some larger program."}, {"start": "00:05:17", "is_lecture": true, "end": "00:05:32", "is_worked_example": false, "text": "Given a strategy for compiling programs, that opens the door to designing new programming languages that let us express our desired computation using data structures and operations particularly suited to the task at hand."}, {"start": "00:05:32", "is_lecture": true, "end": "00:05:38", "is_worked_example": false, "text": "So what have learned from the mathematicians' work on models of computation?"}, {"start": "00:05:38", "is_lecture": true, "end": "00:05:48", "is_worked_example": false, "text": "Well, it's nice to know that the computing engine we're planning to build will be able to perform any computation that can be performed on any realizable machine."}, {"start": "00:05:48", "is_lecture": true, "end": "00:05:56", "is_worked_example": false, "text": "And the development of the universal Turing Machine model paved the way for modern stored-program computers."}, {"start": "00:05:56", "is_lecture": true, "end": "00:06:01", "is_worked_example": false, "text": "The bottom line: we're good to go with the Beta ISA!"}]}, "C09S01B05-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c9/c9s1/5?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c9s1v5", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:01", "is_worked_example": false, "text": "We're on the home stretch now."}, {"start": "00:00:01", "is_lecture": true, "end": "00:00:10", "is_worked_example": false, "text": "For all the instructions up until now, the next instruction has come from the location following the current instruction -- hence the \"PC+4\" logic."}, {"start": "00:00:10", "is_lecture": true, "end": "00:00:15", "is_worked_example": false, "text": "Branches and JMPs change that by altering the value in the PC."}, {"start": "00:00:15", "is_lecture": true, "end": "00:00:22", "is_worked_example": false, "text": "The JMP instruction simply takes the value in the RA register and makes it the next PC value."}, {"start": "00:00:22", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "The PCSEL MUX in the upper left-hand corner lets the control logic select the source of the next PC value."}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:34", "is_worked_example": false, "text": "When PCSEL is 0, the incremented PC value is chosen."}, {"start": "00:00:34", "is_lecture": true, "end": "00:00:39", "is_worked_example": false, "text": "When PCSEL is 2, the value of the RA register is chosen."}, {"start": "00:00:39", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "We'll see how the other inputs to the PCSEL MUX are used in just a moment."}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "The JMP and branch instructions also cause the address of the following instruction, i.e., the PC+4 value, to be written to the RC register."}, {"start": "00:00:53", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "When WDSEL is 0, the \"0\" input of the WDSEL MUX is used to select the PC+4 value as the write-back data."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "Here's how the data flow works."}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "The output of the PC+4 adder is is routed to the register file and WERF is set to 1 to enable that value to be written at the end of the cycle."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:24", "is_worked_example": false, "text": "Meanwhile, the value of RA register coming out of the register file is connected to the \"2\" input of the PCSEL MUX."}, {"start": "00:01:24", "is_lecture": true, "end": "00:01:31", "is_worked_example": false, "text": "So setting PCSEL to 2 will select the value in the RA register as the next value for the PC."}, {"start": "00:01:31", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "The rest of the control signals are \"don't cares\", except, of course for the memory write enable (MWR), which can never be \"don't care\" lest we cause an accidental write to some memory location."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "The branch instruction requires an additional adder to compute the target address by adding the scaled offset from the instruction's literal field to the current PC+4 value."}, {"start": "00:01:53", "is_lecture": true, "end": "00:02:03", "is_worked_example": false, "text": "Remember that we scale the offset by a factor of 4 to convert it from the word offset stored in the literal to the byte offset required for the PC."}, {"start": "00:02:03", "is_lecture": true, "end": "00:02:13", "is_worked_example": false, "text": "The output of the offset adder becomes the \"1\" input to the PCSEL MUX, where, if the branch is taken, it will become the next value of the PC."}, {"start": "00:02:13", "is_lecture": true, "end": "00:02:23", "is_worked_example": false, "text": "Note that multiplying by 4 is easily accomplished by shifting the literal two bits to the left, which inserts two 0-bits at the low-order end of the value."}, {"start": "00:02:23", "is_lecture": true, "end": "00:02:32", "is_worked_example": false, "text": "And, like before, the sign-extension just requires replicating bit ID[15], in this case fourteen times."}, {"start": "00:02:32", "is_lecture": true, "end": "00:02:41", "is_worked_example": false, "text": "So implementing this complicated-looking expression requires care in wiring up the input to the offset adder, but no additional logic!"}, {"start": "00:02:41", "is_lecture": true, "end": "00:02:46", "is_worked_example": false, "text": "We do need some logic to determine if we should branch or not."}, {"start": "00:02:46", "is_lecture": true, "end": "00:02:54", "is_worked_example": false, "text": "The 32-bit NOR gate connected to the first read port of the register file tests the value of the RA register."}, {"start": "00:02:54", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "The NOR's output Z will be 1 if all the bits of the RA register value are 0, and 0 otherwise."}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "The Z value can be used by the control logic to determine the correct value for PCSEL."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:19", "is_worked_example": false, "text": "If Z indicates the branch is taken, PCSEL will be 1 and the output of the offset adder becomes the next value of the PC."}, {"start": "00:03:19", "is_lecture": true, "end": "00:03:28", "is_worked_example": false, "text": "If the branch is not taken, PCSEL will be 0 and execution will continue with the next instruction at PC+4."}, {"start": "00:03:28", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "As in the JMP instruction, the PC+4 value is routed to the register file to be written into the RC register at end of the cycle."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "Meanwhile, the value of Z is computed from the value of the RA register while the branch offset adder computes the address of the branch target."}, {"start": "00:03:49", "is_lecture": true, "end": "00:04:05", "is_worked_example": false, "text": "The output of the offset adder is routed to the PCSEL MUX where the value of the 3-bit PCSEL control signal, computed by the control logic based on Z, determines whether the next PC value is the branch target or the PC+4 value."}, {"start": "00:04:05", "is_lecture": true, "end": "00:04:11", "is_worked_example": false, "text": "The remaining control signals are unused and set to their default \"don't care\" values."}, {"start": "00:04:11", "is_lecture": true, "end": "00:04:18", "is_worked_example": false, "text": "We have one last instruction to introduce: the LDR or load-relative instruction."}, {"start": "00:04:18", "is_lecture": true, "end": "00:04:25", "is_worked_example": false, "text": "LDR behaves like a normal LD instruction except that the memory address is taken from the branch offset adder."}, {"start": "00:04:25", "is_lecture": true, "end": "00:04:31", "is_worked_example": false, "text": "Why would it be useful to load a value from a location near the LDR instruction?"}, {"start": "00:04:31", "is_lecture": true, "end": "00:04:41", "is_worked_example": false, "text": "Normally such addresses would refer to the neighboring instructions, so why would we want to load the binary encoding of an instruction into a register to be used as data?"}, {"start": "00:04:41", "is_lecture": true, "end": "00:04:53", "is_worked_example": false, "text": "The use case for LDR is accessing large constants that have to be stored in main memory because they are too large to fit into the 16-bit literal field of an instruction."}, {"start": "00:04:53", "is_lecture": true, "end": "00:05:00", "is_worked_example": false, "text": "In the example shown here, the compiled code needs to load the constant 123456."}, {"start": "00:05:00", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "So it uses an LDR instruction that refers to a nearby location C1: that has been initialized with the required value."}, {"start": "00:05:10", "is_lecture": true, "end": "00:05:21", "is_worked_example": false, "text": "Since this read-only constant is part of the program, it makes sense to store it with the instructions for the program, usually just after the code for a procedure."}, {"start": "00:05:21", "is_lecture": true, "end": "00:05:28", "is_worked_example": false, "text": "Note that we have to be careful to place the storage location so that it won't be executed as an instruction!"}, {"start": "00:05:28", "is_lecture": true, "end": "00:05:46", "is_worked_example": false, "text": "To route the output of the offset adder to the main memory address port, we'll add ASEL MUX so we can select either the RA register value (when ASEL=0) or the output of the offset adder (when ASEL=1) as the first ALU operand."}, {"start": "00:05:46", "is_lecture": true, "end": "00:05:59", "is_worked_example": false, "text": "For LDR, ASEL will be 1, and we'll then ask the ALU compute the Boolean operation \"A\", i.e., the boolean function whose output is just the value of the first operand."}, {"start": "00:05:59", "is_lecture": true, "end": "00:06:09", "is_worked_example": false, "text": "This value then appears on the ALU output, which is connected to the main memory address port and the remainder of the execution proceeds just like it did for LD."}, {"start": "00:06:09", "is_lecture": true, "end": "00:06:12", "is_worked_example": false, "text": "This seems a bit complicated!"}, {"start": "00:06:12", "is_lecture": true, "end": "00:06:15", "is_worked_example": false, "text": "Mr. Blue has a good question:"}, {"start": "00:06:15", "is_lecture": true, "end": "00:06:22", "is_worked_example": false, "text": "why not just put the ASEL MUX on the wire leading to the main memory address port and bypass the ALU altogether?"}, {"start": "00:06:22", "is_lecture": true, "end": "00:06:28", "is_worked_example": false, "text": "The answer has to do with the amount of time needed to compute the memory address."}, {"start": "00:06:28", "is_lecture": true, "end": "00:06:44", "is_worked_example": false, "text": "If we moved the ASEL MUX here, the data flow for LD and ST addresses would then pass through two MUXes, the BSEL MUX and the ASEL MUX, slowing down the arrival of the address by a small amount."}, {"start": "00:06:44", "is_lecture": true, "end": "00:06:54", "is_worked_example": false, "text": "This may not seem like a big deal, but the additional time would have to be added the clock period, thus slowing down every instruction by a little bit."}, {"start": "00:06:54", "is_lecture": true, "end": "00:07:04", "is_worked_example": false, "text": "When executing billions of instructions, a little extra time on each instruction really impacts the overall performance of the processor."}, {"start": "00:07:04", "is_lecture": true, "end": "00:07:16", "is_worked_example": false, "text": "By placing the ASEL MUX where we did, its propagation delay overlaps that of the BSEL MUX, so the increased functionality it provides comes with no cost in performance."}, {"start": "00:07:16", "is_lecture": true, "end": "00:07:21", "is_worked_example": false, "text": "Here's the data flow for the LDR instruction."}, {"start": "00:07:21", "is_lecture": true, "end": "00:07:26", "is_worked_example": false, "text": "The output of the offset adder is routed through the ASEL MUX to the ALU."}, {"start": "00:07:26", "is_lecture": true, "end": "00:07:33", "is_worked_example": false, "text": "The ALU performs the Boolean computation \"A\" and the result becomes the address for main memory."}, {"start": "00:07:33", "is_lecture": true, "end": "00:07:41", "is_worked_example": false, "text": "The returning data is routed through the WDSEL MUX so it can be written into the RC register at the end of the cycle."}, {"start": "00:07:41", "is_lecture": true, "end": "00:07:46", "is_worked_example": false, "text": "The remaining control values are given their usual default values."}]}, "C07S01B02-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c7/c7s1/2?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c7s1v2", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "The problem we need to solve is where to store the values needed by procedure: its arguments, its return address, its return value."}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "The procedure may also need storage for its local variables and space to save the values of the caller's registers before they get overwritten by the procedure."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "We'd like to avoid any limitations on the number of arguments, the number of local variables, etc."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:31", "is_worked_example": false, "text": "So we'll need a block of storage for each active procedure call, what we'll call the \"activation record\"."}, {"start": "00:00:31", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "As we saw in the factorial example, we can't statically allocate a single block of storage for a particular procedure since recursive calls mean we'll have many active calls to that procedure at points during the execution."}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:54", "is_worked_example": false, "text": "What we need is a way to dynamically allocate storage for an activation record when the procedure is called, which can then be reclaimed when the procedure returns."}, {"start": "00:00:54", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "Let's see how activation records come and go as execution proceeds."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:03", "is_worked_example": false, "text": "The first activation record is for the call fact(3)."}, {"start": "00:01:03", "is_lecture": true, "end": "00:01:15", "is_worked_example": false, "text": "It's created at the beginning of the procedure and holds, among other things, the value of the argument n and the return address where execution should resume after the fact(3) computation is complete."}, {"start": "00:01:15", "is_lecture": true, "end": "00:01:21", "is_worked_example": false, "text": "During the execution of fact(3), we need to make a recursive call to compute fact(2)."}, {"start": "00:01:21", "is_lecture": true, "end": "00:01:29", "is_worked_example": false, "text": "So that procedure call also gets an activation record with the appropriate values for the argument and return address."}, {"start": "00:01:29", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "Note that the original activation record is kept since it contains information needed to complete the computation of fact(3) after the call to fact(2) returns."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:45", "is_worked_example": false, "text": "So now we have two active procedure calls and hence two activation records."}, {"start": "00:01:45", "is_lecture": true, "end": "00:01:52", "is_worked_example": false, "text": "fact(2) requires computing fact(1), which, in turn, requires computing fact(0)."}, {"start": "00:01:52", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "At this point there are four active procedure calls and hence four activation records."}, {"start": "00:01:48", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "The recursion terminates with fact(0), which returns the value 1 to its caller."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:12", "is_worked_example": false, "text": "At this point we've finished execution of fact(0) and so its activation record is no longer needed and can be discarded."}, {"start": "00:02:12", "is_lecture": true, "end": "00:02:17", "is_worked_example": false, "text": "fact(1) now finishes its computation returning 1 to its caller."}, {"start": "00:02:17", "is_lecture": true, "end": "00:02:20", "is_worked_example": false, "text": "We no longer need its activation record."}, {"start": "00:02:20", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "Then fact(2) completes, returning 2 to its caller and its activation record can be discarded."}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "And so on..."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:35", "is_worked_example": false, "text": "Note that the activation record of a nested procedure call is always discarded before the activation record of the caller."}, {"start": "00:02:35", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "That makes sense: the execution of the caller can't complete until the nested procedure call returns."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "What we need is a storage scheme that efficiently supports the allocation and deallocation of activation records as shown here."}, {"start": "00:02:50", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "Early compiler writers recognized that activation records are allocated and deallocated in last-in first-out (LIFO) order."}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:08", "is_worked_example": false, "text": "So they invented the \"stack\", a data structure that implements a PUSH operation to add a record to the top of the stack and a POP operation to remove the top element."}, {"start": "00:03:08", "is_lecture": true, "end": "00:03:16", "is_worked_example": false, "text": "New activation records are PUSHed onto the stack during procedure calls and the POPed from the stack when the procedure call returns."}, {"start": "00:03:16", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "Note that stack operations affect the top (i.e., most recent) record on the stack."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:27", "is_worked_example": false, "text": "C procedures only need to access the top activation record on the stack."}, {"start": "00:03:27", "is_lecture": true, "end": "00:03:33", "is_worked_example": false, "text": "Other programming languages, e.g. Java, support accesses to other active activation records."}, {"start": "00:03:33", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "The stack supports both modes of operation."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:54", "is_worked_example": false, "text": "One final technical note: some programming languages support closures (e.g., Javascript) or continuations (e.g., Python's yield statement), where the activation records need to be preserved even after the procedure returns."}, {"start": "00:03:54", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "In these cases, the simple LIFO behavior of the stack is no longer sufficient and we'll need another scheme for allocating and deallocating activation records."}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:06", "is_worked_example": false, "text": "But that's a topic for another course!"}, {"start": "00:04:06", "is_lecture": true, "end": "00:05:09", "is_worked_example": false, "text": "Here's how we'll implement the stack on the Beta:"}, {"start": "00:05:09", "is_lecture": true, "end": "00:04:17", "is_worked_example": false, "text": "We'll dedicate one of the Beta registers, R29, to be the \"stack pointer\" that will be used to manage stack operations."}, {"start": "00:04:17", "is_lecture": true, "end": "00:04:22", "is_worked_example": false, "text": "When we PUSH a word onto the stack, we'll increment the stack pointer."}, {"start": "00:04:22", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "So the stack grows to successively higher addresses as words are PUSHed onto the stack."}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "We'll adopt the convention that SP points to (i.e., its value is the address of) the first unused stack location, the location that will be filled by next PUSH."}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:47", "is_worked_example": false, "text": "So locations with addresses lower than the value in SP correspond to words that have been previously allocated."}, {"start": "00:04:47", "is_lecture": true, "end": "00:05:00", "is_worked_example": false, "text": "Words can be PUSHed to or POPed from the stack at any point in execution, but we'll impose the rule that code sequences that PUSH words onto the stack must POP those words at the end of execution."}, {"start": "00:05:00", "is_lecture": true, "end": "00:05:07", "is_worked_example": false, "text": "So when a code sequence finishes execution, SP will have the same value as it had before the sequence started."}, {"start": "00:05:07", "is_lecture": true, "end": "00:05:16", "is_worked_example": false, "text": "This is called the \"stack discipline\" and ensures that intervening uses of the stack don't affect later stack references."}, {"start": "00:05:16", "is_lecture": true, "end": "00:05:25", "is_worked_example": false, "text": "We'll allocate a large region of memory to hold the stack located so that the stack can grow without overwriting other program storage."}, {"start": "00:05:25", "is_lecture": true, "end": "00:05:36", "is_worked_example": false, "text": "Most systems require that you specify a maximum stack size when running a program and will signal an execution error if the program attempts to PUSH too many items onto the stack."}, {"start": "00:05:36", "is_lecture": true, "end": "00:05:46", "is_worked_example": false, "text": "For our Beta stack implementation, we'll use existing instructions to implement stack operations, so for us the stack is strictly a set of software conventions."}, {"start": "00:05:46", "is_lecture": true, "end": "00:05:53", "is_worked_example": false, "text": "Other ISAs provide instructions specifically for stack operations."}, {"start": "00:05:53", "is_lecture": true, "end": "00:06:03", "is_worked_example": false, "text": "There are many other sensible stack conventions, so you'll need to read up on the conventions adopted by the particular ISA or programming language you'll be using."}, {"start": "00:06:03", "is_lecture": true, "end": "00:06:08", "is_worked_example": false, "text": "We've added some convenience macros to UASM to support stacks."}, {"start": "00:06:08", "is_lecture": true, "end": "00:06:12", "is_worked_example": false, "text": "The PUSH macro expands into two instructions."}, {"start": "00:06:12", "is_lecture": true, "end": "00:06:23", "is_worked_example": false, "text": "The ADDC increments the stack pointer, allocating a new word at the top of stack, and then initializes the new top-of-stack from a specified register value with a ST instruction."}, {"start": "00:06:23", "is_lecture": true, "end": "00:06:35", "is_worked_example": false, "text": "The POP macro LDs the value at the top of the stack into the specified register, then uses a SUBC instruction to decrement the stack pointer, deallocating that word from the stack."}, {"start": "00:06:35", "is_lecture": true, "end": "00:06:41", "is_worked_example": false, "text": "Note that the order of the instructions in the PUSH and POP macro is very important."}, {"start": "00:06:41", "is_lecture": true, "end": "00:06:52", "is_worked_example": false, "text": "As we'll see in the next lecture, interrupts can cause the Beta hardware to stop executing the current program between any two instructions, so we have to be careful about the order of operations."}, {"start": "00:06:52", "is_lecture": true, "end": "00:06:58", "is_worked_example": false, "text": "So for PUSH, we first allocate the word on the stack, then initialize it."}, {"start": "00:06:58", "is_lecture": true, "end": "00:07:11", "is_worked_example": false, "text": "If we did it the other way around and execution was interrupted between the initialization and allocation, code run during the interrupt which uses the stack might unintentionally overwrite the initialized value."}, {"start": "00:07:11", "is_lecture": true, "end": "00:07:19", "is_worked_example": false, "text": "But, assuming all code follows stack discipline, allocation followed by initialization is always safe."}, {"start": "00:07:19", "is_lecture": true, "end": "00:07:22", "is_worked_example": false, "text": "The same reasoning applies to the order of the POP instructions."}, {"start": "00:07:22", "is_lecture": true, "end": "00:07:30", "is_worked_example": false, "text": "We first access the top-of-stack one last time to retrieve its value, then we deallocate that location."}, {"start": "00:07:30", "is_lecture": true, "end": "00:07:36", "is_worked_example": false, "text": "We can use the ALLOCATE macro to reserve a number of stack locations for later use."}, {"start": "00:07:36", "is_lecture": true, "end": "00:07:40", "is_worked_example": false, "text": "Sort of like PUSH but without the initialization."}, {"start": "00:07:40", "is_lecture": true, "end": "00:07:46", "is_worked_example": false, "text": "DEALLOCATE performs the opposite operation, removing N words from the stack."}, {"start": "00:07:46", "is_lecture": true, "end": "00:07:58", "is_worked_example": false, "text": "In general, if we see a PUSH or ALLOCATE in an assembly language program, we should be able to find the corresponding POP or DEALLOCATE, which would indicate that stack discipline is maintained."}, {"start": "00:07:58", "is_lecture": true, "end": "00:08:01", "is_worked_example": false, "text": "We'll use stacks to save values we'll need later."}, {"start": "00:08:01", "is_lecture": true, "end": "00:08:09", "is_worked_example": false, "text": "For example, if we need to use some registers for a computation but don't know if the register's current values are needed later in the program,"}, {"start": "00:08:09", "is_lecture": true, "end": "00:08:15", "is_worked_example": false, "text": "we can PUSH their current values onto the stack and then are free to use the registers in our code."}, {"start": "00:08:15", "is_lecture": true, "end": "00:08:20", "is_worked_example": false, "text": "After we're done, we can use POP to restore the saved values."}, {"start": "00:08:20", "is_lecture": true, "end": "00:08:32", "is_worked_example": false, "text": "Note that we POP data off the stack in the opposite order that the data was PUSHed, i.e., we need to follow the last-in first-out discipline imposed by the stack operations."}, {"start": "00:08:32", "is_lecture": true, "end": "00:08:40", "is_worked_example": false, "text": "Now that we have the stack data structure, we'll use it to solve our problems with allocating and deallocating activation records during procedure calls."}]}, "C09S02B01-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c9/c9s2/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c9s2v1", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:06", "is_worked_example": true, "text": "In this problem, we are going to consider several instructions that we want to add to our beta."}, {"start": "00:00:06", "is_lecture": false, "end": "00:00:14", "is_worked_example": true, "text": "For each of these instructions, we will need to decide what the minimum requirement is to add that instruction."}, {"start": "00:00:14", "is_lecture": false, "end": "00:00:21", "is_worked_example": true, "text": "The simplest addition would be a macro that references a single already existing beta instruction."}, {"start": "00:00:21", "is_lecture": false, "end": "00:00:39", "is_worked_example": true, "text": "If our new instruction cannot be implemented by simply defining a macro, then we want to consider whether adding a new opcode, and producing the appropriate control ROM signals for it, will enable the new operation to be executed on our existing Beta datapaths."}, {"start": "00:00:39", "is_lecture": false, "end": "00:00:53", "is_worked_example": true, "text": "Finally, if neither the macro or Control ROM solutions work, then we need to specify that the instruction cannot be implemented without making actual hardware changes to the Beta."}, {"start": "00:00:53", "is_lecture": false, "end": "00:01:08", "is_worked_example": true, "text": "The first instruction that we want to consider adding to our Beta is a SWAPR instruction which swaps the contents of registers Rx and Ry in a single clock cycle."}, {"start": "00:01:08", "is_lecture": false, "end": "00:01:20", "is_worked_example": true, "text": "The constraint that this must be done in a single clock cycle points us to the fact that the Beta hardware does not have the ability to write to two different registers in the same clock cycle."}, {"start": "00:01:20", "is_lecture": false, "end": "00:01:27", "is_worked_example": true, "text": "Thus, in order to add this instruction to the Beta, new hardware would need to be added."}, {"start": "00:01:27", "is_lecture": false, "end": "00:01:34", "is_worked_example": true, "text": "The next instruction that we want to consider adding to our beta is a NEG instruction."}, {"start": "00:01:34", "is_lecture": false, "end": "00:01:42", "is_worked_example": true, "text": "This instruction should take the two's complement negation of register Rx and store it into register Ry."}, {"start": "00:01:42", "is_lecture": false, "end": "00:01:49", "is_worked_example": true, "text": "The first question we want to ask ourselves is whether or not we might be able to implement this using a macro."}, {"start": "00:01:49", "is_lecture": false, "end": "00:02:03", "is_worked_example": true, "text": "Since all we are trying to do is produce the negative of a given value, we can write a macro for this instruction which subtracts Rx from R31 and stores that result into Ry."}, {"start": "00:02:03", "is_lecture": false, "end": "00:02:16", "is_worked_example": true, "text": "Note that this macro will not work for the corner case which is the largest representable negative number because the negation of that number cannot be represented using 32-bit two's complement representation."}, {"start": "00:02:16", "is_lecture": false, "end": "00:02:20", "is_worked_example": true, "text": "For all other cases, however, this macro works as expected."}, {"start": "00:02:20", "is_lecture": false, "end": "00:02:29", "is_worked_example": true, "text": "The next instruction that we want to consider adding to our Beta is a PC-relative store instruction."}, {"start": "00:02:29", "is_lecture": false, "end": "00:02:44", "is_worked_example": true, "text": "The way this instruction works is that it writes the contents of register Rx to a location in memory whose address is computed by adding PC + 4 + 4*SEXT(C)."}, {"start": "00:02:44", "is_lecture": false, "end": "00:02:56", "is_worked_example": true, "text": "The only existing store operation in the beta is a store that writes to the address that is computed by adding the contents of register Ry and the sign extended literal C."}, {"start": "00:02:56", "is_lecture": false, "end": "00:03:05", "is_worked_example": true, "text": "Since this is not equivalent to the store relative instruction's behavior that means that we cannot implement this instruction as a macro."}, {"start": "00:03:05", "is_lecture": false, "end": "00:03:11", "is_worked_example": true, "text": "So next we consider whether or not we can implement this instruction using our existing Beta datapaths."}, {"start": "00:03:11", "is_lecture": false, "end": "00:03:23", "is_worked_example": true, "text": "This beta diagram highlights in red the dataflow through the existing Beta datapaths that would perform the desired PC relative store instruction."}, {"start": "00:03:23", "is_lecture": false, "end": "00:03:36", "is_worked_example": true, "text": "The way this instruction works is that the extra adder under the instruction memory is used to compute the value of the effective address which is PC + 4 + 4*SEXT(C)."}, {"start": "00:03:36", "is_lecture": false, "end": "00:03:44", "is_worked_example": true, "text": "The ASEL, or A select signal is then set to 1 to pass that value to the ALU as the A operand."}, {"start": "00:03:44", "is_lecture": false, "end": "00:03:54", "is_worked_example": true, "text": "The ALUFN is then set to A to continue passing that value through the ALU in order for it to be used as the address for the data memory."}, {"start": "00:03:54", "is_lecture": false, "end": "00:04:00", "is_worked_example": true, "text": "This address is labeled MA, or memory address in the beta diagram."}, {"start": "00:04:00", "is_lecture": false, "end": "00:04:05", "is_worked_example": true, "text": "The value that is written to memory is the value of register Rx."}, {"start": "00:04:05", "is_lecture": false, "end": "00:04:10", "is_worked_example": true, "text": "In store operations, the first operand corresponds to register Rc."}, {"start": "00:04:10", "is_lecture": false, "end": "00:04:21", "is_worked_example": true, "text": "So we set RA2SEL = 1 in order to select Rc, which is Rx in this case, as the register whose contents should be written to memory."}, {"start": "00:04:21", "is_lecture": false, "end": "00:04:33", "is_worked_example": true, "text": "The value of this register is made available via the RD2 register file port which then feeds the MWD, or memory write data signal for the memory."}, {"start": "00:04:33", "is_lecture": false, "end": "00:04:37", "is_worked_example": true, "text": "There are a couple other memory related signals that we need to set appropriately."}, {"start": "00:04:37", "is_lecture": false, "end": "00:04:44", "is_worked_example": true, "text": "They are MWR, which stands for memory write read, and controls the write enable of the data memory."}, {"start": "00:04:44", "is_lecture": false, "end": "00:04:49", "is_worked_example": true, "text": "In order to be able to write to the memory, the write enable must be set to 1."}, {"start": "00:04:49", "is_lecture": false, "end": "00:04:52", "is_worked_example": true, "text": "MOE is the memory output enable."}, {"start": "00:04:52", "is_lecture": false, "end": "00:04:57", "is_worked_example": true, "text": "We set this to 0 to specify that no output should be enabled from the memory."}, {"start": "00:04:57", "is_lecture": false, "end": "00:05:06", "is_worked_example": true, "text": "Note that you may think that MOE should be a don't care since we are never making use of the MRD, or memory read data, signal in our datapath."}, {"start": "00:05:06", "is_lecture": false, "end": "00:05:15", "is_worked_example": true, "text": "However, by setting it to 0 we allow ourselves to potentially use the same databus for the read and write data of the memory."}, {"start": "00:05:15", "is_lecture": false, "end": "00:05:22", "is_worked_example": true, "text": "This is not explicitly shown in our beta diagram but is the reason that MOE is specified as 0 for us."}, {"start": "00:05:22", "is_lecture": false, "end": "00:05:29", "is_worked_example": true, "text": "The other control signal that we must set to 0 is WERF, which stands for write enable register file."}, {"start": "00:05:29", "is_lecture": false, "end": "00:05:35", "is_worked_example": true, "text": "Setting this signal to 0 ensures that no value will be written back into our register file."}, {"start": "00:05:35", "is_lecture": false, "end": "00:05:40", "is_worked_example": true, "text": "This allows us to then set WDSEL and WASEL to don't cares."}, {"start": "00:05:40", "is_lecture": false, "end": "00:05:50", "is_worked_example": true, "text": "The last control signal is BSEL which is also a don't care because the B operand is ignored by the ALU for this instruction."}, {"start": "00:05:50", "is_lecture": false, "end": "00:05:59", "is_worked_example": true, "text": "Finally, the PCSEL = 0 in order to increment the PC by 4 so that the next instruction will be fetched."}, {"start": "00:05:59", "is_lecture": false, "end": "00:06:07", "is_worked_example": true, "text": "So our completed Control ROM for the STR operation is shown here."}, {"start": "00:06:07", "is_lecture": false, "end": "00:06:14", "is_worked_example": true, "text": "The last instruction we want to add to our beta is the BITCLR(Rx, Ry, Rz) instruction."}, {"start": "00:06:14", "is_lecture": false, "end": "00:06:23", "is_worked_example": true, "text": "This instruction performs a bitwise AND of the contents of register Ry with the complement of the contents of register Rx."}, {"start": "00:06:23", "is_lecture": false, "end": "00:06:30", "is_worked_example": true, "text": "There is no existing beta instruction that performs this functionality so using a macro is not an option."}, {"start": "00:06:30", "is_lecture": false, "end": "00:06:39", "is_worked_example": true, "text": "Next, we want to consider whether or not we could implement this instruction using our existing datapaths with changes to our control ROM."}, {"start": "00:06:39", "is_lecture": false, "end": "00:06:47", "is_worked_example": true, "text": "To answer this question, you need to realize that the operation that you are trying to perform here is a boolean operation."}, {"start": "00:06:47", "is_lecture": false, "end": "00:07:10", "is_worked_example": true, "text": "In module 1, when implementing the ALU lab, we learned that the way that the bool module works is that if you set the ALUFN to 10abcd, then the ALU would produce the output defined by this truth table for every pair of bits Bi and Ai."}, {"start": "00:07:10", "is_lecture": false, "end": "00:07:26", "is_worked_example": true, "text": "So for example, to implement the AND function, we simply set a = 1, b = 0, c = 0, and d = 0 as shown in this truth table which is the truth table for an AND function."}, {"start": "00:07:26", "is_lecture": false, "end": "00:07:31", "is_worked_example": true, "text": "The truth table for the BITCLR operation is shown here."}, {"start": "00:07:31", "is_lecture": false, "end": "00:07:40", "is_worked_example": true, "text": "One additional column, NOT(Rx)[i] has been added to show the intermediate step of negating Rx[i]."}, {"start": "00:07:40", "is_lecture": false, "end": "00:07:49", "is_worked_example": true, "text": "Then if you take the AND of the Ry[i] column and the Not(Rx)[i] columns you get the result Rz[i]."}, {"start": "00:07:49", "is_lecture": false, "end": "00:07:57", "is_worked_example": true, "text": "This means that the ALUFN for the BITCLR operation is 10 followed by 0100."}, {"start": "00:07:57", "is_lecture": false, "end": "00:08:11", "is_worked_example": true, "text": "The rest of the control signals can be determined by looking at this highlighted beta diagram which shows in red the paths that must be followed in order to properly implement the BITCLR operation."}, {"start": "00:08:11", "is_lecture": false, "end": "00:08:20", "is_worked_example": true, "text": "The instruction memory specifies the registers Ra and Rb, in our case Rx and Ry, that are to be used by this operation."}, {"start": "00:08:20", "is_lecture": false, "end": "00:08:28", "is_worked_example": true, "text": "Setting RA2SEL to 0 tells the register file to read Rb, or Ry, as the second operand."}, {"start": "00:08:28", "is_lecture": false, "end": "00:08:35", "is_worked_example": true, "text": "Then setting ASEL and BSEL to 0 passes the values of Rx and Ry to the ALU."}, {"start": "00:08:35", "is_lecture": false, "end": "00:08:42", "is_worked_example": true, "text": "The ALUFN is used to specify the particular boolean operation that we are performing."}, {"start": "00:08:42", "is_lecture": false, "end": "00:08:49", "is_worked_example": true, "text": "Then WDSEL = 1 in order to feed the results of the ALU back to the register file."}, {"start": "00:08:49", "is_lecture": false, "end": "00:08:55", "is_worked_example": true, "text": "The Rc register is Rz and it is the register that the result should be written to."}, {"start": "00:08:55", "is_lecture": false, "end": "00:09:02", "is_worked_example": true, "text": "To make that happen, we set WASEL = 0, and WERF = 1."}, {"start": "00:09:02", "is_lecture": false, "end": "00:09:08", "is_worked_example": true, "text": "To avoid anything being written to the data memory, MWR is set to 0."}, {"start": "00:09:08", "is_lecture": false, "end": "00:09:20", "is_worked_example": true, "text": "MOE can be a don't care because we are not using the memory for reading or writing and setting WDSEL to 1 ignores anything that is on the MRD, or memory read data, line."}, {"start": "00:09:20", "is_lecture": false, "end": "00:09:30", "is_worked_example": true, "text": "Finally, the PCSEL = 0 in order to increment the PC by 4 so that the next instruction will be fetched."}, {"start": "00:09:30", "is_lecture": false, "end": "00:09:38", "is_worked_example": true, "text": "So our completed Control ROM for the STR operation is shown here."}]}, "C09S01B02-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c9/c9s1/2?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c9s1v2", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:07", "is_worked_example": false, "text": "Our first task is to work on the datapath logic needed to execute ALU instructions with two register operands."}, {"start": "00:00:07", "is_lecture": true, "end": "00:00:10", "is_worked_example": false, "text": "Each instruction requires the same processing steps:"}, {"start": "00:00:10", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "Fetch, where the 32-bit encoded instruction is read from main memory from the location specified by the program counter (PC)."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:27", "is_worked_example": false, "text": "Decode, where the opcode field (instruction bits [31:26]) is used to determine the values for the datapath control signals."}, {"start": "00:00:27", "is_lecture": true, "end": "00:00:39", "is_worked_example": false, "text": "Read, where the contents of the registers specified by the RA and RB fields (instruction bits [20:16] and [15:11]) are read from the register file."}, {"start": "00:00:39", "is_lecture": true, "end": "00:00:42", "is_worked_example": false, "text": "Execute, where the requested operation is performed on the two operand values."}, {"start": "00:00:42", "is_lecture": true, "end": "00:00:47", "is_worked_example": false, "text": "We'll also need to compute the next value for the PC."}, {"start": "00:00:47", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "And Write-back, where the result of the operation is written to the register file in the register specified by the RC field (instruction bits [25:21])."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:03", "is_worked_example": false, "text": "The system's clock signal is connected to the register file and the PC register."}, {"start": "00:01:03", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "At the rising edge of the clock, the new values computed during the Execute phase are written to these registers."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:18", "is_worked_example": false, "text": "The rising clock edge thus marks the end of execution for the current instruction and the beginning of execution for the next instruction."}, {"start": "00:01:18", "is_lecture": true, "end": "00:01:31", "is_worked_example": false, "text": "The period of the clock, i.e., the time between rising clock edges, needs to be long enough to accommodate the cumulative propagation delay of the logic that implements the 5 steps described here."}, {"start": "00:01:31", "is_lecture": true, "end": "00:01:39", "is_worked_example": false, "text": "Since one instruction is executed each clock cycle, the frequency of the clock tells us the rate at which instructions are executed."}, {"start": "00:01:39", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "If the clock period was 10ns, the clock frequency would be 100 MHz and our Beta would be executing instructions at 100 MIPS!"}, {"start": "00:01:48", "is_lecture": true, "end": "00:01:54", "is_worked_example": false, "text": "Here's a sketch showing the hardware needed for the Fetch and Decode steps."}, {"start": "00:01:54", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "The current value of the PC register is routed to main memory as the address of the instruction to be fetched."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "For ALU instructions, the address of the next instruction is simply the address of the current instruction plus 4."}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:16", "is_worked_example": false, "text": "There's an adder dedicated to performing the \"PC+4\" computation and that value is routed back to be used as the next value of the PC."}, {"start": "00:02:16", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "We've also included a MUX used to select the initial value for the PC when the RESET signal is 1."}, {"start": "00:02:24", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "After the memory propagation delay, the instruction bits (ID[31:0]) are available and the processing steps can begin."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:37", "is_worked_example": false, "text": "Some of the instruction fields can be used directly as-is."}, {"start": "00:02:37", "is_lecture": true, "end": "00:02:44", "is_worked_example": false, "text": "To determine the values for other control signals, we'll need some logic that computes their values from the bits of the opcode field."}, {"start": "00:02:44", "is_lecture": true, "end": "00:02:51", "is_worked_example": false, "text": "Now let's fill in the datapath logic needed to execute ALU instructions with two register operands."}, {"start": "00:02:51", "is_lecture": true, "end": "00:03:00", "is_worked_example": false, "text": "The instruction bits for the 5-bit RA, RB and RC fields can be connected directly to the appropriate address inputs of the register file."}, {"start": "00:03:00", "is_lecture": true, "end": "00:03:08", "is_worked_example": false, "text": "The RA and RB fields supply the addresses for the two read ports and the RC field supplies the address for the write port."}, {"start": "00:03:08", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "The outputs of the read data ports are routed to the inputs of the ALU to serve as the two operands."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:19", "is_worked_example": false, "text": "The ALUFN control signals tell the ALU what operation to perform."}, {"start": "00:03:19", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "These control signals are determined by the control logic from the 6-bit opcode field."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:38", "is_worked_example": false, "text": "For specificity, let's assume that the control logic is implemented using a read-only memory (ROM), where the opcode bits are used as the ROM's address and the ROM's outputs are the control signals."}, {"start": "00:03:38", "is_lecture": true, "end": "00:03:43", "is_worked_example": false, "text": "Since there are 6 opcode bits, we'll need 2^6 = 64 locations in the ROM."}, {"start": "00:03:43", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "We'll program the contents of the ROM to supply the correct control signal values for each of the 64 possible opcodes."}, {"start": "00:03:52", "is_lecture": true, "end": "00:04:01", "is_worked_example": false, "text": "The output of the ALU is routed back to the write data port of the register file, to be written into the RC register at the end of the cycle."}, {"start": "00:04:01", "is_lecture": true, "end": "00:04:11", "is_worked_example": false, "text": "We'll need another control signal, WERF (\"write-enable register file\"), that should have the value 1 when we want to write into the RC register."}, {"start": "00:04:11", "is_lecture": true, "end": "00:04:20", "is_worked_example": false, "text": "Let me introduce you to Werf, the 6.004 mascot, who, of course, is named after her favorite control signal, which she's constantly mentioning."}, {"start": "00:04:20", "is_lecture": true, "end": "00:04:25", "is_worked_example": false, "text": "Let's follow the flow of data as we execute the ALU instruction."}, {"start": "00:04:25", "is_lecture": true, "end": "00:04:35", "is_worked_example": false, "text": "After the instruction has been fetched, supplying the RA and RB instruction fields, the RA and RB register values appear on the read data ports of the register file."}, {"start": "00:04:35", "is_lecture": true, "end": "00:04:42", "is_worked_example": false, "text": "The control logic has decoded the opcode bits and supplied the appropriate ALU function code."}, {"start": "00:04:42", "is_lecture": true, "end": "00:04:49", "is_worked_example": false, "text": "You can find a listing of the possible function codes in the upper right-hand corner of the Beta Diagram handout."}, {"start": "00:04:49", "is_lecture": true, "end": "00:04:55", "is_worked_example": false, "text": "The result of the ALU's computation is sent back to the register file to be written into the RC register."}, {"start": "00:04:55", "is_lecture": true, "end": "00:05:05", "is_worked_example": false, "text": "Of course, we'll need to set WERF to 1 to enable the write. 5.oo Here we see one of the major advantages of a reduced-instruction set computer architecture:"}, {"start": "00:05:05", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "the datapath logic required for execution is very straightforward!"}, {"start": "00:05:10", "is_lecture": true, "end": "00:05:15", "is_worked_example": false, "text": "The other form of ALU instructions uses a constant as the second ALU operand."}, {"start": "00:05:15", "is_lecture": true, "end": "00:05:26", "is_worked_example": false, "text": "The 32-bit operand is formed by sign-extending the 16-bit two's complement constant stored in the literal field (bits [15:0]) of the instruction."}, {"start": "00:05:26", "is_lecture": true, "end": "00:05:32", "is_worked_example": false, "text": "In order to select the sign-extended constant as the second operand, we added a MUX to the datapath."}, {"start": "00:05:32", "is_lecture": true, "end": "00:05:39", "is_worked_example": false, "text": "When its BSEL control signal is 0, the output of the register file is selected as the operand."}, {"start": "00:05:39", "is_lecture": true, "end": "00:05:44", "is_worked_example": false, "text": "When BSEL is 1, the sign-extended constant is selected as the operand."}, {"start": "00:05:44", "is_lecture": true, "end": "00:05:47", "is_worked_example": false, "text": "The rest of the datapath logic is the same as before."}, {"start": "00:05:47", "is_lecture": true, "end": "00:05:54", "is_worked_example": false, "text": "Note that no logic gates are needed to perform sign-extension -- it's all done with wiring!"}, {"start": "00:05:54", "is_lecture": true, "end": "00:06:02", "is_worked_example": false, "text": "To sign-extend a two's complement number, we just need to replicate the high-order, or sign, bit as many times as necessary."}, {"start": "00:06:02", "is_lecture": true, "end": "00:06:08", "is_worked_example": false, "text": "You might find it useful to review the discussion of two's complement in Lecture 1 of Part 1 of the course."}, {"start": "00:06:08", "is_lecture": true, "end": "00:06:20", "is_worked_example": false, "text": "So to form a 32-bit operand from a 16-bit constant, we just replicate it's high-order bit (ID[15]) sixteen times as we make the connection to the BSEL MUX."}, {"start": "00:06:20", "is_lecture": true, "end": "00:06:28", "is_worked_example": false, "text": "During execution of ALU-with-constant instructions, the flow of data is much as it was before."}, {"start": "00:06:28", "is_lecture": true, "end": "00:06:37", "is_worked_example": false, "text": "The one difference is that the control logic sets the BSEL control signal to 1, selecting the sign-extended constant as the second ALU operand."}, {"start": "00:06:37", "is_lecture": true, "end": "00:06:48", "is_worked_example": false, "text": "As before, the control logic generates the appropriate ALU function code and the output of the ALU is routed to the register file to be written back to the RC register."}, {"start": "00:06:48", "is_lecture": true, "end": "00:06:54", "is_worked_example": false, "text": "Amazingly, this datapath is sufficient to execute most of the instructions in the Beta ISA!"}, {"start": "00:06:54", "is_lecture": true, "end": "00:06:59", "is_worked_example": false, "text": "We just have the memory and branch instruction left to implement."}, {"start": "00:06:59", "is_lecture": true, "end": "00:07:00", "is_worked_example": false, "text": "That's our next task."}]}, "C11S01B06-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c11/c11s1/6?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c11s1v6", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "Okay, let's review our plan."}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:07", "is_worked_example": false, "text": "The processor starts an access by sending an address to the cache."}, {"start": "00:00:07", "is_lecture": true, "end": "00:00:13", "is_worked_example": false, "text": "If data for the requested address is held in the cache, it's quickly returned to the CPU."}, {"start": "00:00:13", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "If the data we request is not in the cache, we have a cache miss, so the cache has to make a request to main memory to get the data, which it then returns to processor."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:30", "is_worked_example": false, "text": "Typically the cache will remember the newly fetched data, possibly replacing some older data in the cache."}, {"start": "00:00:30", "is_lecture": true, "end": "00:00:36", "is_worked_example": false, "text": "Suppose a cache access takes 4 ns and a main memory access takes 40 ns."}, {"start": "00:00:36", "is_lecture": true, "end": "00:00:45", "is_worked_example": false, "text": "Then an access that hits in the cache has a latency of 4 ns, but an access that misses in the cache has a latency of 44 ns."}, {"start": "00:00:45", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "The processor has to deal with the variable memory access time, perhaps by simply waiting for the access to complete, or, in modern hyper-threaded processors, it might execute an instruction or two from another programming thread."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "The hit and miss ratios tell us the fraction of accesses which are cache hits and the fraction of accesses which are cache misses."}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "Of course, the ratios will sum to 1."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:15", "is_worked_example": false, "text": "Using these metrics we can compute the average memory access time (AMAT)."}, {"start": "00:01:15", "is_lecture": true, "end": "00:01:21", "is_worked_example": false, "text": "Since we always check in the cache first, every access includes the cache access time (called the hit time)."}, {"start": "00:01:21", "is_lecture": true, "end": "00:01:28", "is_worked_example": false, "text": "If we miss in the cache, we have to take the additional time needed to access main memory (called the miss penalty)."}, {"start": "00:01:28", "is_lecture": true, "end": "00:01:35", "is_worked_example": false, "text": "But the main memory access only happens on some fraction of the accesses: the miss ratio tells us how often that occurs."}, {"start": "00:01:35", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "So the AMAT can be computed using the formula shown here."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:49", "is_worked_example": false, "text": "The lower the miss ratio (or, equivalently, the higher the hit ratio), the smaller the average access time."}, {"start": "00:01:49", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "Our design goal for the cache is to achieve a high hit ratio."}, {"start": "00:01:53", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "If we have multiple levels of cache, we can apply the formula recursively to calculate the AMAT at each level of the memory."}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:13", "is_worked_example": false, "text": "Each successive level of the cache is slower, i.e., has a longer hit time, which is offset by lower miss ratio because of its increased size."}, {"start": "00:02:13", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "Let's try out some numbers."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "Suppose the cache takes 4 processor cycles to respond, and main memory takes 100 cycles."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "Without the cache, each memory access would take 100 cycles."}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:32", "is_worked_example": false, "text": "With the cache, a cache hit takes 4 cycles, and a cache miss takes 104 cycles."}, {"start": "00:02:32", "is_lecture": true, "end": "00:02:41", "is_worked_example": false, "text": "What hit ratio is needed to so that the AMAT with the cache is 100 cycles, the break-even point?"}, {"start": "00:02:41", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "Using the AMAT formula from the previously slide, we see that we only need a hit ratio of 4% in order for memory system of the Cache + Main Memory to perform as well as Main Memory alone."}, {"start": "00:02:55", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "The idea, of course, is that we'll be able to do much better than that."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "Suppose we wanted an AMAT of 5 cycles."}, {"start": "00:03:04", "is_lecture": true, "end": "00:03:08", "is_worked_example": false, "text": "Clearly most of the accesses would have to be cache hits."}, {"start": "00:03:08", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "We can use the AMAT formula to compute the necessary hit ratio."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "Working through the arithmetic we see that 99% of the accesses must be cache hits in order to achieve an average access time of 5 cycles."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:28", "is_worked_example": false, "text": "Could we expect to do that well when running actual programs?"}, {"start": "00:03:28", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "Happily, we can come close."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:43", "is_worked_example": false, "text": "In a simulation of the Spec CPU2000 Benchmark, the hit ratio for a standard-size level 1 cache was measured to be 97.5% over some ~10 trillion accesses."}, {"start": "00:03:43", "is_lecture": true, "end": "00:03:44", "is_worked_example": false, "text": "[See the \"All benchmarks\" arithmetic-mean table at http://research.cs.wisc.edu/multifacet/misc/spec2000cache-data/]"}, {"start": "00:03:44", "is_lecture": true, "end": "00:03:46", "is_worked_example": false, "text": "Here's a start at building a cache."}, {"start": "00:03:46", "is_lecture": true, "end": "00:03:50", "is_worked_example": false, "text": "The cache will hold many different blocks of data."}, {"start": "00:03:50", "is_lecture": true, "end": "00:03:53", "is_worked_example": false, "text": "For now let's assume each block is an individual memory location."}, {"start": "00:03:53", "is_lecture": true, "end": "00:03:57", "is_worked_example": false, "text": "Each data block is \"tagged\" with its address."}, {"start": "00:03:57", "is_lecture": true, "end": "00:04:03", "is_worked_example": false, "text": "A combination of a data block and its associated address tag is called a cache line."}, {"start": "00:04:03", "is_lecture": true, "end": "00:04:11", "is_worked_example": false, "text": "When an address is received from the CPU, we'll search the cache looking for a block with a matching address tag."}, {"start": "00:04:11", "is_lecture": true, "end": "00:04:15", "is_worked_example": false, "text": "If we find a matching address tag, we have a cache hit."}, {"start": "00:04:15", "is_lecture": true, "end": "00:04:19", "is_worked_example": false, "text": "On a read access, we'll return the data from the matching cache line."}, {"start": "00:04:19", "is_lecture": true, "end": "00:04:28", "is_worked_example": false, "text": "On a write access, we'll update the data stored in the cache line and, at some point, update the corresponding location in main memory."}, {"start": "00:04:28", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "If no matching tag is found, we have a cache miss."}, {"start": "00:04:33", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "So we'll have to choose a cache line to use to hold the requested data, which means that some previously cached location will no longer be found in the cache."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:55", "is_worked_example": false, "text": "For a read operation, we'll fetch the requested data from main memory, add it to the cache (updating the tag and data fields of the cache line) and, of course, return the data to the CPU."}, {"start": "00:04:55", "is_lecture": true, "end": "00:05:04", "is_worked_example": false, "text": "On a write, we'll update the tag and data in the selected cache line and, at some point, update the corresponding location in main memory."}, {"start": "00:05:04", "is_lecture": true, "end": "00:05:11", "is_worked_example": false, "text": "So the contents of the cache is determined by the memory requests made by the CPU."}, {"start": "00:05:11", "is_lecture": true, "end": "00:05:20", "is_worked_example": false, "text": "If the CPU requests a recently-used address, chances are good the data will still be in the cache from the previous access to the same location."}, {"start": "00:05:20", "is_lecture": true, "end": "00:05:26", "is_worked_example": false, "text": "As the working set slowly changes, the cache contents will be updated as needed."}, {"start": "00:05:26", "is_lecture": true, "end": "00:05:26", "is_worked_example": false, "text": "If the entire working set can fit into the cache, most of the requests will be hits and the AMAT will be close to the cache access time."}, {"start": "00:05:26", "is_lecture": true, "end": "00:05:38", "is_worked_example": false, "text": "So far, so good!"}, {"start": "00:05:38", "is_lecture": true, "end": "00:05:51", "is_worked_example": false, "text": "Of course, we'll need to figure how to quickly search the cache, i.e., we'll a need fast way to answer the question of whether a particular address tag can be found in some cache line."}, {"start": "00:05:51", "is_lecture": true, "end": "00:05:54", "is_worked_example": false, "text": "That's our next topic."}]}, "C06S01B07-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c6/c6s1/7?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c6s1v7", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:09", "is_worked_example": false, "text": "The syntax tree is a useful intermediate representation (IR) that is independent of both the source language and the target ISA."}, {"start": "00:00:09", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "It contains information about the sequencing and grouping of operations that isn't apparent in individual machine language instructions."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "And it allows frontends for different source languages to share a common backend targeting a specific ISA."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "As we'll see, the backend processing can be split into two sub-phases."}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "The first performs machine-independent optimizations on the IR."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:45", "is_worked_example": false, "text": "The optimized IR is then translated by the code generation phase into sequences of instructions for the target ISA."}, {"start": "00:00:45", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "A common IR is to reorganize the syntax tree into what's called a control flow graph (CFG)."}, {"start": "00:00:53", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "Each node in the graph is a sequence of assignment and expression evaluations that ends with a branch."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:06", "is_worked_example": false, "text": "The nodes are called \"basic blocks\" and represent sequences of operations that are executed as a unit."}, {"start": "00:01:06", "is_lecture": true, "end": "00:01:15", "is_worked_example": false, "text": "Once the first operation in a basic block is performed, the remaining operations will also be performed without any other intervening operations."}, {"start": "00:01:15", "is_lecture": true, "end": "00:01:32", "is_worked_example": false, "text": "This knowledge lets us consider many optimizations, e.g., temporarily storing variable values in registers, that would be complicated if there was the possibility that other operations outside the block might also need to access the variable values while we were in the middle of this block."}, {"start": "00:01:32", "is_lecture": true, "end": "00:01:39", "is_worked_example": false, "text": "The edges of the graph indicate the branches that take us to another basic block."}, {"start": "00:01:39", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "For example, here's the CFG for GCD."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:54", "is_worked_example": false, "text": "If a basic block ends with a conditional branch, there are two edges, labeled \"T\" and \"F\" leaving the block that indicate the next block to execute depending on the outcome of the test."}, {"start": "00:01:54", "is_lecture": true, "end": "00:02:03", "is_worked_example": false, "text": "Other blocks have only a single departing arrow, indicating that the block always transfers control to the block indicated by the arrow."}, {"start": "00:02:03", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "Note that if we can arrive at a block from only a single predecessor block, then any knowledge we have about operations and variables from the predecessor block can be carried over to the destination block."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:32", "is_worked_example": false, "text": "For example, if the \"if (x > y)\" block has generated code to load the values of x and y into registers, both destination blocks can use that information and use the appropriate registers without having to generate their own LDs."}, {"start": "00:02:32", "is_lecture": true, "end": "00:02:38", "is_worked_example": false, "text": "But if a block has multiple predecessors, such optimizations are more constrained."}, {"start": "00:02:38", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "We can only use knowledge that is common to *all* the predecessor blocks."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:48", "is_worked_example": false, "text": "The CFG looks a lot like the state transition diagram for a high-level FSM!"}, {"start": "00:02:48", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "We'll optimize the IR by performing multiple passes over the CFG."}, {"start": "00:02:55", "is_lecture": true, "end": "00:03:00", "is_worked_example": false, "text": "Each pass performs a specific, simple optimization."}, {"start": "00:03:00", "is_lecture": true, "end": "00:03:08", "is_worked_example": false, "text": "We'll repeatedly apply the simple optimizations in multiple passes, until we can't find any further optimizations to perform."}, {"start": "00:03:08", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "Collectively, the simple optimizations can combine to achieve very complex optimizations."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:17", "is_worked_example": false, "text": "Here are some example optimizations:"}, {"start": "00:03:17", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "We can eliminate assignments to variables that are never used and basic blocks that are never reached."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "This is called \"dead code elimination\"."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:35", "is_worked_example": false, "text": "In constant propagation, we identify variables that have a constant value and substitute that constant in place of references to the variable."}, {"start": "00:03:35", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "We can compute the value of expressions that have constant operands."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "This is called \"constant folding\"."}, {"start": "00:03:41", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "To illustrate how these optimizations work, consider this slightly silly source program and its CFG."}, {"start": "00:03:49", "is_lecture": true, "end": "00:04:00", "is_worked_example": false, "text": "Note that we've broken down complicated expressions into simple binary operations, using temporary variable names (e.g, \"_t1\") to name the intermediate results."}, {"start": "00:04:00", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "Let's get started!"}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "The dead code elimination pass can remove the assignment to Z in the first basic block since Z is reassigned in subsequent blocks and the intervening code makes no reference to Z."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:17", "is_worked_example": false, "text": "Next we look for variables with constant values."}, {"start": "00:04:17", "is_lecture": true, "end": "00:04:26", "is_worked_example": false, "text": "Here we find that X is assigned the value of 3 and is never re-assigned, so we can replace all references to X with the constant 3."}, {"start": "00:04:26", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "Now perform constant folding [CLICK], evaluating any constant expressions."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:38", "is_worked_example": false, "text": "Here's the updated CFG, ready for another round of optimizations."}, {"start": "00:04:38", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "First dead code elimination."}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "Then constant propagation."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:46", "is_worked_example": false, "text": "And, finally, constant folding."}, {"start": "00:04:46", "is_lecture": true, "end": "00:04:52", "is_worked_example": false, "text": "So after two rounds of these simple operations, we've thinned out a number of assignments."}, {"start": "00:04:52", "is_lecture": true, "end": "00:04:54", "is_worked_example": false, "text": "On to round three!"}, {"start": "00:04:54", "is_lecture": true, "end": "00:04:56", "is_worked_example": false, "text": "Dead code elimination."}, {"start": "00:04:56", "is_lecture": true, "end": "00:05:07", "is_worked_example": false, "text": "And here we can determine the outcome of a conditional branch, eliminating entire basic blocks from the IR, either because they're now empty or because they can no longer be reached."}, {"start": "00:05:07", "is_lecture": true, "end": "00:05:12", "is_worked_example": false, "text": "Wow, the IR is now considerably smaller."}, {"start": "00:05:12", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "Next is another application of constant propagation."}, {"start": "00:05:17", "is_lecture": true, "end": "00:05:19", "is_worked_example": false, "text": "And then constant folding."}, {"start": "00:05:19", "is_lecture": true, "end": "00:05:23", "is_worked_example": false, "text": "Followed by more dead code elimination."}, {"start": "00:05:23", "is_lecture": true, "end": "00:05:29", "is_worked_example": false, "text": "The passes continue until we discover there are no further optimizations to perform, so we're done!"}, {"start": "00:05:29", "is_lecture": true, "end": "00:05:39", "is_worked_example": false, "text": "Repeated applications of these simple transformations have transformed the original program into an equivalent program that computes the same final value for Z."}, {"start": "00:05:39", "is_lecture": true, "end": "00:05:50", "is_worked_example": false, "text": "We can do more optimizations by adding passes: eliminating redundant computation of common subexpressions, moving loop-independent calculations out of loops,"}, {"start": "00:05:50", "is_lecture": true, "end": "00:06:00", "is_worked_example": false, "text": "unrolling short loops to perform the effect of, say, two iterations in a single loop execution, saving some of the cost of increment and test instructions."}, {"start": "00:06:00", "is_lecture": true, "end": "00:06:08", "is_worked_example": false, "text": "Optimizing compilers have a sophisticated set of optimizations they employ to make smaller and more efficient code."}, {"start": "00:06:08", "is_lecture": true, "end": "00:06:11", "is_worked_example": false, "text": "Okay, we're done with optimizations."}, {"start": "00:06:11", "is_lecture": true, "end": "00:06:14", "is_worked_example": false, "text": "Now it's time to generate instructions for the target ISA."}, {"start": "00:06:14", "is_lecture": true, "end": "00:06:19", "is_worked_example": false, "text": "First the code generator assigns each variable a dedicated register."}, {"start": "00:06:19", "is_lecture": true, "end": "00:06:26", "is_worked_example": false, "text": "If we have more variables than registers, some variables are stored in memory and we'll use LD and ST to access them as needed."}, {"start": "00:06:26", "is_lecture": true, "end": "00:06:31", "is_worked_example": false, "text": "But frequently-used variables will almost certainly live as much as possible in registers."}, {"start": "00:06:31", "is_lecture": true, "end": "00:06:38", "is_worked_example": false, "text": "Use our templates from before to translate each assignment and operation into one or more instructions."}, {"start": "00:06:38", "is_lecture": true, "end": "00:06:43", "is_worked_example": false, "text": "The emit the code for each block, adding the appropriate labels and branches."}, {"start": "00:06:43", "is_lecture": true, "end": "00:06:49", "is_worked_example": false, "text": "Reorder the basic block code to eliminate unconditional branches wherever possible."}, {"start": "00:06:49", "is_lecture": true, "end": "00:06:54", "is_worked_example": false, "text": "And finally perform any target-specific peephole optimizations."}, {"start": "00:06:54", "is_lecture": true, "end": "00:07:02", "is_worked_example": false, "text": "Here's the original CFG for the GCD code, along with the slightly optimized CFG."}, {"start": "00:07:02", "is_lecture": true, "end": "00:07:09", "is_worked_example": false, "text": "GCD isn't as trivial as the previous example, so we've only been able to do a bit of constant propagation and constant folding."}, {"start": "00:07:09", "is_lecture": true, "end": "00:07:19", "is_worked_example": false, "text": "Note that we can't propagate knowledge about variable values from the top basic block to the following \"if\" block since the \"if\" block has multiple predecessors."}, {"start": "00:07:19", "is_lecture": true, "end": "00:07:25", "is_worked_example": false, "text": "Here's how the code generator will process the optimized CFG."}, {"start": "00:07:25", "is_lecture": true, "end": "00:07:29", "is_worked_example": false, "text": "First, it dedicates registers to hold the values for x and y."}, {"start": "00:07:29", "is_lecture": true, "end": "00:07:32", "is_worked_example": false, "text": "Then, it emits the code for each of the basic blocks."}, {"start": "00:07:32", "is_lecture": true, "end": "00:07:38", "is_worked_example": false, "text": "Next, reorganize the order of the basic blocks to eliminate unconditional branches wherever possible."}, {"start": "00:07:38", "is_lecture": true, "end": "00:07:42", "is_worked_example": false, "text": "The resulting code is pretty good."}, {"start": "00:07:42", "is_lecture": true, "end": "00:07:47", "is_worked_example": false, "text": "There no obvious changes that a human programmer might make to make the code faster or smaller."}, {"start": "00:07:47", "is_lecture": true, "end": "00:07:48", "is_worked_example": false, "text": "Good job, compiler!"}, {"start": "00:07:48", "is_lecture": true, "end": "00:07:56", "is_worked_example": false, "text": "Here are all the compilation steps shown in order, along with their input and output data structures."}, {"start": "00:07:56", "is_lecture": true, "end": "00:08:01", "is_worked_example": false, "text": "Collectively they transform the original source code into high-quality assembly code."}, {"start": "00:08:01", "is_lecture": true, "end": "00:08:09", "is_worked_example": false, "text": "The patient application of optimization passes often produces code that's more efficient than writing assembly language by hand."}, {"start": "00:08:09", "is_lecture": true, "end": "00:08:22", "is_worked_example": false, "text": "Nowadays, programmers are able to focus on getting the source code to achieve the desired functionality and leave the details of translation to instructions in the hands of the compiler."}]}, "C04S03B01-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c4/c4s1/1?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c4s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:09", "is_worked_example": false, "text": "In the previous lecture we developed the instruction set architecture for the Beta, the computer system we'll be building throughout this part of the course."}, {"start": "00:00:09", "is_lecture": true, "end": "00:00:12", "is_worked_example": false, "text": "The Beta incorporates two types of storage or memory."}, {"start": "00:00:12", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "In the CPU datapath there are 32 general-purpose registers, which can be read to supply source operands for the ALU or written with the ALU result."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "In the CPU's control logic there is a special-purpose register called the program counter, which contains the address of the memory location holding the next instruction to be executed."}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:45", "is_worked_example": false, "text": "The datapath and control logic are connected to a large main memory with a maximum capacity of 2^32 bytes, organized as 2^30 32-bit words."}, {"start": "00:00:45", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "This memory holds both data and instructions."}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "Beta instructions are 32-bit values comprised of various fields."}, {"start": "00:00:53", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "The 6-bit OPCODE field specifies the operation to be performed."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "The 5-bit Ra, Rb, and Rc fields contain register numbers, specifying one of the 32 general-purpose registers."}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:18", "is_worked_example": false, "text": "There are two instruction formats: one specifying an opcode and three registers, the other specifying an opcode, two registers, and a 16-bit signed constant."}, {"start": "00:01:18", "is_lecture": true, "end": "00:01:21", "is_worked_example": false, "text": "There three classes of instructions."}, {"start": "00:01:21", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "The ALU instructions perform an arithmetic or logic operation on two operands, producing a result that is stored in the destination register."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:37", "is_worked_example": false, "text": "The operands are either two values from the general-purpose registers, or one register value and a constant."}, {"start": "00:01:37", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "The yellow highlighting indicates instructions that use the second instruction format."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "The Load/Store instructions access main memory, either loading a value from main memory into a register, or storing a register value to main memory."}, {"start": "00:01:53", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "And, finally, there are branches and jumps whose execution may change the program counter and hence the address of the next instruction to be executed."}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:07", "is_worked_example": false, "text": "To program the Beta we'll need to load main memory with binary-encoded instructions."}, {"start": "00:02:07", "is_lecture": true, "end": "00:02:17", "is_worked_example": false, "text": "Figuring out each encoding is clearly the job for a computer, so we'll create a simple programming language that will let us specify the opcode and operands for each instruction."}, {"start": "00:02:17", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "So instead of writing the binary at the top of slide, we'll write assembly language statements to specify instructions in symbolic form."}, {"start": "00:02:24", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "Of course we still have think about which registers to use for which values and write sequences of instructions for more complex operations."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:45", "is_worked_example": false, "text": "By using a high-level language we can move up one more level abstraction and describe the computation we want in terms of variables and mathematical operations rather than registers and ALU functions."}, {"start": "00:02:45", "is_lecture": true, "end": "00:02:51", "is_worked_example": false, "text": "In this lecture we'll describe the assembly language we'll use for programming the Beta."}, {"start": "00:02:51", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "And in the next lecture we'll figure out how to translate high-level languages, such as C, into assembly language."}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "The layer cake of abstractions gets taller yet:"}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:08", "is_worked_example": false, "text": "we could write an interpreter for say, Python, in C and then write our application programs in Python."}, {"start": "00:03:08", "is_lecture": true, "end": "00:03:22", "is_worked_example": false, "text": "Nowadays, programmers often choose the programming language that's most suitable for expressing their computations, then, after perhaps many layers of translation, come up with a sequence of instructions that the Beta can actually execute."}, {"start": "00:03:22", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "Okay, back to assembly language, which we'll use to shield ourselves from the bit-level representations of instructions and from having to know the exact location of variables and instructions in memory."}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:45", "is_worked_example": false, "text": "A program called the \"assembler\" reads a text file containing the assembly language program and produces an array of 32-bit words that can be used to initialize main memory."}, {"start": "00:03:45", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "We'll learn the UASM assembly language, which is built into BSim, our simulator for the Beta ISA."}, {"start": "00:03:52", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "UASM is really just a fancy calculator!"}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:07", "is_worked_example": false, "text": "It reads arithmetic expressions and evaluates them to produce 8-bit values, which it then adds sequentially to the array of bytes which will eventually be loaded into the Beta's memory."}, {"start": "00:04:07", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "UASM supports several useful language features that make it easier to write assembly language programs."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:19", "is_worked_example": false, "text": "Symbols and labels let us give names to particular values and addresses."}, {"start": "00:04:19", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "And macros let us create shorthand notations for sequences of expressions that, when evaluated, will generate the binary representations for instructions and data."}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "Here's an example UASM source file."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:41", "is_worked_example": false, "text": "Typically we write one UASM statement on each line and can use spaces, tabs, and newlines to make the source as readable as possible."}, {"start": "00:04:41", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "We've added some color coding to help in our explanation."}, {"start": "00:04:44", "is_lecture": true, "end": "00:04:49", "is_worked_example": false, "text": "Comments (shown in green) allow us to add text annotations to the program."}, {"start": "00:04:49", "is_lecture": true, "end": "00:04:52", "is_worked_example": false, "text": "Good comments will help remind you how your program works."}, {"start": "00:04:52", "is_lecture": true, "end": "00:04:59", "is_worked_example": false, "text": "You really don't want to have figure out from scratch what a section of code does each time you need to modify or debug it!"}, {"start": "00:04:59", "is_lecture": true, "end": "00:05:02", "is_worked_example": false, "text": "There are two ways to add comments to the code."}, {"start": "00:05:02", "is_lecture": true, "end": "00:05:07", "is_worked_example": false, "text": "\"//\" starts a comment, which then occupies the rest of the source line."}, {"start": "00:05:07", "is_lecture": true, "end": "00:05:16", "is_worked_example": false, "text": "Any characters after \"//\" are ignored by the assembler, which will start processing statements again at the start of the next line in the source file."}, {"start": "00:05:16", "is_lecture": true, "end": "00:05:26", "is_worked_example": false, "text": "You can also enclose comment text using the delimiters \"/*\" and \"*/\" and the assembler will ignore everything in-between."}, {"start": "00:05:26", "is_lecture": true, "end": "00:05:38", "is_worked_example": false, "text": "Using this second type of comment, you can \"comment-out\" many lines of code by placing \"/*\" at the start and, many lines later, end the comment section with a \"*/\"."}, {"start": "00:05:38", "is_lecture": true, "end": "00:05:42", "is_worked_example": false, "text": "Symbols (shown in red) are symbolic names for constant values."}, {"start": "00:05:42", "is_lecture": true, "end": "00:05:52", "is_worked_example": false, "text": "Symbols make the code easier to understand, e.g., we can use N as the name for an initial value for some computation, in this case the value 12."}, {"start": "00:05:52", "is_lecture": true, "end": "00:05:58", "is_worked_example": false, "text": "Subsequent statements can refer to this value using the symbol N instead of entering the value 12 directly."}, {"start": "00:05:58", "is_lecture": true, "end": "00:06:03", "is_worked_example": false, "text": "When reading the program, we'll know that N means this particular initial value."}, {"start": "00:06:03", "is_lecture": true, "end": "00:06:13", "is_worked_example": false, "text": "So if later we want to change the initial value, we only have to change the definition of the symbol N rather than find all the 12's in our program and change them."}, {"start": "00:06:13", "is_lecture": true, "end": "00:06:22", "is_worked_example": false, "text": "In fact some of the other appearances of 12 might not refer to this initial value and so to be sure we only changed the ones that did,"}, {"start": "00:06:22", "is_lecture": true, "end": "00:06:27", "is_worked_example": false, "text": "we'd have to read and understand the whole program to make sure we only edited the right 12's."}, {"start": "00:06:27", "is_lecture": true, "end": "00:06:29", "is_worked_example": false, "text": "You can imagine how error-prone that might be!"}, {"start": "00:06:29", "is_lecture": true, "end": "00:06:33", "is_worked_example": false, "text": "So using symbols is a practice you want to follow!"}, {"start": "00:06:33", "is_lecture": true, "end": "00:06:37", "is_worked_example": false, "text": "Note that all the register names are shown in red."}, {"start": "00:06:37", "is_lecture": true, "end": "00:06:43", "is_worked_example": false, "text": "We'll define the symbols R0 through R31 to have the values 0 through 31."}, {"start": "00:06:43", "is_lecture": true, "end": "00:06:56", "is_worked_example": false, "text": "Then we'll use those symbols to help us understand which instruction operands are intended to be registers, e.g., by writing R1, and which operands are numeric values, e.g., by writing the number 1."}, {"start": "00:06:56", "is_lecture": true, "end": "00:07:01", "is_worked_example": false, "text": "We could just use numbers everywhere, but the code would be much harder to read and understand."}, {"start": "00:07:01", "is_lecture": true, "end": "00:07:08", "is_worked_example": false, "text": "Labels (shown in yellow) are symbols whose value are the address of a particular location in the program."}, {"start": "00:07:08", "is_lecture": true, "end": "00:07:13", "is_worked_example": false, "text": "Here, the label \"loop\" will be our name for the location of the MUL instruction in memory."}, {"start": "00:07:13", "is_lecture": true, "end": "00:07:19", "is_worked_example": false, "text": "In the BNE at the end of the code, we use the label \"loop\" to specify the MUL instruction as the branch target."}, {"start": "00:07:19", "is_lecture": true, "end": "00:07:25", "is_worked_example": false, "text": "So if R1 is non-zero, we want to branch back to the MUL instruction and start another iteration."}, {"start": "00:07:25", "is_lecture": true, "end": "00:07:33", "is_worked_example": false, "text": "We'll use indentation for most UASM statements to make it easy to spot the labels defined by the program."}, {"start": "00:07:33", "is_lecture": true, "end": "00:07:40", "is_worked_example": false, "text": "Indentation isn't required, it's just another habit assembly language programmers use to keep their programs readable."}, {"start": "00:07:40", "is_lecture": true, "end": "00:07:47", "is_worked_example": false, "text": "We use macro invocations (shown in blue) when we want to write Beta instructions."}, {"start": "00:07:47", "is_lecture": true, "end": "00:07:55", "is_worked_example": false, "text": "When the assembler encounters a macro, it \"expands\" the macro, replacing it with a string of text provided by in the macro's definition."}, {"start": "00:07:55", "is_lecture": true, "end": "00:08:03", "is_worked_example": false, "text": "During expansion, the provided arguments are textually inserted into the expanded text at locations specified in the macro definition."}, {"start": "00:08:03", "is_lecture": true, "end": "00:08:08", "is_worked_example": false, "text": "Think of a macro as shorthand for a longer text string we could have typed in."}, {"start": "00:08:08", "is_lecture": true, "end": "00:08:12", "is_worked_example": false, "text": "We'll show how all this works in the next video segment."}]}, "C03S01B12-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c3/c3s1/12?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c3s1v12", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "Finally, let's discuss the third class of instructions that let us change the program counter."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:19", "is_worked_example": false, "text": "Up until now, the program counter has simply been incremented by 4 at the end of each instruction, so that the next instruction comes from the memory location that immediately follows the location that held the current instruction,"}, {"start": "00:00:19", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "i.e., the Beta has been executing instructions sequentially from memory."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:37", "is_worked_example": false, "text": "But in many programs, such as in factorial, we need to disrupt sequential execution, either to loop back to repeat some earlier instruction, or to skip over instructions because of some data dependency."}, {"start": "00:00:37", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "We need a way to change the program counter based on data values generated by the program's execution."}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "In the factorial example, as long as b is not equal to 0, we need to keep executing the instructions that calculate a*b and decrement b."}, {"start": "00:00:53", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "So we need instructions to test the value of b after it's been decremented and if it's non-zero, change the PC to repeat the loop one more time."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:12", "is_worked_example": false, "text": "Changing the PC depending on some condition is implemented by a branch instruction, and the operation is referred to as a \"conditional branch\"."}, {"start": "00:01:12", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "When the branch is taken, the PC is changed and execution is restarted at the new location, which is called the branch target."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "If the branch is not taken, the PC is incremented by 4 and execution continues with the instruction following the branch."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:36", "is_worked_example": false, "text": "As the name implies, a branch instruction represents a potential fork in the execution sequence."}, {"start": "00:01:36", "is_lecture": true, "end": "00:01:44", "is_worked_example": false, "text": "We'll use branches to implement many different types of control structures: loops, conditionals, procedure calls, etc."}, {"start": "00:01:44", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "Branches instructions also use the instruction format with the 16-bit signed constant."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "The operation of the branch instructions are a bit complicated, so let's walk through their operation step-by-step."}, {"start": "00:01:56", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "Let's start by looking at the operation of the BEQ instruction."}, {"start": "00:03:41", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "First the usual PC+4 calculation is performed, giving us the address of the instruction following the BEQ."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "This value is written to the \"rc\" register whether or not the branch is taken."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:22", "is_worked_example": false, "text": "This feature of branches is pretty handy and we'll use it to implement procedure calls a couple of lectures from now."}, {"start": "00:02:22", "is_lecture": true, "end": "00:02:30", "is_worked_example": false, "text": "Note that if we don't need to remember the PC+4 value, we can specify R31 as the \"rc\" register."}, {"start": "00:02:30", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "Next, BEQ tests the value of the \"ra\" register to see if it's equal to 0."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:44", "is_worked_example": false, "text": "If it is equal to 0, the branch is taken and the PC is incremented by the amount specified in the constant field of the instruction."}, {"start": "00:02:44", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "Actually the constant, called an offset since we're using it to offset the PC, is treated as a word offset and is multiplied by 4 to convert it a byte offset since the PC uses byte addressing."}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "If the contents of the \"ra\" register is not equal to 0, the PC is incremented by 4 and execution continues with the instruction following the BEQ."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "Let me say a few more words about the offset."}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:17", "is_worked_example": false, "text": "The branches are using what's referred to as \"pc-relative addressing\"."}, {"start": "00:03:17", "is_lecture": true, "end": "00:03:27", "is_worked_example": false, "text": "That means the address of the branch target is specified relative to the address of the branch, or, actually, relative to the address of the instruction following the branch."}, {"start": "00:03:27", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "So an offset of 0 would refer to the instruction following the branch and an offset of -1 would refer to the branch itself."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:50", "is_worked_example": false, "text": "Negative offsets are called \"backwards branches\" and are usually seen at branches used at the end of loops, where the looping condition is tested and we branch backwards to the beginning of the loop if another iteration is called for."}, {"start": "00:03:50", "is_lecture": true, "end": "00:04:01", "is_worked_example": false, "text": "Positive offsets are called \"forward branches\" and are usually seen in code for \"if statements\", where we might skip over some part of the program if a condition is not true."}, {"start": "00:04:01", "is_lecture": true, "end": "00:04:08", "is_worked_example": false, "text": "We can use BEQ to implement a so-called unconditional branch, i.e., a branch that is always taken."}, {"start": "00:04:08", "is_lecture": true, "end": "00:04:16", "is_worked_example": false, "text": "If we test R31 to see if it's 0, that's always true, so BEQ(R31,...) would always branch to the specified target."}, {"start": "00:04:16", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "There's also a BNE instruction, identical to BEQ in its operation except the sense of the condition is reversed: the branch is taken if the value of register \"ra\" is non-zero."}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:34", "is_worked_example": false, "text": "It might seem that only testing for zero/non-zero doesn't let us do everything we might want to do."}, {"start": "00:04:34", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "For example, how would we branch if \"a < b\"?"}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:49", "is_worked_example": false, "text": "That's where the compare instructions come in -- they do more complicated comparisons, producing a non-zero value if the comparison is true and a zero value if the comparison is false."}, {"start": "00:04:49", "is_lecture": true, "end": "00:04:55", "is_worked_example": false, "text": "Then we can use BEQ and BNE to test the result of the comparison and branch appropriately."}, {"start": "00:04:55", "is_lecture": true, "end": "00:05:04", "is_worked_example": false, "text": "At long last we're finally in a position to write Beta code to compute factorial using the iterative algorithm shown in C code on the left."}, {"start": "00:05:04", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "In the Beta code, the loop starts at the second instruction and is marked with the \"L:\" label."}, {"start": "00:05:10", "is_lecture": true, "end": "00:05:16", "is_worked_example": false, "text": "The body of the loop consists of the required multiplication and the decrement of b."}, {"start": "00:05:16", "is_lecture": true, "end": "00:05:24", "is_worked_example": false, "text": "Then, in the fourth instruction, b is tested and, if it's non-zero, the BNE will branch back to the instruction with the label L."}, {"start": "00:05:24", "is_lecture": true, "end": "00:05:36", "is_worked_example": false, "text": "Note that in our symbolic notation for BEQ and BNE instructions we don't write the offset directly since that would be a pain to calculate and would change if we added or removed instructions from the loop."}, {"start": "00:05:36", "is_lecture": true, "end": "00:05:47", "is_worked_example": false, "text": "Instead we reference the instruction to which we want to branch, and the program that translates the symbolic code into the binary instruction fields will do the offset calculation for us."}, {"start": "00:05:47", "is_lecture": true, "end": "00:06:01", "is_worked_example": false, "text": "There's a satisfying similarity between the Beta code and the operations specified by the high-level FSM we created for computing factorial in the simple programmable datapath discussed earlier in this lecture."}, {"start": "00:06:01", "is_lecture": true, "end": "00:06:08", "is_worked_example": false, "text": "In this example, each state in the high-level FSM matches up nicely with a particular Beta instruction."}, {"start": "00:06:08", "is_lecture": true, "end": "00:06:19", "is_worked_example": false, "text": "We wouldn't expect that high degree of correspondence in general, but since our Beta datapath and the example datapath were very similar, the states and instructions match up pretty well."}]}, "C04S03B02-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x_2+3T2016/courseware/c4/c4s1/2?activate_block_id=block-v1%3AMITx%2B6.004.3x%2B2T2016%2Btype%40discussion%2Bblock%40c4s1v2", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "Let's follow along as the assembler processes our source file."}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:09", "is_worked_example": false, "text": "The assembler maintains a symbol table that maps symbols names to their numeric values."}, {"start": "00:00:09", "is_lecture": true, "end": "00:00:14", "is_worked_example": false, "text": "Initially the symbol table is loaded with mappings for all the register symbols."}, {"start": "00:00:14", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "The assembler reads the source file line-by-line, defining symbols and labels, expanding macros, or evaluating expressions to generate bytes for the output array."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:32", "is_worked_example": false, "text": "Whenever the assembler encounters a use of a symbol or label, it's replaced by the corresponding numeric value found in the symbol table."}, {"start": "00:00:32", "is_lecture": true, "end": "00:00:42", "is_worked_example": false, "text": "The first line, N = 12, defines the value of the symbol N to be 12, so the appropriate entry is made in the symbol table."}, {"start": "00:00:42", "is_lecture": true, "end": "00:00:51", "is_worked_example": false, "text": "Advancing to the next line, the assembler encounters an invocation of the ADDC macro with the arguments \"r31\", \"N\", and \"r1\"."}, {"start": "00:00:51", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "As we'll see in a couple of slides, this triggers a series of nested macro expansions that eventually lead to generating a 32-bit binary value to be placed in memory location 0."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "The 32-bit value is formatted here to show the instruction fields and the destination address is shown in brackets."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "The next instruction is processed in the same way, generating a second 32-bit word."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:25", "is_worked_example": false, "text": "On the fourth line, the label loop is defined to have the value of the location in memory that's about to filled, in this case, location 8."}, {"start": "00:01:25", "is_lecture": true, "end": "00:01:34", "is_worked_example": false, "text": "So the appropriate entry is made in the symbol table and the MUL macro is expanded into the 32-bit word to be placed in location 8."}, {"start": "00:01:34", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "The assembler processes the file line-by-line until it reaches the end of the file."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "Actually the assembler makes two passes through the file."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "On the first pass it loads the symbol table with the values from all the symbol and label definitions."}, {"start": "00:01:48", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "Then, on the second pass, it generates the binary output. .152 The two-pass approach allows a statement to refer to symbol or label that is defined later in the file, e.g., a forward branch instruction could refer to the label for an instruction later in the program."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "As we saw in the previous slide, there's nothing magic about the register symbols."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:13", "is_worked_example": false, "text": "They are just symbolic names for the values 0 through 31."}, {"start": "00:02:13", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "So when processing ADDC(r31,N,r1), UASM replaces the symbols with their values and actually expands ADDC(31,12,1)."}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:28", "is_worked_example": false, "text": "UASM is very simple."}, {"start": "00:02:28", "is_lecture": true, "end": "00:02:34", "is_worked_example": false, "text": "It simply replaces symbols with their values, expands macros and evaluates expressions."}, {"start": "00:02:34", "is_lecture": true, "end": "00:02:41", "is_worked_example": false, "text": "So if you use a register symbol where a numeric value is expected, the value of the symbol is used as the numeric constant."}, {"start": "00:02:41", "is_lecture": true, "end": "00:02:43", "is_worked_example": false, "text": "Probably not what the programmer intended."}, {"start": "00:02:43", "is_lecture": true, "end": "00:02:56", "is_worked_example": false, "text": "Similarly, if you use a symbol or expression where a register number is expected, the low-order 5 bits of the value is used as the register number, in this example, as the Rb register number."}, {"start": "00:02:56", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "Again probably not what the programmer intended."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "The moral of the story is that when writing UASM assembly language programs, you have to keep your wits about you and recognize that the interpretation of an operand is determined by the opcode macro, not by the way you wrote the operand."}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "Recall from Lecture 9 that branch instructions use the 16-bit constant field of the instruction to encode the address of the branch target as a word offset from the location of the branch instruction."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:37", "is_worked_example": false, "text": "Well, actually the offset is calculated from the instruction immediately following the branch, so an offset of -1 would refer to the branch itself."}, {"start": "00:03:37", "is_lecture": true, "end": "00:03:47", "is_worked_example": false, "text": "The calculation of the offset is a bit tedious to do by hand and would, of course, change if we added or removed instructions between the branch instruction and branch target."}, {"start": "00:03:47", "is_lecture": true, "end": "00:03:57", "is_worked_example": false, "text": "Happily macros for the branch instructions incorporate the necessary formula to compute the offset from the address of the branch and the address of the branch target."}, {"start": "00:03:57", "is_lecture": true, "end": "00:04:05", "is_worked_example": false, "text": "So we just specify the address of the branch target, usually with a label, and let UASM do the heavy lifting."}, {"start": "00:04:05", "is_lecture": true, "end": "00:04:15", "is_worked_example": false, "text": "Here we see that BNE branches backwards by three instructions (remember to count from the instruction following the branch) so the offset is -3."}, {"start": "00:04:15", "is_lecture": true, "end": "00:04:24", "is_worked_example": false, "text": "The 16-bit two's complement representation of -3 is the value placed in the constant field of the BNE instruction."}]}}
