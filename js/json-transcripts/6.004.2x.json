{"C03S01B05-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s1/5?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s1v5", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "The Beta is an example of a reduced-instruction-set computer (RISC) architecture."}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:13", "is_worked_example": false, "text": "\"Reduced\" refers to the fact that in the Beta ISA, most instructions only access the internal registers for their operands and destination."}, {"start": "00:00:13", "is_lecture": true, "end": "00:00:22", "is_worked_example": false, "text": "Memory values are loaded and stored using separate memory-access instructions, which implement only a simple address calculation."}, {"start": "00:00:22", "is_lecture": true, "end": "00:00:30", "is_worked_example": false, "text": "These reductions lead to smaller, higher-performance hardware implementations and simpler compilers on the software side."}, {"start": "00:00:30", "is_lecture": true, "end": "00:00:34", "is_worked_example": false, "text": "The ARM and MIPS ISAs are other examples of RISC architectures."}, {"start": "00:00:34", "is_lecture": true, "end": "00:00:38", "is_worked_example": false, "text": "Intel's x86 ISA is more complex."}, {"start": "00:00:38", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "There is a limited amount of storage inside of the CPU -- using the language of sequential logic, we'll refer to this as the CPU state."}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:55", "is_worked_example": false, "text": "There's a 32-bit program counter (PC for short) that holds the address of the current instruction in main memory."}, {"start": "00:00:55", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "And there are thirty-two registers, numbered 0 through 31."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "Each register holds a 32-bit value."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "We'll use use 5-bit fields in the instruction to specify the number of the register to be used an operand or destination."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:23", "is_worked_example": false, "text": "As shorthand, we'll refer to a register using the prefix \"R\" followed by its number, e.g., \"R0\" refers to the register selected by the 5-bit field 0b00000."}, {"start": "00:01:23", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "Register 31 (R31) is special -- its value always reads as 0 and writes to R31 have no affect on its value."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "The number of bits in each register and hence the number of bits supported by ALU operations is a fundamental parameter of the ISA."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:45", "is_worked_example": false, "text": "The Beta is a 32-bit architecture."}, {"start": "00:01:45", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "Many modern computers are 64-bit architectures, meaning they have 64-bit registers and a 64-bit datapath."}, {"start": "00:01:53", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "Main memory is an array of 32-bit words."}, {"start": "00:01:56", "is_lecture": true, "end": "00:01:59", "is_worked_example": false, "text": "Each word contains four 8-bit bytes."}, {"start": "00:01:59", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "The bytes are numbered 0 through 3, with byte 0 corresponding to the low-order 7 bits of the 32-bit value, and so on."}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:14", "is_worked_example": false, "text": "The Beta ISA only supports word accesses, either loading or storing full 32-bit words."}, {"start": "00:02:14", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "Most \"real\" computers also support accesses to bytes and half-words."}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:28", "is_worked_example": false, "text": "Even though the Beta only accesses full words, following a convention used by many ISAs it uses byte addresses."}, {"start": "00:02:28", "is_lecture": true, "end": "00:02:35", "is_worked_example": false, "text": "Since there are 4 bytes in each word, consecutive words in memory have addresses that differ by 4."}, {"start": "00:02:35", "is_lecture": true, "end": "00:02:41", "is_worked_example": false, "text": "So the first word in memory has address 0, the second word address 4, and so on."}, {"start": "00:02:41", "is_lecture": true, "end": "00:02:46", "is_worked_example": false, "text": "You can see the addresses to left of each memory location in the diagram shown here."}, {"start": "00:02:46", "is_lecture": true, "end": "00:02:56", "is_worked_example": false, "text": "Note that we'll usually use hexadecimal notation when specifying addresses and other binary values -- the \"0x\" prefix indicates when a number is in hex."}, {"start": "00:02:56", "is_lecture": true, "end": "00:03:03", "is_worked_example": false, "text": "When drawing a memory diagram, we'll follow the convention that addresses increase as you read from top to bottom."}, {"start": "00:03:03", "is_lecture": true, "end": "00:03:11", "is_worked_example": false, "text": "The Beta ISA supports 32-bit byte addressing, so an address fits exactly into one 32-bit register or memory location."}, {"start": "00:03:11", "is_lecture": true, "end": "00:03:21", "is_worked_example": false, "text": "The maximum memory size is 2^32 bytes or 2^30 words -- that's 4 gigabytes (4 GB) or one billion words of main memory."}, {"start": "00:03:21", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "Some Beta implementations might actually have a smaller main memory, i.e., one with fewer than 1 billion locations."}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:32", "is_worked_example": false, "text": "Why have separate registers and main memory?"}, {"start": "00:03:32", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "Well, modern programs and datasets are very large, so we'll want to have a large main memory to hold everything."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:51", "is_worked_example": false, "text": "But large memories are slow and usually only support access to one location at a time, so they don't make good storage for use in each instruction which needs to access several operands and store a result."}, {"start": "00:03:51", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "If we used only one large storage array, then an instruction would need to have three 32-bit addresses to specify the two source operands and destination -- each instruction encoding would be huge!"}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:12", "is_worked_example": false, "text": "And the required memory accesses would have to be one-after-the-other, really slowing down instruction execution."}, {"start": "00:04:12", "is_lecture": true, "end": "00:04:22", "is_worked_example": false, "text": "On the other hand, if we use registers to hold the operands and serve as the destination, we can design the register hardware for parallel access and make it very fast."}, {"start": "00:04:22", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "To keep the speed up we won't be able to have very many registers -- a classic size-vs-speed performance tradeoff we see in digital systems all the time."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "In the end, the tradeoff leading to the best performance is to have a small number of very fast registers used by most instructions and a large but slow main memory."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:45", "is_worked_example": false, "text": "So that's what the BETA ISA does."}, {"start": "00:04:45", "is_lecture": true, "end": "00:04:50", "is_worked_example": false, "text": "In general, all program data will reside in main memory."}, {"start": "00:04:50", "is_lecture": true, "end": "00:04:58", "is_worked_example": false, "text": "Each variable used by the program \"lives\" in a specific main memory location and so has a specific memory address."}, {"start": "00:04:58", "is_lecture": true, "end": "00:05:11", "is_worked_example": false, "text": "For example, in the diagram below, the value of variable \"x\" is stored in memory location 0x1008, and the value of \"y\" is stored in memory location 0x100C, and so on."}, {"start": "00:05:11", "is_lecture": true, "end": "00:05:23", "is_worked_example": false, "text": "To perform a computation, e.g., to compute x*37 and store the result in y, we would have to first load the value of x into a register, say, R0."}, {"start": "00:05:23", "is_lecture": true, "end": "00:05:30", "is_worked_example": false, "text": "Then we would have the datapath multiply the value in R0 by 37, storing the result back into R0."}, {"start": "00:05:30", "is_lecture": true, "end": "00:05:37", "is_worked_example": false, "text": "Here we've assumed that the constant 37 is somehow available to the datapath and doesn't itself need to be loaded from memory."}, {"start": "00:05:37", "is_lecture": true, "end": "00:05:44", "is_worked_example": false, "text": "Finally, we would write the updated value in R0 back into memory at the location for y."}, {"start": "00:05:44", "is_lecture": true, "end": "00:05:46", "is_worked_example": false, "text": "Whew!  A lot of steps..."}, {"start": "00:05:46", "is_lecture": true, "end": "00:05:53", "is_worked_example": false, "text": "Of course, we could avoid all the loading and storing if we chose to keep the values for x and y in registers."}, {"start": "00:05:53", "is_lecture": true, "end": "00:06:01", "is_worked_example": false, "text": "Since there are only 32 registers, we can't do this for all of our variables, but maybe we could arrange to load x and y into registers,"}, {"start": "00:06:01", "is_lecture": true, "end": "00:06:12", "is_worked_example": false, "text": "do all the required computations involving x and y by referring to those registers, and then, when we're done, store changes to x and y back into memory for later use."}, {"start": "00:06:12", "is_lecture": true, "end": "00:06:20", "is_worked_example": false, "text": "Optimizing performance by keeping often-used values in registers is a favorite trick of programmers and compiler writers."}, {"start": "00:06:20", "is_lecture": true, "end": "00:06:30", "is_worked_example": false, "text": "So the basic program template is some loads to bring values into the registers, followed by computation, followed by any necessary stores."}, {"start": "00:06:30", "is_lecture": true, "end": "00:06:36", "is_worked_example": false, "text": "ISAs that use this template are usually referred to as \"load-store architectures\"."}]}, "C03S01B04-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s1/4?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s1v4", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "There are many approaches to building a general-purpose computer that can be easily re-programmed for new problems."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "Almost all modern computers are based on the \"stored program\" computer architecture developed by John von Neumann in 1945, which is now commonly referred to as the \"von Neumann model\"."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "The von Neumann model has three components."}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:28", "is_worked_example": false, "text": "There's a central processing unit (aka the CPU) that contains a datapath and control FSM as described previously."}, {"start": "00:00:28", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "The CPU is connected to a read/write memory that holds some number W of words, each with N bits."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "Nowadays, even small memories have a billion words and the width of each location is at least 32 bits (usually more)."}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "This memory is often referred to as \"main memory\" to distinguish it from other memories in the system."}, {"start": "00:00:49", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "You can think of it as an array: when the CPU wishes to operate on values in memory , it sends the memory an array index, which we call the address, and, after a short delay (currently 10's of nanoseconds) the memory will return the N-bit value stored at that address."}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:13", "is_worked_example": false, "text": "Writes to main memory follow the same protocol except, of course, the data flows in the opposite direction."}, {"start": "00:01:13", "is_lecture": true, "end": "00:01:17", "is_worked_example": false, "text": "We'll talk about memory technologies a couple of lectures from now."}, {"start": "00:01:17", "is_lecture": true, "end": "00:01:29", "is_worked_example": false, "text": "And, finally, there are input/output devices that enable the computer system to communicate with the outside world or to access data storage that, unlike main memory, will remember values even when turned off."}, {"start": "00:01:29", "is_lecture": true, "end": "00:01:36", "is_worked_example": false, "text": "The key idea is to use main memory to hold the instructions for the CPU as well as data."}, {"start": "00:01:36", "is_lecture": true, "end": "00:01:41", "is_worked_example": false, "text": "Both instructions and data are, of course, just binary data stored in main memory."}, {"start": "00:01:41", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "Interpreted as an instruction, a value in memory can be thought of as a set of fields containing one or bits encoding information about the actions to be performed by the CPU."}, {"start": "00:01:53", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "The opcode field indicates the operation to be performed (e.g., ADD, XOR, COMPARE)."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "Subsequent fields specify which registers supply the source operands and the destination register where the result is stored."}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:14", "is_worked_example": false, "text": "The CPU interprets the information in the instruction fields and performs the requested operation."}, {"start": "00:02:14", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "It would then move on to the next instruction in memory, executing the stored program step-by-step."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:29", "is_worked_example": false, "text": "The goal of this chapter is to discuss the details of what operations we want the CPU to perform, how many registers we should have, and so on."}, {"start": "00:02:29", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "Of course, some values in memory are not instructions!"}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "They might be binary data representing numeric values, strings of characters, and so on."}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:48", "is_worked_example": false, "text": "The CPU will read these values into its temporary registers when it needs to operate on them and write newly computed values back into memory."}, {"start": "00:02:48", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "Mr. Blue is asking a good question: how do we know which words in memory are instructions and which are data?"}, {"start": "00:02:55", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "After all, they're both binary values!"}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:06", "is_worked_example": false, "text": "The answer is that we can't tell by looking at the values -- it's how they are used by the CPU that distinguishes instructions from data."}, {"start": "00:03:06", "is_lecture": true, "end": "00:03:10", "is_worked_example": false, "text": "If a value is loaded into the datapath, it's being used as data."}, {"start": "00:03:10", "is_lecture": true, "end": "00:03:15", "is_worked_example": false, "text": "If a value is loaded by the control logic, it's being used an instruction."}, {"start": "00:03:15", "is_lecture": true, "end": "00:03:19", "is_worked_example": false, "text": "So this is the digital system we'll build to perform computations."}, {"start": "00:03:19", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "We'll start with a datapath that contains some number of registers to hold data values."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:32", "is_worked_example": false, "text": "We'll be able to select which registers will supply operands for the arithmetic and logic unit that will perform an operation."}, {"start": "00:03:32", "is_lecture": true, "end": "00:03:35", "is_worked_example": false, "text": "The ALU produces a result and other status signals."}, {"start": "00:03:35", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "The ALU result can be written back to one of the registers for later use."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:44", "is_worked_example": false, "text": "We'll provide the datapath with means to move data to and from main memory."}, {"start": "00:03:44", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "There will be a control unit that provides the necessary control signals to the datapath."}, {"start": "00:03:04", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "In the example datapath shown here, the control unit would provide ASEL and BSEL to select two register values as operands and DEST to select the register where the ALU result will be written."}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "If the datapath had, say, 32 internal registers, ASEL, BSEL and DEST would be 5-bit values, each specifying a particular register number in the range 0 to 31."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:31", "is_worked_example": false, "text": "The control unit also provides the FN function code that controls the operation performed by the ALU."}, {"start": "00:04:31", "is_lecture": true, "end": "00:04:30", "is_worked_example": false, "text": "The ALU we designed in Part 1 of the course requires a 6-bit function code to select between a variety of arithmetic, boolean and shift operations."}, {"start": "00:04:30", "is_lecture": true, "end": "00:04:35", "is_worked_example": false, "text": "The control unit would load values from main memory to be interpreted as instructions."}, {"start": "00:04:35", "is_lecture": true, "end": "00:04:45", "is_worked_example": false, "text": "The control unit contains a register, called the \"program counter\", that keeps track of the address in main memory of the next instruction to be executed."}, {"start": "00:04:45", "is_lecture": true, "end": "00:04:53", "is_worked_example": false, "text": "The control unit also contains a (hopefully small) amount of logic to translate the instruction fields into the necessary control signals."}, {"start": "00:04:53", "is_lecture": true, "end": "00:05:04", "is_worked_example": false, "text": "Note the control unit receives status signals from the datapath that will enable programs to execute different sequences of instructions if, for example, a particular data value was zero."}, {"start": "00:05:04", "is_lecture": true, "end": "00:05:11", "is_worked_example": false, "text": "The datapath serves as the brawn of our digital system and is responsible for storing and manipulating data values."}, {"start": "00:05:11", "is_lecture": true, "end": "00:05:21", "is_worked_example": false, "text": "The control unit serves as the brain of our system, interpreting the program stored in main memory and generating the necessary sequence of control signals for the datapath."}, {"start": "00:05:21", "is_lecture": true, "end": "00:05:25", "is_worked_example": false, "text": "Instructions are the fundamental unit of work."}, {"start": "00:05:25", "is_lecture": true, "end": "00:05:30", "is_worked_example": false, "text": "They're fetched by the control unit and executed one after another in the order they are fetched."}, {"start": "00:05:30", "is_lecture": true, "end": "00:05:39", "is_worked_example": false, "text": "Each instruction specifies the operation to be performed along with the registers to supply the source operands and destination register where the result will be stored."}, {"start": "00:05:39", "is_lecture": true, "end": "00:05:45", "is_worked_example": false, "text": "In a von Neumann machine, instruction execution involves the steps shown here:"}, {"start": "00:05:45", "is_lecture": true, "end": "00:05:51", "is_worked_example": false, "text": "the instruction is loaded from the memory location whose address is specified by the program counter."}, {"start": "00:05:51", "is_lecture": true, "end": "00:05:58", "is_worked_example": false, "text": "When the requested data is returned by the memory, the instruction fields are converted to the appropriate control signals for the datapath,"}, {"start": "00:05:58", "is_lecture": true, "end": "00:06:09", "is_worked_example": false, "text": "selecting the source operands from the specified registers, directing the ALU to perform the specified operation, and storing the result in the specified destination register."}, {"start": "00:06:09", "is_lecture": true, "end": "00:06:16", "is_worked_example": false, "text": "The final step in executing an instruction is updating the value of the program counter to be the address of the next instruction."}, {"start": "00:06:16", "is_lecture": true, "end": "00:06:20", "is_worked_example": false, "text": "This execution loop is performed again and again."}, {"start": "00:06:20", "is_lecture": true, "end": "00:06:24", "is_worked_example": false, "text": "Modern machines can execute up more than a billion instructions per second!"}, {"start": "00:06:24", "is_lecture": true, "end": "00:06:28", "is_worked_example": false, "text": "The discussion so far has been a bit abstract."}, {"start": "00:06:28", "is_lecture": true, "end": "00:06:33", "is_worked_example": false, "text": "Now it's time to roll up our sleeves and figure out what instructions we want our system to support."}, {"start": "00:06:33", "is_lecture": true, "end": "00:06:44", "is_worked_example": false, "text": "The specification of instruction fields and their meaning along with the details of the datapath design are collectively called the instruction set architecture (ISA) of the system."}, {"start": "00:06:44", "is_lecture": true, "end": "00:06:56", "is_worked_example": false, "text": "The ISA is a detailed functional specification of the operations and storage mechanisms and serves as a contract between the designers of the digital hardware and the programmers who will write the programs."}, {"start": "00:06:56", "is_lecture": true, "end": "00:07:06", "is_worked_example": false, "text": "Since the programs are stored in main memory and can hence be changed, we'll call them software, to distinguish them from the digital logic which, once implemented, doesn't change."}, {"start": "00:07:06", "is_lecture": true, "end": "00:07:11", "is_worked_example": false, "text": "It's the combination of hardware and software that determine the behavior of our system."}, {"start": "00:07:11", "is_lecture": true, "end": "00:07:20", "is_worked_example": false, "text": "The ISA is a new layer of abstraction: we can write programs for the system without knowing the implementation details of the hardware."}, {"start": "00:07:20", "is_lecture": true, "end": "00:07:27", "is_worked_example": false, "text": "As hardware technology improves we can build faster systems without having to change the software."}, {"start": "00:07:27", "is_lecture": true, "end": "00:07:41", "is_worked_example": false, "text": "You can see here that over a fifteen year timespan, the hardware for executing the Intel x86 instruction set went from executing 300,000 instructions per second to executing 5 billion instructions per second."}, {"start": "00:07:41", "is_lecture": true, "end": "00:07:51", "is_worked_example": false, "text": "Same software as before, we've just taken advantage of smaller and faster MOSFETs to build more complex circuits and faster execution engines."}, {"start": "00:07:51", "is_lecture": true, "end": "00:07:54", "is_worked_example": false, "text": "But a word of caution is in order!"}, {"start": "00:07:54", "is_lecture": true, "end": "00:08:06", "is_worked_example": false, "text": "It's tempting to make choices in the ISA that reflect the constraints of current technologies, e.g., the number of internal registers, the width of the operands, or the maximum size of main memory."}, {"start": "00:08:06", "is_lecture": true, "end": "00:08:23", "is_worked_example": false, "text": "But it will be hard to change the ISA when technology improves since there's a powerful economic incentive to ensure that old software can run on new machines, which means that a particular ISA can live for decades and span many generations of technology."}, {"start": "00:08:23", "is_lecture": true, "end": "00:08:29", "is_worked_example": false, "text": "If your ISA is successful, you'll have to live with any bad choices you made for a very long time."}, {"start": "00:08:29", "is_lecture": true, "end": "00:08:33", "is_worked_example": false, "text": "Designing an ISA is hard!"}, {"start": "00:08:33", "is_lecture": true, "end": "00:08:35", "is_worked_example": false, "text": "What are the operations that should be supported?"}, {"start": "00:08:35", "is_lecture": true, "end": "00:08:36", "is_worked_example": false, "text": "How many internal registers?"}, {"start": "00:08:36", "is_lecture": true, "end": "00:08:38", "is_worked_example": false, "text": "How much main memory?"}, {"start": "00:08:38", "is_lecture": true, "end": "00:08:45", "is_worked_example": false, "text": "Should we design the instruction encoding to minimize program size or to keep the logic in the control unit as simple as possible?"}, {"start": "00:08:45", "is_lecture": true, "end": "00:08:51", "is_worked_example": false, "text": "Looking into our crystal ball, what can we say about the computation and storage capabilities of future technologies?"}, {"start": "00:08:51", "is_lecture": true, "end": "00:08:56", "is_worked_example": false, "text": "We'll answer these questions by taking a quantitative approach."}, {"start": "00:08:56", "is_lecture": true, "end": "00:09:03", "is_worked_example": false, "text": "First we'll choose a set of benchmark programs, chosen as representative of the many types of programs we expect to run on our system."}, {"start": "00:09:03", "is_lecture": true, "end": "00:09:18", "is_worked_example": false, "text": "So some of benchmark programs will perform scientific and engineering computations, some will manipulate large data sets or perform database operations, some will require specialized computations for graphics or communications, and so on."}, {"start": "00:09:18", "is_lecture": true, "end": "00:09:25", "is_worked_example": false, "text": "Happily, after many decades of computer use, several standardized benchmark suites are available for us to use."}, {"start": "00:09:25", "is_lecture": true, "end": "00:09:33", "is_worked_example": false, "text": "We'll then implement the benchmark programs using our instruction set and simulate their execution on our proposed datapath."}, {"start": "00:09:33", "is_lecture": true, "end": "00:09:37", "is_worked_example": false, "text": "We'll evaluate the results to measure how well the system performs."}, {"start": "00:09:37", "is_lecture": true, "end": "00:09:40", "is_worked_example": false, "text": "But what do we mean by \"well\"?"}, {"start": "00:09:40", "is_lecture": true, "end": "00:09:48", "is_worked_example": false, "text": "That's where it gets interesting: \"well\" could refer to execution speed, energy consumption, circuit size, system cost, etc."}, {"start": "00:09:48", "is_lecture": true, "end": "00:09:56", "is_worked_example": false, "text": "If you're designing a smart watch, you'll make different choices than if you're designing a high-performance graphics card or a data-center server."}, {"start": "00:09:56", "is_lecture": true, "end": "00:10:03", "is_worked_example": false, "text": "Whatever metric you choose to evaluate your proposed system, there's an important design principle we can follow:"}, {"start": "00:10:03", "is_lecture": true, "end": "00:10:07", "is_worked_example": false, "text": "identify the common operations and focus on them as you optimize your design."}, {"start": "00:10:07", "is_lecture": true, "end": "00:10:17", "is_worked_example": false, "text": "For example, in general-purpose computing, almost all programs spend a lot of their time on simple arithmetic operations and accessing values in main memory."}, {"start": "00:10:17", "is_lecture": true, "end": "00:10:21", "is_worked_example": false, "text": "So those operations should be made as fast and energy efficient as possible."}, {"start": "00:10:21", "is_lecture": true, "end": "00:10:29", "is_worked_example": false, "text": "Now, let's get to work designing our own instruction set and execution engine, a system we'll call the Beta."}]}, "C06S01B02-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c6/c6s1/2?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c6s1v2", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:10", "is_worked_example": false, "text": "A compiler is a program that translates a high-level language program into a functionally equivalent sequence of machine instructions, i.e., an assembly language program."}, {"start": "00:00:10", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "A compiler first checks that the high-level program is correct, i.e., that the statements are well formed, the programmer isn't asking for nonsensical computations,"}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:28", "is_worked_example": false, "text": "e.g., adding a string value and an integer, or attempting to use the value of a variable before it has been properly initialized."}, {"start": "00:00:28", "is_lecture": true, "end": "00:00:44", "is_worked_example": false, "text": "The compiler may also provide warnings when operations may not produce the expected results, e.g., when converting from a floating-point number to an integer, where the floating-point value may be too large to fit in the number of bits provided by the integer."}, {"start": "00:00:44", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "If the program passes scrutiny, the compiler then proceeds to generate efficient sequences of instructions, often finding ways to rearrange the computation so that the resulting sequences are shorter and faster."}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "It's hard to beat a modern optimizing compiler at producing assembly language, since the compiler will patiently explore alternatives and deduce properties of the program that may not be apparent to even diligent assembly language programmers."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:18", "is_worked_example": false, "text": "In this section, we'll look at a simple technique for compiling C programs into assembly."}, {"start": "00:01:18", "is_lecture": true, "end": "00:01:24", "is_worked_example": false, "text": "Then, in the next section, we'll dive more deeply into how a modern compiler works."}, {"start": "00:01:24", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "There are two main routines in our simple compiler: compile_statement and compile_expr."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:35", "is_worked_example": false, "text": "The job of compile_statement is to compile a single statement from the source program."}, {"start": "00:01:35", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "Since the source program is a sequence of statements, we'll be calling compile_statement repeatedly."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "We'll focus on the compilation technique for four types of statements."}, {"start": "00:01:48", "is_lecture": true, "end": "00:01:52", "is_worked_example": false, "text": "An unconditional statement is simply an expression that's evaluated once."}, {"start": "00:01:52", "is_lecture": true, "end": "00:01:58", "is_worked_example": false, "text": "A compound statement is simply a sequence of statements to be executed in turn."}, {"start": "00:01:58", "is_lecture": true, "end": "00:02:06", "is_worked_example": false, "text": "Conditional statements, sometimes called \"if statements\", compute the value of an test expression, e.g., a comparison such as \"A < B\"."}, {"start": "00:02:06", "is_lecture": true, "end": "00:02:12", "is_worked_example": false, "text": "If the test is true then statement_1 is executed, otherwise statement_2 is executed."}, {"start": "00:02:12", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "Iteration statements also contain a test expression."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "In each iteration, if the test true, then the statement is executed, and the process repeats."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "If the test is false, the iteration is terminated."}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "The other main routine is compile_expr whose job it is to generate code to compute the value of an expression, leaving the result in some register."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:38", "is_worked_example": false, "text": "Expressions take many forms:"}, {"start": "00:02:38", "is_lecture": true, "end": "00:02:40", "is_worked_example": false, "text": "simple constant values"}, {"start": "00:02:40", "is_lecture": true, "end": "00:02:43", "is_worked_example": false, "text": "values from scalar or array variables,"}, {"start": "00:02:43", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "assignment expressions that compute a value and then store the result in some variable,"}, {"start": "00:03:49", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "unary or binary operations that combine the values of their operands with the specified operator."}, {"start": "00:02:55", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "Complex arithmetic expressions can be decomposed into sequences of unary and binary operations."}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "And, finally, procedure calls, where a named sequence of statements will be executed with the values of the supplied arguments assigned as the values for the formal parameters of the procedure."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "Compiling procedures and procedure calls is a topic that we'll tackle next lecture since there are some complications to understand and deal with."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:29", "is_worked_example": false, "text": "Happily, compiling the other types of expressions and statements is straightforward, so let's get started."}, {"start": "00:03:29", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "What code do we need to put the value of a constant into a register?"}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:43", "is_worked_example": false, "text": "If the constant will fit into the 16-bit constant field of an instruction, we can use CMOVE to load the sign-extended constant into a register."}, {"start": "00:03:43", "is_lecture": true, "end": "00:03:51", "is_worked_example": false, "text": "This approach works for constants between -32768 and +32767."}, {"start": "00:03:51", "is_lecture": true, "end": "00:03:58", "is_worked_example": false, "text": "If the constant is too large, it's stored in a main memory location and we use a LD instruction to get the value into a register."}, {"start": "00:03:58", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "Loading the value of a variable is much the same as loading the value of a large constant."}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:10", "is_worked_example": false, "text": "We use a LD instruction to access the memory location that holds the value of the variable."}, {"start": "00:04:10", "is_lecture": true, "end": "00:04:20", "is_worked_example": false, "text": "Performing an array access is slightly more complicated: arrays are stored as consecutive locations in main memory, starting with index 0."}, {"start": "00:04:20", "is_lecture": true, "end": "00:04:24", "is_worked_example": false, "text": "Each element of the array occupies some fixed number bytes."}, {"start": "00:04:24", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "So we need code to convert the array index into the actual main memory address for the specified array element."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:41", "is_worked_example": false, "text": "We first invoke compile_expr to generate code that evaluates the index expression and leaves the result in Rx."}, {"start": "00:04:41", "is_lecture": true, "end": "00:04:46", "is_worked_example": false, "text": "That will be a value between 0 and the size of the array minus 1."}, {"start": "00:04:46", "is_lecture": true, "end": "00:05:00", "is_worked_example": false, "text": "We'll use a LD instruction to access the appropriate array entry, but that means we need to convert the index into a byte offset, which we do by multiplying the index by bsize, the number of bytes in one element."}, {"start": "00:05:00", "is_lecture": true, "end": "00:05:04", "is_worked_example": false, "text": "If b was an array of integers, bsize would be 4."}, {"start": "00:05:04", "is_lecture": true, "end": "00:05:19", "is_worked_example": false, "text": "Now that we have the byte offset in a register, we can use LD to add the offset to the base address of the array computing the address of the desired array element, then load the memory value at that address into a register."}, {"start": "00:05:19", "is_lecture": true, "end": "00:05:21", "is_worked_example": false, "text": "Assignment expressions are easy"}, {"start": "00:05:21", "is_lecture": true, "end": "00:05:32", "is_worked_example": false, "text": "Invoke compile_expr to generate code that loads the value of the expression into a register, then generate a ST instruction to store the value into the specified variable."}, {"start": "00:05:32", "is_lecture": true, "end": "00:05:35", "is_worked_example": false, "text": "Arithmetic operations are pretty easy too."}, {"start": "00:05:35", "is_lecture": true, "end": "00:05:42", "is_worked_example": false, "text": "Use compile_expr to generate code for each of the operand expressions, leaving the results in registers."}, {"start": "00:05:42", "is_lecture": true, "end": "00:05:49", "is_worked_example": false, "text": "Then generate the appropriate ALU instruction to combine the operands and leave the answer in a register."}, {"start": "00:05:49", "is_lecture": true, "end": "00:05:53", "is_worked_example": false, "text": "Let's look at example to see how all this works."}, {"start": "00:05:53", "is_lecture": true, "end": "00:06:00", "is_worked_example": false, "text": "Here have an assignment expression that requires a subtract, a multiply, and an addition to compute the required value."}, {"start": "00:06:00", "is_lecture": true, "end": "00:06:07", "is_worked_example": false, "text": "Let's follow the compilation process from start to finish as we invoke compile_expr to generate the necessary code."}, {"start": "00:06:07", "is_lecture": true, "end": "00:06:17", "is_worked_example": false, "text": "Following the template for assignment expressions from the previous page, we recursively call compile_expr to compute value of the right-hand-side of the assignment."}, {"start": "00:06:17", "is_lecture": true, "end": "00:06:26", "is_worked_example": false, "text": "That's a multiply operation, so, following the Operations template, we need to compile the left-hand operand of the multiply."}, {"start": "00:06:26", "is_lecture": true, "end": "00:06:34", "is_worked_example": false, "text": "That's a subtract operation, so, we call compile_expr again to compile the left-hand operand of the subtract."}, {"start": "00:06:34", "is_lecture": true, "end": "00:06:43", "is_worked_example": false, "text": "Aha, we know how to get the value of a variable into a register. So we generate a LD instruction to load the value of x into r1."}, {"start": "00:06:43", "is_lecture": true, "end": "00:06:48", "is_worked_example": false, "text": "The process we're following is called \"recursive descent\"."}, {"start": "00:06:48", "is_lecture": true, "end": "00:06:54", "is_worked_example": false, "text": "We've used recursive calls to compile_expr to process each level of the expression tree."}, {"start": "00:06:54", "is_lecture": true, "end": "00:07:04", "is_worked_example": false, "text": "At each recursive call the expressions get simpler, until we reach a variable or constant, where we can generate the appropriate instruction without descending further."}, {"start": "00:07:04", "is_lecture": true, "end": "00:07:10", "is_worked_example": false, "text": "At this point we've reach a leaf of the expression tree and we're done with this branch of the recursion."}, {"start": "00:07:10", "is_lecture": true, "end": "00:07:16", "is_worked_example": false, "text": "Now we need to get the value of the right-hand operand of the subtract into a register."}, {"start": "00:07:16", "is_lecture": true, "end": "00:07:21", "is_worked_example": false, "text": "In case it's a small constant, so we generate a CMOVE instruction."}, {"start": "00:07:21", "is_lecture": true, "end": "00:07:31", "is_worked_example": false, "text": "Now that both operand values are in registers, we return to the subtract template and generate a SUB instruction to do the subtraction."}, {"start": "00:07:31", "is_lecture": true, "end": "00:07:36", "is_worked_example": false, "text": "We now have the value for the left-hand operand of the multiply in r1."}, {"start": "00:07:36", "is_lecture": true, "end": "00:07:49", "is_worked_example": false, "text": "We follow the same process for the right-hand operand of the multiply, recursively calling compile_expr to process each level of the expression until we reach a variable or constant."}, {"start": "00:07:49", "is_lecture": true, "end": "00:07:59", "is_worked_example": false, "text": "Then we return up the expression tree, generating the appropriate instructions as we go, following the dictates of the appropriate template from the previous slide."}, {"start": "00:07:59", "is_lecture": true, "end": "00:08:02", "is_worked_example": false, "text": "The generated code is shown on the left of the slide."}, {"start": "00:08:02", "is_lecture": true, "end": "00:08:09", "is_worked_example": false, "text": "The recursive-descent technique makes short work of generating code for even the most complicated of expressions."}, {"start": "00:08:09", "is_lecture": true, "end": "00:08:15", "is_worked_example": false, "text": "There's even opportunity to find some simple optimizations by looking at adjacent instructions."}, {"start": "00:08:15", "is_lecture": true, "end": "00:08:25", "is_worked_example": false, "text": "For example, a CMOVE followed by an arithmetic operation can often be shorted to a single arithmetic instruction with the constant as its second operand."}, {"start": "00:08:25", "is_lecture": true, "end": "00:08:33", "is_worked_example": false, "text": "These local transformations are called \"peephole optimizations\" since we're only considering just one or two instructions at a time."}]}, "C06S01B06-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c6/c6s1/6?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c6s1v6", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:11", "is_worked_example": false, "text": "A modern compiler starts by analyzing the source program text to produce an equivalent sequence of operations expressed in a language- and machine-independent intermediate representation (IR)."}, {"start": "00:00:11", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "The analysis, or frontend, phase checks that program is well-formed, i.e., that the syntax of each high-level language statement is correct."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:25", "is_worked_example": false, "text": "It understands the meaning (semantics) of each statement."}, {"start": "00:00:25", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "Many high-level languages include declarations of the type -- e.g., integer, floating point, string, etc. -- of each variable,"}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:45", "is_worked_example": false, "text": "and the frontend verifies that all operations are correctly applied, ensuring that numeric operations have numeric-type operands, string operations have string-type operands, and so on."}, {"start": "00:00:45", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "Basically the analysis phase converts the text of the source program into an internal data structure that specifies the sequence and type of operations to be performed."}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:09", "is_worked_example": false, "text": "Often there are families of frontend programs that translate a variety of high-level languages (e.g, C, C++, Java) into a common IR."}, {"start": "00:01:09", "is_lecture": true, "end": "00:01:19", "is_worked_example": false, "text": "The synthesis, or backend, phase then optimizes the IR to reduce the number of operations that will be executed when the final code is run."}, {"start": "00:01:19", "is_lecture": true, "end": "00:01:31", "is_worked_example": false, "text": "For example, it might find operations inside of a loop that are independent of the loop index and can moved outside the loop, where they are performed once instead of repeatedly inside the loop."}, {"start": "00:01:31", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "Once the IR is in its final optimized form, the backend generates code sequences for the target ISA and looks for further optimizations that take advantage of particular features of the ISA."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "For example, for the Beta ISA we saw how a CMOVE followed by an arithmetic operation can be shorted to a single operation with a constant operand."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:06", "is_worked_example": false, "text": "The analysis phase starts by scanning the source text and generating a sequence of token objects that identify the type of each piece of the source text."}, {"start": "00:02:06", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "While spaces, tabs, newlines, and so on were needed to separate tokens in the source text, they've all been removed during the scanning process."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "To enable useful error reporting, token objects also include information about where in the source text each token was found, e.g., the file name, line number, and column number."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "The scanning phase reports illegal tokens, e.g., the token \"3x\" would cause an error since in C it would not be a legal number or a legal variable name."}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "The parsing phase processes the sequence of tokens to build the syntax tree, which captures the structure of the original program in a convenient data structure."}, {"start": "00:02:50", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "The operands have been organized for each unary and binary operation."}, {"start": "00:02:55", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "The components of each statement have been found and labeled."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "The role of each source token has been determined and the information captured in the syntax tree."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:11", "is_worked_example": false, "text": "Compare the labels of the nodes in the tree to the templates we discussed in the previous segment."}, {"start": "00:03:11", "is_lecture": true, "end": "00:03:21", "is_worked_example": false, "text": "We can see that it would be easy to write a program that did a depth-first tree walk, using the label of each tree node to select the appropriate code generation template."}, {"start": "00:03:21", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "We won't do that quite yet since there's still some work to be done analyzing and transforming the tree."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:37", "is_worked_example": false, "text": "The syntax tree makes it easy to verify that the program is semantically correct, e.g., to check that the types of the operands are compatible with the requested operation."}, {"start": "00:03:37", "is_lecture": true, "end": "00:03:42", "is_worked_example": false, "text": "For example, consider the statement x = \"bananas\"."}, {"start": "00:03:42", "is_lecture": true, "end": "00:03:50", "is_worked_example": false, "text": "The syntax of the assignment operation is correct: there's a variable on the left-hand side and an expression on the right-hand side."}, {"start": "00:03:50", "is_lecture": true, "end": "00:03:53", "is_worked_example": false, "text": "But the semantics is not correct, at least in the C language!"}, {"start": "00:03:53", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "By looking in its symbol table to check the declared type for the variable x (int) and comparing it to the type of the expression (string),"}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:15", "is_worked_example": false, "text": "the semantic checker for the \"op =\" tree node will detect that the types are not compatible, i.e., that we can't store a string value into an integer variable."}, {"start": "00:04:15", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "When the semantic analysis is complete, we know that the syntax tree represents a syntactically correct program with valid semantics, and we've finished converting the source program into an equivalent, language-independent sequence of operations."}]}, "C04S03B10-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c4/c4s1/1?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c4s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:08", "is_worked_example": false, "text": "This video is optional, but we wanted to answer the question \"Are there uncomputable functions?\""}, {"start": "00:00:08", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "Yes, there are well-defined discrete functions that cannot be computed by any TM, i.e., no algorithm can compute f(x) for arbitrary finite x in a finite number of steps."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:27", "is_worked_example": false, "text": "It's not that we don't know the algorithm, we can actually prove that no algorithm exists."}, {"start": "00:00:27", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "So the finite memory limitations of FSMs wasn't the only barrier as to whether we can solve a problem."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:41", "is_worked_example": false, "text": "The most famous uncomputable function is the so-called Halting function."}, {"start": "00:00:41", "is_lecture": true, "end": "00:00:46", "is_worked_example": false, "text": "When TMs undertake a computation there two possible outcomes."}, {"start": "00:00:46", "is_lecture": true, "end": "00:00:52", "is_worked_example": false, "text": "Either the TM writes an answer onto the tape and halts, or the TM loops forever."}, {"start": "00:00:52", "is_lecture": true, "end": "00:00:56", "is_worked_example": false, "text": "The Halting function tells which outcome we'll get:"}, {"start": "00:00:56", "is_lecture": true, "end": "00:01:08", "is_worked_example": false, "text": "given two integer arguments k and j, the Halting function determines if the kth TM halts when given a tape containing j as the input."}, {"start": "00:01:08", "is_lecture": true, "end": "00:01:14", "is_worked_example": false, "text": "Let's quick sketch an argument as to why the Halting function is not computable."}, {"start": "00:01:14", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "Well, suppose it was computable, then it would be equivalent to some TM, say T_H."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "So we can use T_H to build another TM, T_N (the \"N\" stands for nasty!) that processes its single argument and either LOOPs or HALTs."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "T_N[X] is designed to loop if TM X given input X halts."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "And vice versa: T_N[X] halts if TM X given input X loops."}, {"start": "00:01:48", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "The idea is that T_N[X] does the opposite of whatever T_X[X] does."}, {"start": "00:01:56", "is_lecture": true, "end": "00:02:02", "is_worked_example": false, "text": "T_N is easy to implement assuming that we have T_H to answer the \"halts or loops\" question."}, {"start": "00:02:02", "is_lecture": true, "end": "00:02:09", "is_worked_example": false, "text": "Now consider what happens if we give N as the argument to T_N."}, {"start": "00:02:09", "is_lecture": true, "end": "00:02:20", "is_worked_example": false, "text": "From the definition of T_N, T_N[N] will LOOP if the halting function tells us that T_N[N] halts."}, {"start": "00:02:20", "is_lecture": true, "end": "00:02:31", "is_worked_example": false, "text": "And T_N[N] will HALT if the halting function tells us that T_N[N] loops."}, {"start": "00:02:31", "is_lecture": true, "end": "00:02:37", "is_worked_example": false, "text": "Obviously T_N[N] can't both LOOP and HALT at the same time!"}, {"start": "00:02:37", "is_lecture": true, "end": "00:02:48", "is_worked_example": false, "text": "So if the Halting function is computable and T_H exists, we arrive at this impossible behavior for T_N[N]."}, {"start": "00:02:48", "is_lecture": true, "end": "00:02:56", "is_worked_example": false, "text": "This tells us that T_H cannot exist and hence that the Halting function is not computable."}]}, "C04S03B04-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c4/c4s1/4?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c4s1v4", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "Let's take a closer look at how macros work in UASM."}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:11", "is_worked_example": false, "text": "Here we see the definition of the macro \"consec\" which has a single parameter \"n\"."}, {"start": "00:00:11", "is_lecture": true, "end": "00:00:14", "is_worked_example": false, "text": "The body of the macro is a sequence of four expressions."}, {"start": "00:00:14", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "When there's an invocation of the \"consec\" macro, in this example with the argument 37, the body of the macro is expanded replacing all occurrences of \"n\" with the argument 37."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:32", "is_worked_example": false, "text": "The resulting text is then processed as if it had appeared in place of the macro invocation."}, {"start": "00:00:32", "is_lecture": true, "end": "00:00:41", "is_worked_example": false, "text": "In this example, the four expressions are evaluated to give a sequence of four values that will be placed in the next four bytes of the output array."}, {"start": "00:00:41", "is_lecture": true, "end": "00:00:51", "is_worked_example": false, "text": "Macro expansions may contain other macro invocations, which themselves will be expanded, continuing until all that's left are expressions to be evaluated."}, {"start": "00:00:51", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "Here we see the macro definition for WORD, which assembles its argument into two consecutive bytes."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "And for the macro LONG, which assembles its argument into four consecutive bytes, using the WORD macro to process the low 16 bits of the value, then the high 16 bits of the value."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:21", "is_worked_example": false, "text": "These two UASM statements cause the constant 0xDEADBEEF to converted to 4 bytes, which are then deposited in the output array starting at index 0x100."}, {"start": "00:01:21", "is_lecture": true, "end": "00:01:29", "is_worked_example": false, "text": "Note that the Beta expects the least-significant byte of a multi-byte value to be stored at the lowest byte address."}, {"start": "00:01:29", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "So the least-significant byte 0xEF is placed at address 0x100 and the most-significant byte 0xDE is placed at address 0x103."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "This is the \"little-endian\" convention for multi-byte values: the least-significant byte comes first."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "Intel's x86 architecture is also little-endian."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "There is a symmetrical \"big-endian\" convention where the most-significant byte comes first."}, {"start": "00:01:56", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "Both conventions are in active use and, in fact, some ISAs can be configured to use either convention!"}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:23", "is_worked_example": false, "text": "There is no right answer for which convention to use, but the fact that there two conventions means that we have to be alert for the need to convert the representation of multi-byte values when moving values between one ISA and another, e.g., when we send a data file to another user."}, {"start": "00:02:23", "is_lecture": true, "end": "00:02:30", "is_worked_example": false, "text": "As you can imagine there are strong advocates for both schemes who are happy to defend their point of view at great length."}, {"start": "00:02:30", "is_lecture": true, "end": "00:02:46", "is_worked_example": false, "text": "Given the heat of the discussion, it's appropriate that the names for the conventions were drawn from Jonathan Swift's \"Gulliver's Travels\" in which a civil war is fought over whether to open a soft-boiled egg at its big end or its little end."}, {"start": "00:02:46", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "Let's look at the macros used to assemble Beta instructions."}, {"start": "00:02:50", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "The BETAOP helper macro supports the 3-register instruction format, taking as arguments the values to be placed in the OPCODE, Ra, Rb, and Rc fields."}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:16", "is_worked_example": false, "text": "The \".align 4\" directive is a bit of administrative bookkeeping to ensure that instructions will have a byte address that's a multiple of 4, i.e., that they span exactly one 32-bit word in memory."}, {"start": "00:03:16", "is_lecture": true, "end": "00:03:25", "is_worked_example": false, "text": "That's followed by an invocation of the LONG macro to generate the 4 bytes of binary data representing the value of the expression shown here."}, {"start": "00:03:25", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "The expression is where the actual assembly of the fields takes place."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "Each field is limited to requisite number of bits using the modulo operator (%), then shifted left (<<) to the correct position in the 32-bit word."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:46", "is_worked_example": false, "text": "And here are the helper macros for the instructions that use a 16-bit constant as the second operand."}, {"start": "00:03:46", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "Let's follow the assembly of an ADDC instruction to see how this works."}, {"start": "00:03:52", "is_lecture": true, "end": "00:04:03", "is_worked_example": false, "text": "The ADDC macro expands into an invocation of the BETAOPC helper macro, passing along the correct value for the ADDC opcode, along with the three operands."}, {"start": "00:04:03", "is_lecture": true, "end": "00:04:07", "is_worked_example": false, "text": "The BETAOPC macro does the following arithmetic:"}, {"start": "00:04:07", "is_lecture": true, "end": "00:04:15", "is_worked_example": false, "text": "the OP argument, in this case the value 0x30, is shifted left to occupy the high-order 6 bits of the instruction."}, {"start": "00:04:15", "is_lecture": true, "end": "00:04:21", "is_worked_example": false, "text": "Then the RA argument, in this case 15, is placed in its proper location."}, {"start": "00:04:21", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "The 16-bit constant -32768 is positioned in the low 16 bits of the instruction."}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:36", "is_worked_example": false, "text": "And, finally, the Rc argument, in this case 0, is positioned in the Rc field of the instruction."}, {"start": "00:04:36", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "You can see why we call this processing \"assembling an instruction\"."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:48", "is_worked_example": false, "text": "The binary representation of an instruction is assembled from the binary values for each of the instruction fields."}, {"start": "00:04:48", "is_lecture": true, "end": "00:04:56", "is_worked_example": false, "text": "It's not a complicated process, but it requires a lot of shifting and masking, tasks that we're happy to let a computer handle."}, {"start": "00:04:56", "is_lecture": true, "end": "00:05:07", "is_worked_example": false, "text": "Here's the entire sequence of macro expansions that assemble this ADDC instruction into an appropriate 32-bit binary value in main memory."}, {"start": "00:05:07", "is_lecture": true, "end": "00:05:15", "is_worked_example": false, "text": "You can see that the knowledge of Beta instruction formats and opcode values is built into the bodies of the macro definitions."}, {"start": "00:05:15", "is_lecture": true, "end": "00:05:18", "is_worked_example": false, "text": "The UASM processing is actually quite general."}, {"start": "00:05:18", "is_lecture": true, "end": "00:05:25", "is_worked_example": false, "text": "With a different set of macro definitions it could process assembly language programs for almost any ISA!"}, {"start": "00:05:25", "is_lecture": true, "end": "00:05:36", "is_worked_example": false, "text": "All the macro definitions for the Beta ISA are provided in the beta.uasm file, which is included in each of the assembly language lab assignments."}, {"start": "00:05:36", "is_lecture": true, "end": "00:05:44", "is_worked_example": false, "text": "Note that we include some convenience macros to define shorthand representations that provide common default values for certain operands."}, {"start": "00:05:44", "is_lecture": true, "end": "00:05:53", "is_worked_example": false, "text": "For example, except for procedure calls, we don't care about the PC+4 value saved in the destination register by branch instructions,"}, {"start": "00:05:53", "is_lecture": true, "end": "00:06:03", "is_worked_example": false, "text": "so almost always would specify R31 as the Rc register, effectively discarding the PC+4 value saved by branches."}, {"start": "00:06:03", "is_lecture": true, "end": "00:06:10", "is_worked_example": false, "text": "So we define two-argument branch macros that automatically provide R31 as the destination register."}, {"start": "00:06:10", "is_lecture": true, "end": "00:06:17", "is_worked_example": false, "text": "Saves some typing, and, more importantly, it makes it easier to understand the assembly language program."}, {"start": "00:06:17", "is_lecture": true, "end": "00:06:22", "is_worked_example": false, "text": "Here are a whole set of convenience macros intended to make programs more readable."}, {"start": "00:06:22", "is_lecture": true, "end": "00:06:31", "is_worked_example": false, "text": "For example, unconditional branches can be written using the BR() macro rather than the more cumbersome BEQ(R31,...)."}, {"start": "00:06:31", "is_lecture": true, "end": "00:06:38", "is_worked_example": false, "text": "And it's more readable to use branch-false (BF) and branch-true (BT) macros when testing the results of a compare instruction."}, {"start": "00:06:38", "is_lecture": true, "end": "00:06:43", "is_worked_example": false, "text": "And note the PUSH and POP macros at the bottom of page."}, {"start": "00:06:43", "is_lecture": true, "end": "00:06:52", "is_worked_example": false, "text": "These expand into multi-instruction sequences, in this case to add and remove values from a stack data structure pointed to by the SP register."}, {"start": "00:06:52", "is_lecture": true, "end": "00:07:00", "is_worked_example": false, "text": "We call these macros \"pseudo instructions\" since they let us provide the programmer with what appears a larger instruction set,"}, {"start": "00:07:00", "is_lecture": true, "end": "00:07:07", "is_worked_example": false, "text": "although underneath the covers we've just using the same small instruction repertoire developed in Lecture 9."}, {"start": "00:07:07", "is_lecture": true, "end": "00:07:15", "is_worked_example": false, "text": "In this example we've rewritten the original code we had for the factorial computation using pseudo instructions."}, {"start": "00:07:15", "is_lecture": true, "end": "00:07:21", "is_worked_example": false, "text": "For example, CMOVE is a pseudo instruction for moving small constants into a register."}, {"start": "00:07:21", "is_lecture": true, "end": "00:07:32", "is_worked_example": false, "text": "It's easier for us to read and understand the intent of a \"constant move\" operation than an \"add a value to 0\" operation provided by the ADDC expansion of CMOVE."}, {"start": "00:07:32", "is_lecture": true, "end": "00:07:39", "is_worked_example": false, "text": "Anything we can do to remove the cognitive clutter will be very beneficial in the long run."}]}, "C04S03B05-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c4/c4s1/5?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c4s1v5", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "So far we've talked about assembling instructions."}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "What about data?"}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:13", "is_worked_example": false, "text": "How do we allocate and initialize data storage and how do we get those values into registers so that they can be used as operands?"}, {"start": "00:00:13", "is_lecture": true, "end": "00:00:19", "is_worked_example": false, "text": "Here we see a program that allocates and initializes two memory locations using the LONG macro."}, {"start": "00:00:19", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "We've used labels to remember the addresses of these locations for later reference."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:36", "is_worked_example": false, "text": "When the program is assembled the values of the label N and factN are 0 and 4 respectively, the addresses of the memory locations holding the two data values."}, {"start": "00:00:36", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "To access the first data value, the program uses a LD instruction, in this case one of convenience macros that supplies R31 as the default value of the Ra field."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:55", "is_worked_example": false, "text": "The assembler replaces the reference to the label N with its value 0 from the symbol table."}, {"start": "00:00:55", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "When the LD is executed, it computes the memory address by adding the constant (0) to the value of the Ra register (which is R31 and hence the value is 0)"}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:13", "is_worked_example": false, "text": "to get the address (0) of the memory location from which to fetch the value to be placed in R1."}, {"start": "00:01:13", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "The constants needed as values for data words and instruction fields can be written as expressions."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:27", "is_worked_example": false, "text": "These expressions are evaluated by the assembler as it assembles the program and the resulting value is used as needed."}, {"start": "00:01:27", "is_lecture": true, "end": "00:01:32", "is_worked_example": false, "text": "Note that the expressions are evaluated at the time the assembler runs."}, {"start": "00:01:32", "is_lecture": true, "end": "00:01:37", "is_worked_example": false, "text": "By the time the program runs on the Beta, the resulting value is used."}, {"start": "00:01:37", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "The assembler does NOT generate ADD and MUL instructions to compute the value during program execution."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:52", "is_worked_example": false, "text": "If a value is needed for an instruction field or initial data value, the assembler has to be able to perform the arithmetic itself."}, {"start": "00:01:52", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "If you need the program to compute a value during execution, you have to write the necessary instructions as part of your program."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:13", "is_worked_example": false, "text": "One last UASM feature: there's a special symbol \".\", called \"dot\", whose value is the address of the next main memory location to be filled by the assembler when it generates binary data."}, {"start": "00:02:13", "is_lecture": true, "end": "00:02:20", "is_worked_example": false, "text": "Initially \".\"  is 0 and it's incremented each time a new byte value is generated."}, {"start": "00:02:20", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "We can set the value of \".\" to tell the assembler where in memory we wish to place a value."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "In this example, the constant 0xDEADBEEF is placed into location 0x100 of main memory."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "And we can use \".\" in expressions to compute the values for other symbols, as shown here when defining the value for the symbol \"k\"."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "In fact, the label definition \"k:\" is exactly equivalent to the UASM statement \"k = .\""}, {"start": "00:02:50", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "We can even increment the value of \".\" to skip over locations, e.g., if we wanted to leave space for an un initialized array."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:03", "is_worked_example": false, "text": "And that's assembly language!"}, {"start": "00:03:03", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "We use assembly language as a convenient notation for generating the binary encoding for instructions and data."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:17", "is_worked_example": false, "text": "We let the assembler build the bit-level representations we need and to keep track of the addresses where these values are stored in main memory."}, {"start": "00:03:17", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "UASM itself provides support for values, symbols, labels and macros."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:29", "is_worked_example": false, "text": "Values can be written as constants or expressions involving constants."}, {"start": "00:03:29", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "We use symbols to give meaningful names to values so that our programs will be more readable and more easily modified."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "Similarly, we use labels to give meaningful names to addresses in main memory and then use the labels in referring to data locations in LD or ST instructions, or to instruction locations in branch instructions."}, {"start": "00:03:52", "is_lecture": true, "end": "00:03:58", "is_worked_example": false, "text": "Macros hide the details of how instructions are assembled from their component fields."}, {"start": "00:03:58", "is_lecture": true, "end": "00:04:04", "is_worked_example": false, "text": "And we can use \".\" to control where the assembler places values in main memory."}, {"start": "00:04:04", "is_lecture": true, "end": "00:04:09", "is_worked_example": false, "text": "The assembler is itself a program that runs on our computer."}, {"start": "00:04:09", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "That raises an interesting \"chicken and egg problem\":"}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:18", "is_worked_example": false, "text": "how did the first assembler program get assembled into binary so it could run on a computer?"}, {"start": "00:04:18", "is_lecture": true, "end": "00:04:21", "is_worked_example": false, "text": "Well, it was hand-assembled into binary."}, {"start": "00:04:21", "is_lecture": true, "end": "00:04:35", "is_worked_example": false, "text": "I suspect it processed a very simple language indeed, with the bells and whistles of symbols, labels, macros, expression evaluation, etc. added only after basic instructions could be assembled by the program."}, {"start": "00:04:35", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "And I'm sure they were very careful not loose the binary so they wouldn't have to do the hand-assembly a second time!"}]}, "C03S02B01-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s2/1?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s2v1", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:16", "is_worked_example": true, "text": "For this problem, we are going to make use of this simple datapath that consists of a four register register file, a relatively simple arithmetic logic unit that can perform ADD, SUB, MUL, and NAND operations."}, {"start": "00:00:16", "is_lecture": false, "end": "00:00:21", "is_worked_example": true, "text": "In addition, it can compare two inputs and determine whether or not they are equal."}, {"start": "00:00:21", "is_lecture": false, "end": "00:00:26", "is_worked_example": true, "text": "The result of the comparison, Z, can then be used to control what happens next."}, {"start": "00:00:26", "is_lecture": false, "end": "00:00:30", "is_worked_example": true, "text": "There are multiple control signals in this datapath."}, {"start": "00:00:30", "is_lecture": false, "end": "00:00:33", "is_worked_example": true, "text": "The first two are Asel and Bsel."}, {"start": "00:00:33", "is_lecture": false, "end": "00:00:38", "is_worked_example": true, "text": "These are used to select which register drives the corresponding multiplexer output."}, {"start": "00:00:38", "is_lecture": false, "end": "00:00:49", "is_worked_example": true, "text": "The value stored in the register selected by Asel becomes the A input to the arithmetic operations and is passed to the arithmetic units along the red wire."}, {"start": "00:00:49", "is_lecture": false, "end": "00:00:59", "is_worked_example": true, "text": "The value stored in the register selected by Bsel becomes the B input to the arithmetic operations and is passed to the arithmetic units along the blue wire."}, {"start": "00:00:59", "is_lecture": false, "end": "00:01:02", "is_worked_example": true, "text": "The next control signal is Opsel."}, {"start": "00:01:02", "is_lecture": false, "end": "00:01:11", "is_worked_example": true, "text": "It selects which of the four operation outputs should be selected by the Opsel multiplexer as the result of our operation."}, {"start": "00:01:11", "is_lecture": false, "end": "00:01:15", "is_worked_example": true, "text": "This result is fed back to the register file along the purple wire."}, {"start": "00:01:15", "is_lecture": false, "end": "00:01:27", "is_worked_example": true, "text": "The Wen is a write enable for the register file which specifies whether or not the result of our operation should be written back into the register file."}, {"start": "00:01:27", "is_lecture": false, "end": "00:01:37", "is_worked_example": true, "text": "If it is supposed to be written back to the register file, then the Wsel control signal selects to which of the registers the result should be written."}, {"start": "00:01:37", "is_lecture": false, "end": "00:01:40", "is_worked_example": true, "text": "The yellow box is the control FSM."}, {"start": "00:01:40", "is_lecture": false, "end": "00:01:47", "is_worked_example": true, "text": "It generates the control signals for the rest of the datapath based on the operations that you want to perform."}, {"start": "00:01:47", "is_lecture": false, "end": "00:01:52", "is_worked_example": true, "text": "Suppose the initial value of our 4 registers is:"}, {"start": "00:01:52", "is_lecture": false, "end": "00:01:59", "is_worked_example": true, "text": "R0 = 1, R1 = 0, R2 = -1, and R3 = N."}, {"start": "00:01:59", "is_lecture": false, "end": "00:02:07", "is_worked_example": true, "text": "We want to evaluate the result of the function 3 * N -- 2 and store the result into R3."}, {"start": "00:02:07", "is_lecture": false, "end": "00:02:15", "is_worked_example": true, "text": "Our job is to design the control FSM so that it produces the correct signals to achieve what we want."}, {"start": "00:02:15", "is_lecture": false, "end": "00:02:22", "is_worked_example": true, "text": "To help us get started, here is an incomplete listing of the code that will achieve what we want."}, {"start": "00:02:22", "is_lecture": false, "end": "00:02:27", "is_worked_example": true, "text": "The Sx labels are the names of the states corresponding to each instruction in our program."}, {"start": "00:02:27", "is_lecture": false, "end": "00:02:35", "is_worked_example": true, "text": "Our first job is to figure out the values of RX, RY, and RZ so that our code behaves as expected."}, {"start": "00:02:35", "is_lecture": false, "end": "00:02:38", "is_worked_example": true, "text": "Let's begin by looking at state S0."}, {"start": "00:02:38", "is_lecture": false, "end": "00:02:48", "is_worked_example": true, "text": "We want to end up with the value -2 in R2 by adding R2 which currently holds -1 to some register."}, {"start": "00:02:48", "is_lecture": false, "end": "00:02:55", "is_worked_example": true, "text": "In order to produce -2, we need to add -1 which means that RX = R2."}, {"start": "00:02:55", "is_lecture": false, "end": "00:03:00", "is_worked_example": true, "text": "Next, we look at state S1."}, {"start": "00:03:00", "is_lecture": false, "end": "00:03:08", "is_worked_example": true, "text": "Here we want to end up with the value 2 in R1 by adding Ry to R0 which currently holds a 1."}, {"start": "00:03:08", "is_lecture": false, "end": "00:03:14", "is_worked_example": true, "text": "In order to produce 2, we need to add 1 which means RY = R0."}, {"start": "00:03:14", "is_lecture": false, "end": "00:03:22", "is_worked_example": true, "text": "State S2 adds R0 to R1 and stores the result in R1."}, {"start": "00:03:22", "is_lecture": false, "end": "00:03:28", "is_worked_example": true, "text": "Since R0 still equals 1 and R1 = 2, then we produce R1 = 3."}, {"start": "00:03:28", "is_lecture": false, "end": "00:03:31", "is_worked_example": true, "text": "Now, let's look at state S3."}, {"start": "00:03:31", "is_lecture": false, "end": "00:03:37", "is_worked_example": true, "text": "Our goal is to multiply 3*N and store the result into R3."}, {"start": "00:03:37", "is_lecture": false, "end": "00:03:43", "is_worked_example": true, "text": "To achieve this, we multiply RZ by R3 and store the result in R3."}, {"start": "00:03:43", "is_lecture": false, "end": "00:03:50", "is_worked_example": true, "text": "Since R3 currently = N, that means that we want to multiply it by R1 which equals 3."}, {"start": "00:03:50", "is_lecture": false, "end": "00:03:53", "is_worked_example": true, "text": "So RZ = R1."}, {"start": "00:03:53", "is_lecture": false, "end": "00:04:02", "is_worked_example": true, "text": "Finally, we add R3 and R2 to produce 3*N-2 and store that result back into R3."}, {"start": "00:04:02", "is_lecture": false, "end": "00:04:08", "is_worked_example": true, "text": "S5 just executes a HALT() instruction to indicate that we are done."}, {"start": "00:04:08", "is_lecture": false, "end": "00:04:18", "is_worked_example": true, "text": "Now that we have working code, our next goal is to determine the settings for the control FSM that will make the correct operations be executed by our datapath."}, {"start": "00:04:18", "is_lecture": false, "end": "00:04:25", "is_worked_example": true, "text": "Since we have 6 states, we will need 3 state bits to encode the value of the current and next state."}, {"start": "00:04:25", "is_lecture": false, "end": "00:04:28", "is_worked_example": true, "text": "We begin with state S0."}, {"start": "00:04:28", "is_lecture": false, "end": "00:04:40", "is_worked_example": true, "text": "In order to encode that we are in state zero using 3 bits, we set our current state, S[2:0] to 000."}, {"start": "00:04:40", "is_lecture": false, "end": "00:04:47", "is_worked_example": true, "text": "In this operation we don't care about the Z signal, so Z = X which means don't care."}, {"start": "00:04:47", "is_lecture": false, "end": "00:04:54", "is_worked_example": true, "text": "The instruction that we want to execute after this first ADD, is the next ADD in state S1."}, {"start": "00:04:54", "is_lecture": false, "end": "00:04:58", "is_worked_example": true, "text": "This means that our next state is 001."}, {"start": "00:04:58", "is_lecture": false, "end": "00:05:03", "is_worked_example": true, "text": "Note that the notation S' is often used to represent the next state."}, {"start": "00:05:03", "is_lecture": false, "end": "00:05:09", "is_worked_example": true, "text": "Our register select signals each need to select one of 4 registers."}, {"start": "00:05:09", "is_lecture": false, "end": "00:05:14", "is_worked_example": true, "text": "This means that these signals must each be 2 bits wide."}, {"start": "00:05:14", "is_lecture": false, "end": "00:05:19", "is_worked_example": true, "text": "Our Asel control signal identifies the register that should be used as input A."}, {"start": "00:05:19", "is_lecture": false, "end": "00:05:24", "is_worked_example": true, "text": "This register is R2, so Asel is 10."}, {"start": "00:05:24", "is_lecture": false, "end": "00:05:28", "is_worked_example": true, "text": "Bsel identifies the second source operand."}, {"start": "00:05:28", "is_lecture": false, "end": "00:05:35", "is_worked_example": true, "text": "In this case it is also R2, so Bsel = 10 as well."}, {"start": "00:05:35", "is_lecture": false, "end": "00:05:40", "is_worked_example": true, "text": "The Opsel signal identifies which operation we want to perform."}, {"start": "00:05:40", "is_lecture": false, "end": "00:05:50", "is_worked_example": true, "text": "Since we have 4 distinct operations, we would need two bits to distinguish amongst them and we would make each operation be associated with one of the 4 encodings."}, {"start": "00:05:50", "is_lecture": false, "end": "00:05:57", "is_worked_example": true, "text": "For simplicity, let's just label Opsel as ADD to indicate that we selected the encoding for the ADD."}, {"start": "00:05:57", "is_lecture": false, "end": "00:06:06", "is_worked_example": true, "text": "The register we want to write our result to, also known as the destination register, is R2 for this operation."}, {"start": "00:06:06", "is_lecture": false, "end": "00:06:13", "is_worked_example": true, "text": "This means that Wsel = 10 and Wen = 1."}, {"start": "00:06:13", "is_lecture": false, "end": "00:06:17", "is_worked_example": true, "text": "Wen is a signal that enables writing to the register file."}, {"start": "00:06:17", "is_lecture": false, "end": "00:06:25", "is_worked_example": true, "text": "If it is set to 0, then regardless of the value of Wsel, no value will be written into the register file."}, {"start": "00:06:25", "is_lecture": false, "end": "00:06:29", "is_worked_example": true, "text": "Now let's quickly run through the rest of our instructions."}, {"start": "00:06:29", "is_lecture": false, "end": "00:06:34", "is_worked_example": true, "text": "Our current state is state S1, or 001."}, {"start": "00:06:34", "is_lecture": false, "end": "00:06:36", "is_worked_example": true, "text": "Once again Z is a don't care."}, {"start": "00:06:36", "is_lecture": false, "end": "00:06:43", "is_worked_example": true, "text": "Since the instruction that will be executed next is the one in S2, our next state is 010."}, {"start": "00:06:43", "is_lecture": false, "end": "00:06:49", "is_worked_example": true, "text": "Our Asel = 00 and Bsel = 00."}, {"start": "00:06:49", "is_lecture": false, "end": "00:06:56", "is_worked_example": true, "text": "Opsel = ADD and Wsel = 01 and Wen = 1."}, {"start": "00:06:56", "is_lecture": false, "end": "00:07:05", "is_worked_example": true, "text": "State 2 follows the same model, so current state is 010 and next state is 011."}, {"start": "00:07:05", "is_lecture": false, "end": "00:07:15", "is_worked_example": true, "text": "Here Asel = 00, Bsel = 01 and Wsel = 01 and Wen = 1."}, {"start": "00:07:15", "is_lecture": false, "end": "00:07:18", "is_worked_example": true, "text": "Once again our Opsel is an ADD."}, {"start": "00:07:18", "is_lecture": false, "end": "00:07:26", "is_worked_example": true, "text": "We move on to state 3 whose current state is 011 and next state is 100."}, {"start": "00:07:26", "is_lecture": false, "end": "00:07:36", "is_worked_example": true, "text": "Asel = 01, Bsel = 11, Wsel = 11, and Wen = 1."}, {"start": "00:07:36", "is_lecture": false, "end": "00:07:44", "is_worked_example": true, "text": "Here our Opsel is MUL to indicate that the operation to be executed here is a multiply."}, {"start": "00:07:44", "is_lecture": false, "end": "00:07:51", "is_worked_example": true, "text": "For state four, we have current state set to 100 and next state to 101."}, {"start": "00:07:51", "is_lecture": false, "end": "00:08:00", "is_worked_example": true, "text": "Asel = 11, Bsel = 10, Wsel = 11, and Wen = 1."}, {"start": "00:08:00", "is_lecture": false, "end": "00:08:03", "is_worked_example": true, "text": "Our Opsel is once again ADD."}, {"start": "00:08:03", "is_lecture": false, "end": "00:08:06", "is_worked_example": true, "text": "Finally, we reach state 5."}, {"start": "00:08:06", "is_lecture": false, "end": "00:08:11", "is_worked_example": true, "text": "This state looks a little different from the previous states so lets examine it a little more closely."}, {"start": "00:08:11", "is_lecture": false, "end": "00:08:22", "is_worked_example": true, "text": "The first thing to note, is that when we get to state 5 we want to stay there because we are done with our execution, so both the current state and the next state are 101."}, {"start": "00:08:22", "is_lecture": false, "end": "00:08:32", "is_worked_example": true, "text": "Most of the other control bits can be set to don't care because at this point we mostly don't care about what the rest of the datapath is doing."}, {"start": "00:08:32", "is_lecture": false, "end": "00:08:36", "is_worked_example": true, "text": "The only other signal that we do need to worry about is Wen."}, {"start": "00:08:36", "is_lecture": false, "end": "00:08:47", "is_worked_example": true, "text": "Since we are allowing the rest of our datapath to run in whatever way, we need to ensure that nothing produced on the datapath at this stage gets written back to any of the registers."}, {"start": "00:08:47", "is_lecture": false, "end": "00:08:52", "is_worked_example": true, "text": "In order to guarantee that, we set Wen = 0."}, {"start": "00:08:52", "is_lecture": false, "end": "00:09:02", "is_worked_example": true, "text": "Here is the complete control ROM that will execute the function 3*N-2 and store its result into R3."}]}, "C03S01B02-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s1/2?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s1v2", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:05", "is_worked_example": false, "text": "Okay, we've figured out a way to design hardware to perform a particular computation:"}, {"start": "00:00:05", "is_lecture": true, "end": "00:00:12", "is_worked_example": false, "text": "Draw the state transition diagram for an FSM that describes the sequence of operations needed to complete the computation."}, {"start": "00:00:12", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "Then construct the appropriate datapath, using registers to store values and combinational logic to implement the needed operations."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "Finally build an FSM to generate the control signals required by the datapath."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:30", "is_worked_example": false, "text": "Is the datapath plus control logic itself an FSM?"}, {"start": "00:00:30", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "Well, it has registers and some combinational logic, so, yes, it is an FSM."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:38", "is_worked_example": false, "text": "Can we draw the truth table?"}, {"start": "00:00:38", "is_lecture": true, "end": "00:00:40", "is_worked_example": false, "text": "In theory, yes."}, {"start": "00:00:40", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "In practice, there are 66 bits of registers and hence 66 bits of state, so our truth table would need 2^66 rows!"}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "Hmm, not very likely that we'd be able to draw the truth table!"}, {"start": "00:00:53", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "The difficulty comes from thinking of the registers in the datapath as part of the state of our super-FSM."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:03", "is_worked_example": false, "text": "That's why we think about the datapath as being separate from the control FSM."}, {"start": "00:01:03", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "So how do we generalize this approach so we can use one computer circuit to solve many different problems."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:17", "is_worked_example": false, "text": "Well, most problems would probably require more storage for operands and results."}, {"start": "00:01:17", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "And a larger list of allowable operations would be handy."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:26", "is_worked_example": false, "text": "This is actually a bit tricky: what's the minimum set of operations we can get away with?"}, {"start": "00:01:26", "is_lecture": true, "end": "00:01:32", "is_worked_example": false, "text": "As we'll see later, surprisingly simple hardware is sufficient to perform any realizable computation."}, {"start": "00:01:32", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "At the other extreme, many complex operations (e.g., fast fourier transform) are best implemented as sequences of simpler operations (e.g., add and multiply) rather than as a single massive combinational circuit."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:51", "is_worked_example": false, "text": "These sorts of design tradeoffs are what makes computer architecture fun!"}, {"start": "00:01:51", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "We'd then combine our larger storage with logic for our chosen set of operations into a general purpose datapath that could be reused to solve many different problems."}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:03", "is_worked_example": false, "text": "Let's see how that would work..."}, {"start": "00:02:03", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "Here's a datapath with 4 data registers to hold results."}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "The ASEL and BSEL multiplexers allow any of the data registers to be selected as either operand for our repertoire of arithmetic and boolean operations."}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "The result is selected by the OPSEL MUX and can be written back into any of the data registers by setting the WEN control signal to 1 and using the 2-bit WSEL signal to select which data register will be loaded at the next rising clock edge."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "Note that the data registers have a load-enable control input."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:46", "is_worked_example": false, "text": "When this signal is 1, the register will load a new value from its D input, otherwise it ignores the D input and simply reloads its previous value."}, {"start": "00:02:46", "is_lecture": true, "end": "00:02:53", "is_worked_example": false, "text": "And, of course, we'll add a control FSM to generate the appropriate sequence of control signals for the datapath."}, {"start": "00:02:53", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "The Z input from the datapath allows the system to perform data-dependent operations, where the sequence of operations can be influenced by the actual values in the data registers."}, {"start": "00:03:04", "is_lecture": true, "end": "00:03:15", "is_worked_example": false, "text": "Here's the state transition diagram for the control FSM we'd use if we wanted to use this datapath to compute factorial assuming the initial contents of the data registers are as shown."}, {"start": "00:03:15", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "We need a few more states than in our initial implementation since this datapath can only perform one operation at each step."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:31", "is_worked_example": false, "text": "So we need three steps for each iteration: one for the multiply, one for the decrement, and one for the test to see if we're done."}, {"start": "00:03:31", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "As seen here, it's often the case that general-purpose computer hardware will need more cycles and perhaps involve more hardware than an optimized single-purpose circuit."}, {"start": "00:03:41", "is_lecture": true, "end": "00:03:45", "is_worked_example": false, "text": "You can solve many different problems with this system:"}, {"start": "00:03:45", "is_lecture": true, "end": "00:03:54", "is_worked_example": false, "text": "exponentiation, division, square root, and so on, so long as you don't need more than four data registers to hold input data, intermediate results, or the final answer."}, {"start": "00:03:54", "is_lecture": true, "end": "00:04:03", "is_worked_example": false, "text": "By designing a control FSM, we are in effect \"programming\" our digital system, specifying the sequence of operations it will perform."}, {"start": "00:04:03", "is_lecture": true, "end": "00:04:07", "is_worked_example": false, "text": "This is exactly how the early digital computers worked!"}, {"start": "00:04:07", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "Here's a picture of the ENIAC computer built in 1943 at the University of Pennsylvania."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:23", "is_worked_example": false, "text": "The Wikipedia article on the ENIAC tells us that \"ENIAC could be programmed to perform complex sequences of operations, including loops, branches, and subroutines."}, {"start": "00:04:23", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "The task of taking a problem and mapping it onto the machine was complex, and usually took weeks."}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:38", "is_worked_example": false, "text": "After the program was figured out on paper, the process of getting the program into ENIAC by manipulating its switches and cables could take days."}, {"start": "00:04:38", "is_lecture": true, "end": "00:04:45", "is_worked_example": false, "text": "This was followed by a period of verification and debugging, aided by the ability to execute the program step by step.\""}, {"start": "00:04:45", "is_lecture": true, "end": "00:04:50", "is_worked_example": false, "text": "It's clear that we need a less cumbersome way to program our computer!"}]}, "C03S01B10-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s1/1?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:09", "is_worked_example": false, "text": "Now let's turn our attention to the second class of instructions: load (LD) and store (ST), which allow the CPU to access values in memory."}, {"start": "00:00:09", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "Note that since the Beta is a load-store architecture these instructions are the *only* mechanism for accessing memory values."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "The LD and ST instructions use the same instruction template as the ALU-with-constant instructions."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "To access memory, we'll need a memory address, which is computed by adding the value of the \"ra\" register to the sign-extended 16-bit constant from the low-order 16 bits of the instruction."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "This computation is exactly the one performed by the ADDC instruction -- so we'll reuse that hardware -- and the sum is sent to main memory as the byte address of the location to be accessed."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "For the LD instruction, the data returned by main memory is written to the \"rc\" register."}, {"start": "00:00:53", "is_lecture": true, "end": "00:01:03", "is_worked_example": false, "text": "The store instruction (ST) performs the same address calculation as LD, then reads the data value from the \"rc\" register and sends both to main memory."}, {"start": "00:01:03", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "The ST instruction is special in several ways:"}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:15", "is_worked_example": false, "text": "it's the only instruction that needs to read the value of the \"rc\" register, so we'll need to adjust the datapath hardware slightly to accommodate that need."}, {"start": "00:01:15", "is_lecture": true, "end": "00:01:26", "is_worked_example": false, "text": "And since \"rc\" is serving as a source operand, it appears as the first operand in the symbolic form of the instruction, followed by \"const\" and \"ra\" which are specifying the destination address."}, {"start": "00:01:26", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "ST is the only instruction that does *not* write a result into the register file at end of the instruction."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:45", "is_worked_example": false, "text": "Here's the example we saw earlier, where we needed to load the value of the variable x from memory, multiply it by 37 and write the result back to the memory location that holds the value of the variable y."}, {"start": "00:01:45", "is_lecture": true, "end": "00:01:52", "is_worked_example": false, "text": "Now that we have actual Beta instructions, we've expressed the computation as a sequence of three instructions."}, {"start": "00:01:52", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "To access the value of variable x, the LD instruction adds the contents of R31 to the constant 0x1008, which sums to 0x1008, the address we need to access."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "The ST instruction specifies a similar address calculation to write into the location for the variable y."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "The address calculation performed by LD and ST works well when the locations we need to access have addresses that fit into the 16-bit constant field."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "What happens when we need to access locations at addresses higher than 0x7FFF?"}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:37", "is_worked_example": false, "text": "Then we need to treat those addresses as we would any large constant, and store those large addresses in main memory so they can be loaded into a register to be used by LD and ST."}, {"start": "00:02:37", "is_lecture": true, "end": "00:02:47", "is_worked_example": false, "text": "Okay, but what if the number of large constants we need to store is greater than will fit in low memory, i.e., the addresses we can access directly?"}, {"start": "00:02:47", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "To solve this problem, the Beta includes a \"load relative\" (LDR) instruction, which we'll see in the lecture on the Beta implementation."}]}, "C06S02B01-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c6/c6s2/1?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c6s2v1", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:08", "is_worked_example": true, "text": "In this problem, we will examine how compilers translate high level language descriptions into assembly language."}, {"start": "00:00:08", "is_lecture": false, "end": "00:00:17", "is_worked_example": true, "text": "We will be given several code fragments and asked to help the compiler in figuring out the dependencies of the program so that it produces valid code."}, {"start": "00:00:17", "is_lecture": false, "end": "00:00:24", "is_worked_example": true, "text": "Let's begin with the code fragment: a = b + 3*c."}, {"start": "00:00:24", "is_lecture": false, "end": "00:00:29", "is_worked_example": true, "text": "We can assume that our variables: a, b, and c are stored in memory."}, {"start": "00:00:29", "is_lecture": false, "end": "00:00:34", "is_worked_example": true, "text": "We can also assume that registers may be used to store intermediate results."}, {"start": "00:00:34", "is_lecture": false, "end": "00:00:42", "is_worked_example": true, "text": "Given the following partially completed assembly code, let's determine the missing values that the compiler would have had to determine."}, {"start": "00:00:42", "is_lecture": false, "end": "00:00:46", "is_worked_example": true, "text": "We begin with XXX which is the first instruction."}, {"start": "00:00:46", "is_lecture": false, "end": "00:00:51", "is_worked_example": true, "text": "The first instruction is trying to put the value of c into register R1."}, {"start": "00:00:51", "is_lecture": false, "end": "00:01:00", "is_worked_example": true, "text": "Since c comes from memory, that means that instruction XXX must be a LD operation where c is the address of the variable to be loaded."}, {"start": "00:01:00", "is_lecture": false, "end": "00:01:13", "is_worked_example": true, "text": "Note that LD(c, R1) is actually a macro instruction that is equal to LD(R31, c, R1)."}, {"start": "00:01:13", "is_lecture": false, "end": "00:01:25", "is_worked_example": true, "text": "The load operation would add the constant c to the value of register R31, which is always 0, thus ending up with the address c as the source address of the load operation."}, {"start": "00:01:25", "is_lecture": false, "end": "00:01:30", "is_worked_example": true, "text": "R1 is a temporary register that will hold the value of variable c."}, {"start": "00:01:30", "is_lecture": false, "end": "00:01:34", "is_worked_example": true, "text": "Next, we need to multiply c by 3."}, {"start": "00:01:34", "is_lecture": false, "end": "00:01:46", "is_worked_example": true, "text": "Multiply operations are generally very expensive, so it is the compilers job to figure out that this operation could potentially be achieved by 2 simpler and faster operations."}, {"start": "00:01:46", "is_lecture": false, "end": "00:01:53", "is_worked_example": true, "text": "The comment tells us that it first tries to compute 2 * c and store that result into R0."}, {"start": "00:01:53", "is_lecture": false, "end": "00:02:06", "is_worked_example": true, "text": "Since R1 = c, and the constant in this operation is a 1, we need to realize that the inexpensive operation that the compiler would use for this is a logical shift to the left by one position."}, {"start": "00:02:06", "is_lecture": false, "end": "00:02:12", "is_worked_example": true, "text": "In binary, this produces the same result as multiplying a number by 2."}, {"start": "00:02:12", "is_lecture": false, "end": "00:02:16", "is_worked_example": true, "text": "So YYY = SHLC."}, {"start": "00:02:16", "is_lecture": false, "end": "00:02:29", "is_worked_example": true, "text": "Note that we use the constant version of the SHL operation since the amount to shift is given by a constant in our instruction rather than being read from another register."}, {"start": "00:02:29", "is_lecture": false, "end": "00:02:41", "is_worked_example": true, "text": "The next instruction is provided for us and it adds R0 which equals 2*c to R1 which equals c in order to produce 3*c."}, {"start": "00:02:41", "is_lecture": false, "end": "00:02:45", "is_worked_example": true, "text": "This intermediate result is then stored back into R0."}, {"start": "00:02:45", "is_lecture": false, "end": "00:02:50", "is_worked_example": true, "text": "Next we want to once again get the value of a variable from memory."}, {"start": "00:02:50", "is_lecture": false, "end": "00:02:58", "is_worked_example": true, "text": "As we saw before, XXX = LD in order to load the contents of address b into register R1."}, {"start": "00:02:58", "is_lecture": false, "end": "00:03:10", "is_worked_example": true, "text": "We are almost done, we now just need to add R1 = b to R0 = 3*c and then store the result back into memory variable a."}, {"start": "00:03:10", "is_lecture": false, "end": "00:03:21", "is_worked_example": true, "text": "Since the store instruction is using R0 as its source, that means that ZZZ must also be R0 so that the correct value ends up in variable a."}, {"start": "00:03:21", "is_lecture": false, "end": "00:03:28", "is_worked_example": true, "text": "Next, we will take a look at how a conditional statement would be compiled into assembly language."}, {"start": "00:03:28", "is_lecture": false, "end": "00:03:35", "is_worked_example": true, "text": "The statement says that if a is greater than b then c should be assigned the value 17."}, {"start": "00:03:35", "is_lecture": false, "end": "00:03:42", "is_worked_example": true, "text": "Once again we are given the semi-complete translation of the high level language code into beta assembly."}, {"start": "00:03:42", "is_lecture": false, "end": "00:03:51", "is_worked_example": true, "text": "For this example, we first load the values of our variables a and b into temporary registers R0 and R1."}, {"start": "00:03:51", "is_lecture": false, "end": "00:03:58", "is_worked_example": true, "text": "Now we want to check if a is greater than b and if so set c = 17."}, {"start": "00:03:58", "is_lecture": false, "end": "00:04:03", "is_worked_example": true, "text": "We know that XXX must be some kind of beta comparison operation."}, {"start": "00:04:03", "is_lecture": false, "end": "00:04:15", "is_worked_example": true, "text": "However, the beta does not provide a compare greater than operation, so instead we need to make use of the compare less than (CMPLT) or compare less than or equal (CMPLE) operations."}, {"start": "00:04:15", "is_lecture": false, "end": "00:04:27", "is_worked_example": true, "text": "Since we see that the store into label c is skipped when the code branches to label _L2, we want to make sure that the branch is not taken when a is greater than b."}, {"start": "00:04:27", "is_lecture": false, "end": "00:04:32", "is_worked_example": true, "text": "This is equivalent to the branch being taken when a is less than or equal to b."}, {"start": "00:04:32", "is_lecture": false, "end": "00:04:48", "is_worked_example": true, "text": "So if we make XXX = CMPLE of R0, which equals a, and R1, which equals b, then the result stored into R0 will be 1 if a <= b."}, {"start": "00:04:48", "is_lecture": false, "end": "00:05:00", "is_worked_example": true, "text": "We then set YYY to R0 to ensure that we take the branch when a <= b and we make the assignment to c when a > b."}, {"start": "00:05:00", "is_lecture": false, "end": "00:05:15", "is_worked_example": true, "text": "Finally, if we set ZZZ = 17, then when the branch is not taken, we will move 17 into R0 and then store that value into the location pointed to by address c."}, {"start": "00:05:15", "is_lecture": false, "end": "00:05:22", "is_worked_example": true, "text": "So the complete translation of this conditional statement to beta assembly is shown here."}, {"start": "00:05:22", "is_lecture": false, "end": "00:05:32", "is_worked_example": true, "text": "For this next code segment, we are going to take a look at how a compiler would convert array accesses into beta code."}, {"start": "00:05:32", "is_lecture": false, "end": "00:05:42", "is_worked_example": true, "text": "Once again we are given partially completed assembly code to help us understand how the compiler translates this high level code into beta assembly."}, {"start": "00:05:42", "is_lecture": false, "end": "00:05:48", "is_worked_example": true, "text": "We begin with a load of the value stored at location i into register R0."}, {"start": "00:05:48", "is_lecture": false, "end": "00:05:51", "is_worked_example": true, "text": "I is the index into our array."}, {"start": "00:05:51", "is_lecture": false, "end": "00:06:00", "is_worked_example": true, "text": "However, since the beta is byte addressed, but it deals with 32 bit values, that means that each array element requires 4 bytes of storage."}, {"start": "00:06:00", "is_lecture": false, "end": "00:06:06", "is_worked_example": true, "text": "So in order to point to the correct location in memory, we need to multiply i by 4."}, {"start": "00:06:06", "is_lecture": false, "end": "00:06:19", "is_worked_example": true, "text": "As we saw earlier, shifting to the left by 1 bit is equivalent to multiplying by 2, so here we shift to the left by 2 bits in order to multiply by 4."}, {"start": "00:06:19", "is_lecture": false, "end": "00:06:22", "is_worked_example": true, "text": "So XXX = 2."}, {"start": "00:06:22", "is_lecture": false, "end": "00:06:35", "is_worked_example": true, "text": "Now that R0 = 4 * i, in order to load a[i], we would load the location a + 4*i."}, {"start": "00:06:35", "is_lecture": false, "end": "00:06:47", "is_worked_example": true, "text": "In order to load a[i-1], we need to load the location that is 4 bytes before that, so location a + 4*i -- 4."}, {"start": "00:06:47", "is_lecture": false, "end": "00:06:58", "is_worked_example": true, "text": "This means that in this load operation which actually wants to load a[i-1], we need to set YYY = a-4."}, {"start": "00:06:58", "is_lecture": false, "end": "00:07:06", "is_worked_example": true, "text": "So this load operation places array element a[i-1] into R1."}, {"start": "00:07:06", "is_lecture": false, "end": "00:07:18", "is_worked_example": true, "text": "Now we want to store the contents of R1 into array element a[i] which is located at address a + 4*i."}, {"start": "00:07:18", "is_lecture": false, "end": "00:07:26", "is_worked_example": true, "text": "Since R0 already equals 4*i, then adding a to R0 will give us the desired destination address of our store."}, {"start": "00:07:26", "is_lecture": false, "end": "00:07:35", "is_worked_example": true, "text": "This means that we just need to set ZZZ to R1 since that is the value that we want to store into a[i]."}, {"start": "00:07:35", "is_lecture": false, "end": "00:07:40", "is_worked_example": true, "text": "Let's take a look at one last example."}, {"start": "00:07:40", "is_lecture": false, "end": "00:07:52", "is_worked_example": true, "text": "Here we have a variable sum that is initialized to 0, followed by a loop that increments the value of sum by i for every value of i between 0 and 9."}, {"start": "00:07:52", "is_lecture": false, "end": "00:07:58", "is_worked_example": true, "text": "Our partial mostly completed compiled code is shown here."}, {"start": "00:07:58", "is_lecture": false, "end": "00:08:04", "is_worked_example": true, "text": "The first thing that the compiler does, is it initializes the two variables sum and i to 0."}, {"start": "00:08:04", "is_lecture": false, "end": "00:08:14", "is_worked_example": true, "text": "This is done by storing the value of register R31, which is always 0 in the beta, into the locations pointed to by sum and by i."}, {"start": "00:08:14", "is_lecture": false, "end": "00:08:19", "is_worked_example": true, "text": "_L7 is a label that indicates the beginning of our loop."}, {"start": "00:08:19", "is_lecture": false, "end": "00:08:26", "is_worked_example": true, "text": "The first thing that needs to happen in the loop is to load the current values of sum and i from memory."}, {"start": "00:08:26", "is_lecture": false, "end": "00:08:29", "is_worked_example": true, "text": "Next, sum should be incremented by i."}, {"start": "00:08:29", "is_lecture": false, "end": "00:08:38", "is_worked_example": true, "text": "Since R0 is stored back into sum, we want XXX = R0 to be the destination register of the ADD."}, {"start": "00:08:38", "is_lecture": false, "end": "00:08:41", "is_worked_example": true, "text": "Now the loop index needs to be incremented."}, {"start": "00:08:41", "is_lecture": false, "end": "00:08:50", "is_worked_example": true, "text": "Since R1 = i, that means that we want to increment R1 by 1,so YYY = R1."}, {"start": "00:08:50", "is_lecture": false, "end": "00:08:56", "is_worked_example": true, "text": "Finally, we need to determine whether the loop needs to be repeated or we are done."}, {"start": "00:08:56", "is_lecture": false, "end": "00:09:00", "is_worked_example": true, "text": "This is done by checking whether i is less than 10."}, {"start": "00:09:00", "is_lecture": false, "end": "00:09:04", "is_worked_example": true, "text": "The beta provides the CMPLTC operation to do just that."}, {"start": "00:09:04", "is_lecture": false, "end": "00:09:13", "is_worked_example": true, "text": "Since R1 holds the latest value of i, comparing R1 to the constant 10 will produce the result we want in R0."}, {"start": "00:09:13", "is_lecture": false, "end": "00:09:17", "is_worked_example": true, "text": "So ZZZ = 10."}, {"start": "00:09:17", "is_lecture": false, "end": "00:09:24", "is_worked_example": true, "text": "If the comparison was true, then we need to repeat the loop so we branch back to _L7."}, {"start": "00:09:24", "is_lecture": false, "end": "00:09:29", "is_worked_example": true, "text": "If not, we proceed to the instruction after the branch."}]}, "C03S01B06-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s1/6?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s1v6", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:07", "is_worked_example": false, "text": "Having talked about the storage resources provided by the Beta ISA, let's design the Beta instructions themselves."}, {"start": "00:00:07", "is_lecture": true, "end": "00:00:15", "is_worked_example": false, "text": "This might be a good time to print a copy of the handout called the \"Summary of Beta Instruction Formats\" so you'll have it for handy reference."}, {"start": "00:00:15", "is_lecture": true, "end": "00:00:32", "is_worked_example": false, "text": "The Beta has three types of instructions: compute instructions that perform arithmetic and logic operations on register values, load and store instructions that access values in main memory, and branch instructions that change the value of the program counter."}, {"start": "00:00:32", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "We'll discuss each class of instructions in turn."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "In the Beta ISA, all the instruction encodings are the same size: each instruction is encoded in 32 bits and hence occupies exactly one 32-bit word in main memory."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "This instruction encoding leads to simpler control-unit logic for decoding instructions."}, {"start": "00:00:53", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "And computing the next value of the program counter is very simple:"}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "for most instructions, the next instruction can be found in the following memory location."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:08", "is_worked_example": false, "text": "We just need to add 4 to the current value of program counter to advance to the next instruction."}, {"start": "00:01:08", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "As we saw in Part 1 of the course, fixed-length encodings are often inefficient in the sense that the same information content (in this case, the encoded program) can be encoded using fewer bits."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:28", "is_worked_example": false, "text": "To do better we would need a variable-length encoding for instructions, where frequently-occurring instructions would use a shorter encoding."}, {"start": "00:01:28", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "But hardware to decode variable-length instructions is complex since there may be several instructions packed into one memory word, while other instructions might require loading several memory words."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "The details can be worked out, but there's a performance and energy cost associated with the more efficient encoding."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "Nowadays, advances in memory technology have made memory size less of an issue and the focus is on the higher-performance needed by today's applications."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:05", "is_worked_example": false, "text": "Our choice of a fixed-length encoding leads to larger code size, but keeps the hardware execution engine small and fast."}, {"start": "00:02:05", "is_lecture": true, "end": "00:02:11", "is_worked_example": false, "text": "The computation performed by the Beta datapath happens in the arithmetic-and-logic unit (ALU)."}, {"start": "00:02:11", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "We'll be using the ALU designed in Part 1 of the course."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "The Beta ALU instructions have 4 instruction fields."}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "There's a 6-bit field specifying the ALU operation to be performed -- this field is called the opcode."}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "The two source operands come from registers whose numbers are specified by the 5-bit \"ra\" and \"rb\" fields."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:38", "is_worked_example": false, "text": "So we can specify any register from R0 to R31 as a source operand."}, {"start": "00:02:38", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "The destination register is specified by the 5-bit \"rc\" field."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:50", "is_worked_example": false, "text": "This instruction format uses 21 bits of the 32-bit word, the remaining bits are unused and should be set to 0."}, {"start": "00:02:50", "is_lecture": true, "end": "00:02:54", "is_worked_example": false, "text": "The diagram shows how the fields are positioned in the 32-bit word."}, {"start": "00:02:54", "is_lecture": true, "end": "00:03:06", "is_worked_example": false, "text": "The choice of position for each field is somewhat arbitrary, but to keep the hardware simple, when we can we'll want to use the same field positions for similar fields in the other instruction encodings."}, {"start": "00:03:06", "is_lecture": true, "end": "00:03:12", "is_worked_example": false, "text": "For example, the opcode will always be found in bits [31:26] of the instruction."}, {"start": "00:03:12", "is_lecture": true, "end": "00:03:16", "is_worked_example": false, "text": "Here's the binary encoding of an ADD instruction."}, {"start": "00:03:16", "is_lecture": true, "end": "00:03:28", "is_worked_example": false, "text": "The opcode for ADD is the 6-bit binary value 0b100000 -- you can find the binary for each opcode in the Opcode Table in the handout mentioned before."}, {"start": "00:03:28", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "The \"rc\" field specifies that the result of the ADD will be written into R3."}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "And the \"ra\" and \"rb\" fields specify that the first and second source operands are R1 and R2 respectively."}, {"start": "00:03:41", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "So this instruction adds the 32-bit values found in R1 and R2, writing the 32-bit sum into R3."}, {"start": "00:03:49", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "Note that it's permissible to refer to a particular register several times in the same instruction."}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:03", "is_worked_example": false, "text": "So, for example, we could specify R1 as the register for both source operands AND also as the destination register."}, {"start": "00:04:03", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "If we did, we'd be adding R1 to R1 and writing the result back into R1, which would effectively multiply the value in R1 by 2."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:24", "is_worked_example": false, "text": "Since it's tedious and error-prone to transcribe 32-bit binary values, we'll often use hexadecimal notation for the binary representation of an instruction."}, {"start": "00:04:24", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "In this example, the hexadecimal notation for the encoded instruction is 0x80611000."}, {"start": "00:04:33", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "However, it's *much* easier if we describe the instructions using a functional notation, e.g., \"ADD(r1,r2,r3)\"."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:47", "is_worked_example": false, "text": "Here we use a symbolic name for each operation, called a mnemonic."}, {"start": "00:04:47", "is_lecture": true, "end": "00:04:48", "is_worked_example": false, "text": "For this instruction the mnemonic is \"ADD\", followed by a parenthesized list of operands, in this case the two source operands (r1 and r2), then the destination (r3)."}, {"start": "00:04:48", "is_lecture": true, "end": "00:05:11", "is_worked_example": false, "text": "So we'll understand that ADD(ra,rb,rc) is shorthand for asking the Beta to compute the sum of the values in registers ra and rb, writing the result as the new value of register rc."}, {"start": "00:05:11", "is_lecture": true, "end": "00:05:16", "is_worked_example": false, "text": "Here's the list of the mnemonics for all the operations supported by the Beta."}, {"start": "00:05:16", "is_lecture": true, "end": "00:05:22", "is_worked_example": false, "text": "There is a detailed description of what each instruction does in the Beta Documentation handout."}, {"start": "00:05:22", "is_lecture": true, "end": "00:05:28", "is_worked_example": false, "text": "Note that all these instructions use same 4-field template, differing only in the value of the opcode field."}, {"start": "00:05:28", "is_lecture": true, "end": "00:05:36", "is_worked_example": false, "text": "This first step was pretty straightforward -- we simply provided instruction encodings for the basic operations provided by the ALU."}, {"start": "00:05:36", "is_lecture": true, "end": "00:05:43", "is_worked_example": false, "text": "Now that we have our first group of instructions, we can create a more concrete implementation sketch."}, {"start": "00:05:43", "is_lecture": true, "end": "00:05:45", "is_worked_example": false, "text": "Here we see our proposed datapath."}, {"start": "00:05:45", "is_lecture": true, "end": "00:05:53", "is_worked_example": false, "text": "The 5-bit \"ra\" and \"rb\" fields from the instruction are used to select which of the 32 registers will be used for the two operands."}, {"start": "00:05:53", "is_lecture": true, "end": "00:06:06", "is_worked_example": false, "text": "Note that register 31 isn't actually a read/write register, it's just the 32-bit constant 0, so that selecting R31 as an operand results in using the value 0."}, {"start": "00:06:06", "is_lecture": true, "end": "00:06:12", "is_worked_example": false, "text": "The 5-bit \"rc\" field from the instruction selects which register will be written with the result from the ALU."}, {"start": "00:06:12", "is_lecture": true, "end": "00:06:25", "is_worked_example": false, "text": "Not shown is the hardware needed to translate the instruction opcode to the appropriate ALU function code -- perhaps a 64-location ROM could be used to perform the translation by table lookup."}, {"start": "00:06:25", "is_lecture": true, "end": "00:06:30", "is_worked_example": false, "text": "The program counter logic supports simple sequential execution of instructions."}, {"start": "00:06:30", "is_lecture": true, "end": "00:06:36", "is_worked_example": false, "text": "It's a 32-bit register whose value is updated at the end of each instruction by adding 4 to its current value."}, {"start": "00:06:36", "is_lecture": true, "end": "00:06:42", "is_worked_example": false, "text": "This means the next instruction will come from the memory location following the one that holds the current instruction."}, {"start": "00:06:42", "is_lecture": true, "end": "00:06:47", "is_worked_example": false, "text": "In this diagram we see one of the benefits of a RISC architecture:"}, {"start": "00:06:47", "is_lecture": true, "end": "00:06:52", "is_worked_example": false, "text": "there's not much logic needed to decode the instruction to produce the signals needed to control the datapath."}, {"start": "00:06:52", "is_lecture": true, "end": "00:06:57", "is_worked_example": false, "text": "In fact, many of the instruction fields are used as-is!"}]}, "C03S01B08-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s1/8?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s1v8", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:10", "is_worked_example": false, "text": "ISA designers receive many requests for what are affectionately known as \"features\" -- additional instructions that, in theory, will make the ISA better in some way."}, {"start": "00:00:10", "is_lecture": true, "end": "00:00:19", "is_worked_example": false, "text": "Dealing with such requests is the moment to apply our quantitive approach in order to be able to judge the tradeoffs between cost and benefits."}, {"start": "00:00:19", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "Our first \"feature request\" is to allow small constants as the second operand in ALU instructions."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:36", "is_worked_example": false, "text": "So if we replaced the 5-bit \"rb\" field, we would have room in the instruction to include a 16-bit constant as bits [15:0] of the instruction."}, {"start": "00:00:36", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "The argument in favor of this request is that small constants appear frequently in many programs and it would make programs shorter if we didn't have use load operations to read constant values from main memory."}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "The argument against the request is that we would need additional control and datapath logic to implement the feature, increasing the hardware cost and probably decreasing the performance."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:08", "is_worked_example": false, "text": "So our strategy is to modify our benchmark programs to use the ISA augmented with this feature and measure the impact on a simulated execution."}, {"start": "00:01:08", "is_lecture": true, "end": "00:01:19", "is_worked_example": false, "text": "Looking at the results, we find that there is compelling evidence that small constants are indeed very common as the second operands to many operations."}, {"start": "00:01:19", "is_lecture": true, "end": "00:01:22", "is_worked_example": false, "text": "Note that we're not so much interested in simply looking at the code."}, {"start": "00:01:22", "is_lecture": true, "end": "00:01:28", "is_worked_example": false, "text": "Instead we want to look at what instructions actually get executed while running the benchmark programs."}, {"start": "00:01:28", "is_lecture": true, "end": "00:01:38", "is_worked_example": false, "text": "This will take into account that instructions executed during each iteration of a loop might get executed 1000's of times even though they only appear in the program once."}, {"start": "00:01:38", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "Looking at the results, we see that over half of the arithmetic instructions have a small constant as their second operand."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "Comparisons involve small constants 80% of the time."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "This probably reflects the fact that during execution comparisons are used in determining whether we've reached the end of a loop."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:02", "is_worked_example": false, "text": "And small constants are often found in address calculations done by load and store operations."}, {"start": "00:02:02", "is_lecture": true, "end": "00:02:09", "is_worked_example": false, "text": "Operations involving constant operands are clearly a common case, one well worth optimizing."}, {"start": "00:02:09", "is_lecture": true, "end": "00:02:17", "is_worked_example": false, "text": "Adding support for small constant operands to the ISA resulted in programs that were measurably smaller and faster."}, {"start": "00:02:17", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "So: feature request approved!"}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "Here we see the second of the two Beta instruction formats."}, {"start": "00:02:24", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "It's a modification of the first format where we've replaced the 5-bit \"rb\" field with a 16-bit field holding a constant in two's complement format."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:49", "is_worked_example": false, "text": "This will allow us to represent constant operands in the range of 0x8000 (decimal -32768) to 0x7FFF (decimal 32767)."}, {"start": "00:02:49", "is_lecture": true, "end": "00:03:00", "is_worked_example": false, "text": "Here's an example of the add-constant (ADDC) instruction which adds the contents of R1 and the constant -3, writing the result into R3."}, {"start": "00:03:00", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "We can see that the second operand in the symbolic representation is now a constant (or, more generally, an expression that can evaluated to get a constant value)."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:20", "is_worked_example": false, "text": "One technical detail needs discussion: the instruction contains a 16-bit constant, but the datapath requires a 32-bit operand."}, {"start": "00:03:20", "is_lecture": true, "end": "00:03:29", "is_worked_example": false, "text": "How does the datapath hardware go about converting from, say, the 16-bit representation of -3 to the 32-bit representation of -3?"}, {"start": "00:03:29", "is_lecture": true, "end": "00:03:47", "is_worked_example": false, "text": "Comparing the 16-bit and 32-bit representations for various constants, we see that if the 16-bit two's-complement constant is negative (i.e., its high-order bit is 1), the high sixteen bits of the equivalent 32-bit constant are all 1's."}, {"start": "00:03:47", "is_lecture": true, "end": "00:03:57", "is_worked_example": false, "text": "And if the 16-bit constant is non-negative (i.e., its high-order bit is 0), the high sixteen bits of the 32-bit constant are all 0's."}, {"start": "00:03:57", "is_lecture": true, "end": "00:04:09", "is_worked_example": false, "text": "Thus the operation the hardware needs to perform is \"sign extension\" where the sign-bit of the 16-bit constant is replicated sixteen times to form the high half of the 32-bit constant."}, {"start": "00:04:09", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "The low half of the 32-bit constant is simply the 16-bit constant from the instruction."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:21", "is_worked_example": false, "text": "No additional logic gates will be needed to implement sign extension -- we can do it all with wiring."}, {"start": "00:04:21", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "Here are the fourteen ALU instructions in their \"with constant\" form, showing the same instruction mnemonics but with a \"C\" suffix indicate the second operand is a constant."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:39", "is_worked_example": false, "text": "Since these are additional instructions, these have different opcodes than the original ALU instructions."}, {"start": "00:04:39", "is_lecture": true, "end": "00:04:53", "is_worked_example": false, "text": "Finally, note that if we need a constant operand whose representation does NOT fit into 16 bits, then we have to store the constant as a 32-bit value in a main memory location and load it into a register for use just like we would any variable value."}, {"start": "00:04:53", "is_lecture": true, "end": "00:05:03", "is_worked_example": false, "text": "To give some sense for the additional datapath hardware that will be needed, let's update our implementation sketch to add support for constants as the second ALU operand."}, {"start": "00:05:03", "is_lecture": true, "end": "00:05:05", "is_worked_example": false, "text": "We don't have to add much hardware:"}, {"start": "00:05:05", "is_lecture": true, "end": "00:05:13", "is_worked_example": false, "text": "just a multiplexer which selects either the \"rb\" register value or the sign-extended constant from the 16-bit field in the instruction."}, {"start": "00:05:13", "is_lecture": true, "end": "00:05:22", "is_worked_example": false, "text": "The BSEL control signal that controls the multiplexer is 1 for the ALU-with-constant instructions and 0 for the regular ALU instructions."}, {"start": "00:05:22", "is_lecture": true, "end": "00:05:29", "is_worked_example": false, "text": "We'll put the hardware implementation details aside for now and revisit them in a few lectures."}]}, "C04S04B01-WE.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c4/c4s2/1?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c4s2v1", "items": [{"start": "00:00:00", "is_lecture": false, "end": "00:00:07", "is_worked_example": true, "text": "As presented in lecture, in this course, we use a simple 32-bit processor called the Beta."}, {"start": "00:00:07", "is_lecture": false, "end": "00:00:11", "is_worked_example": true, "text": "The Beta works on 32-bit instruction and data words."}, {"start": "00:00:11", "is_lecture": false, "end": "00:00:15", "is_worked_example": true, "text": "However, the addresses in memory are specified in bytes."}, {"start": "00:00:15", "is_lecture": false, "end": "00:00:22", "is_worked_example": true, "text": "A byte is made up of 8 bits, so each 32-bit instruction consists of 4 bytes."}, {"start": "00:00:22", "is_lecture": false, "end": "00:00:36", "is_worked_example": true, "text": "That means that if you have two instructions A and B in consecutive memory locations, if A is at address 0x100, then B is at address 0x104."}, {"start": "00:00:36", "is_lecture": false, "end": "00:00:41", "is_worked_example": true, "text": "Now, suppose that you are given the following piece of code."}, {"start": "00:00:41", "is_lecture": false, "end": "00:00:47", "is_worked_example": true, "text": "The . = 0 notation tells you that your program begins at address 0."}, {"start": "00:00:47", "is_lecture": false, "end": "00:00:54", "is_worked_example": true, "text": "You can assume that execution begins at this location 0 and halts when the HALT() instruction is about to be executed."}, {"start": "00:00:54", "is_lecture": false, "end": "00:01:01", "is_worked_example": true, "text": "We want to determine what value ends up in R0 after this instruction sequence has been executed."}, {"start": "00:01:01", "is_lecture": false, "end": "00:01:09", "is_worked_example": true, "text": "Note that we are working with hexadecimal numbers in this code and we want our answer to also be in hexadecimal."}, {"start": "00:01:09", "is_lecture": false, "end": "00:01:14", "is_worked_example": true, "text": "This code begins with a LD operation into register R0."}, {"start": "00:01:14", "is_lecture": false, "end": "00:01:21", "is_worked_example": true, "text": "The load, uses the value of R31 + c as the source address for the load."}, {"start": "00:01:21", "is_lecture": false, "end": "00:01:28", "is_worked_example": true, "text": "Since R31 = 0, this means that the value stored at address c is being loaded into R0."}, {"start": "00:01:28", "is_lecture": false, "end": "00:01:34", "is_worked_example": true, "text": "So after the LD, R0 = 0x300."}, {"start": "00:01:34", "is_lecture": false, "end": "00:01:43", "is_worked_example": true, "text": "Next an ADDC of R0 with the constant b is performed and that result is stored back into R0."}, {"start": "00:01:43", "is_lecture": false, "end": "00:01:53", "is_worked_example": true, "text": "The .=0x200 notation immediately preceding the \"a\" label, tells us that address a = 0x200."}, {"start": "00:01:53", "is_lecture": false, "end": "00:02:01", "is_worked_example": true, "text": "This means that address b = 0x204, and c = 0x208."}, {"start": "00:02:01", "is_lecture": false, "end": "00:02:16", "is_worked_example": true, "text": "So if we are adding the constant b to R0, R0 now becomes 0x300 + 0x204 = 0x504."}, {"start": "00:02:16", "is_lecture": false, "end": "00:02:19", "is_worked_example": true, "text": "Now lets take a look at this short piece of code."}, {"start": "00:02:19", "is_lecture": false, "end": "00:02:25", "is_worked_example": true, "text": "Our goal is to determine the value left in R0 in hexadecimal."}, {"start": "00:02:25", "is_lecture": false, "end": "00:02:33", "is_worked_example": true, "text": "The . = 0 notation once again tells us that our first instruction (the branch) is at address 0."}, {"start": "00:02:33", "is_lecture": false, "end": "00:02:43", "is_worked_example": true, "text": "The branch instruction then branches to location . + 4 = 0 + 4 = 4."}, {"start": "00:02:43", "is_lecture": false, "end": "00:02:46", "is_worked_example": true, "text": "This is the address of the HALT() instruction."}, {"start": "00:02:46", "is_lecture": false, "end": "00:02:59", "is_worked_example": true, "text": "In addition to branching to the HALT() instruction, a branch instruction also stores the address of the instruction immediately following it into the destination register, R0 in this case."}, {"start": "00:02:59", "is_lecture": false, "end": "00:03:07", "is_worked_example": true, "text": "The address of the next instruction is 4, so R0 = 0x4."}, {"start": "00:03:07", "is_lecture": false, "end": "00:03:12", "is_worked_example": true, "text": "Let's take a look at what this code is doing."}, {"start": "00:03:12", "is_lecture": false, "end": "00:03:26", "is_worked_example": true, "text": "It first loads the contents of address x into R0, so R0 = 0x0FACE0FF or 0xFACEOFF for short."}, {"start": "00:03:26", "is_lecture": false, "end": "00:03:32", "is_worked_example": true, "text": "It then moves the constant 0 into R1, so R1 = 0."}, {"start": "00:03:32", "is_lecture": false, "end": "00:03:40", "is_worked_example": true, "text": "It now enters the loop where the ANDC puts into R3 the least significant bit of R0."}, {"start": "00:03:40", "is_lecture": false, "end": "00:03:45", "is_worked_example": true, "text": "The ADD increments R1 if R3 equals 1."}, {"start": "00:03:45", "is_lecture": false, "end": "00:03:54", "is_worked_example": true, "text": "This means that if the least significant bit of R0 was a 1, then R1 is incremented by 1, otherwise R1 stays the same."}, {"start": "00:03:54", "is_lecture": false, "end": "00:03:59", "is_worked_example": true, "text": "The shift right constant then shifts R0 to the right by 1."}, {"start": "00:03:59", "is_lecture": false, "end": "00:04:10", "is_worked_example": true, "text": "This makes R0 have a 0 in the most significant bit, and the top 31 bits, of what R0 used to be, are shifted over by one position to the right."}, {"start": "00:04:10", "is_lecture": false, "end": "00:04:17", "is_worked_example": true, "text": "Note that this means that the least significant bit of the old R0 is now completely gone."}, {"start": "00:04:17", "is_lecture": false, "end": "00:04:24", "is_worked_example": true, "text": "That's okay though because we already incremented R1 based on that original least significant bit of R0."}, {"start": "00:04:24", "is_lecture": false, "end": "00:04:33", "is_worked_example": true, "text": "The BNE, or branch on not equal, then branches back to loop as long as R0 is not equal to 0."}, {"start": "00:04:33", "is_lecture": false, "end": "00:04:39", "is_worked_example": true, "text": "This means that what this loop is doing is looking at the current least significant bit of R0,"}, {"start": "00:04:39", "is_lecture": false, "end": "00:04:42", "is_worked_example": true, "text": "incrementing R1 if that bit is 1,"}, {"start": "00:04:42", "is_lecture": false, "end": "00:04:46", "is_worked_example": true, "text": "and then shifting that bit out until all bits have been shifted out."}, {"start": "00:04:46", "is_lecture": false, "end": "00:04:53", "is_worked_example": true, "text": "In other words, it's counting the total number of ones in the original value loaded from address x."}, {"start": "00:04:53", "is_lecture": false, "end": "00:05:03", "is_worked_example": true, "text": "The loop ends when all the 1's have been counted at which point R0 is left with a 0 in it because all the 1's have been shifted out."}, {"start": "00:05:03", "is_lecture": false, "end": "00:05:31", "is_worked_example": true, "text": "R1 is left with the number of 1's in the data 0x0FACE0FF equals in binary 0000 1111 1010 1100 1110 0000 1111 1111."}, {"start": "00:05:31", "is_lecture": false, "end": "00:05:46", "is_worked_example": true, "text": "There are 19 ones in 0x0FACE0FF, so R1 = 19 = 16 + 3 which in hexadecimal = 0x13."}, {"start": "00:05:46", "is_lecture": false, "end": "00:05:53", "is_worked_example": true, "text": "In this piece of code, the CMOVE first sets the stack pointer to 0x1000."}, {"start": "00:05:53", "is_lecture": false, "end": "00:05:58", "is_worked_example": true, "text": "Then a PUSH(SP) operation is performed."}, {"start": "00:05:58", "is_lecture": false, "end": "00:06:01", "is_worked_example": true, "text": "Lets first understand what a PUSH instruction does."}, {"start": "00:06:01", "is_lecture": false, "end": "00:06:06", "is_worked_example": true, "text": "A PUSH instruction is actually a macro made up of two beta instructions."}, {"start": "00:06:06", "is_lecture": false, "end": "00:06:16", "is_worked_example": true, "text": "To push a value onto the stack, the stack pointer is first incremented by 4 in order to point to the next empty location on the stack."}, {"start": "00:06:16", "is_lecture": false, "end": "00:06:20", "is_worked_example": true, "text": "This sets SP = 0x1004."}, {"start": "00:06:20", "is_lecture": false, "end": "00:06:34", "is_worked_example": true, "text": "Then, the contents of register Ra, which is being pushed onto the stack, are stored at the memory location whose address is SP-4 which is address 0x1000."}, {"start": "00:06:34", "is_lecture": false, "end": "00:06:46", "is_worked_example": true, "text": "Now looking at the actual PUSH operation performed here, we are performing a PUSH of stack pointer so the Ra register is also the stack pointer."}, {"start": "00:06:46", "is_lecture": false, "end": "00:06:57", "is_worked_example": true, "text": "This means that the value stored at location 0x1000 is actually the value of SP which is 0x1004."}, {"start": "00:06:57", "is_lecture": false, "end": "00:07:05", "is_worked_example": true, "text": "So the value that got pushed onto the stack is 0x1004."}]}, "C03S01B01-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s1/1?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "Welcome to Part 2 of 6.004x!"}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:13", "is_worked_example": false, "text": "In this part of the course, we turn our attention to the design and implementation of digital systems that can perform useful computations on different types of binary data."}, {"start": "00:00:13", "is_lecture": true, "end": "00:00:21", "is_worked_example": false, "text": "We'll come up with a general-purpose design for these systems, we which we call \"computers\", so that they can serve as useful tools in many diverse application areas."}, {"start": "00:00:21", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "Computers were first used to perform numeric calculations in science and engineering, but today they are used as the central control element in any system where complex behavior is required."}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:37", "is_worked_example": false, "text": "We have a lot to do in this chapter, so let's get started!"}, {"start": "00:00:37", "is_lecture": true, "end": "00:00:42", "is_worked_example": false, "text": "Suppose we want to design a system to compute the factorial function on some numeric argument N."}, {"start": "00:00:42", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "N! is defined as the product of N times N-1 times N-2, and so on down to 1."}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "We can use a programming language like C to describe the sequence of operations necessary to perform the factorial computation."}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:00", "is_worked_example": false, "text": "In this program there are two variables, \"a\" and \"b\"."}, {"start": "00:01:00", "is_lecture": true, "end": "00:01:04", "is_worked_example": false, "text": "\"a\" is used to accumulate the answer as we compute it step-by-step."}, {"start": "00:01:04", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "\"b\" is used to hold the next value we need to multiply."}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "\"b\" starts with the value of the numeric argument N."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:25", "is_worked_example": false, "text": "The DO loop is where the work gets done: on each loop iteration we perform one of the multiplies from the factorial formula, updating the value of the accumulator \"a\" with the result, then decrementing \"b\" in preparation for the next loop iteration."}, {"start": "00:01:25", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "If we want to implement a digital system that performs this sequence of operations, it makes sense to use sequential logic!"}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "Here's the state transition diagram for a high-level finite-state machine designed to perform the necessary computations in the desired order."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:47", "is_worked_example": false, "text": "We call this a high-level FSM since the \"outputs\" of each state are more than simple logic levels."}, {"start": "00:01:47", "is_lecture": true, "end": "00:01:54", "is_worked_example": false, "text": "They are formulas indicating operations to be performed on source variables, storing the result in a destination variable."}, {"start": "00:01:54", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "The sequence of states visited while the FSM is running mirrors the steps performed by the execution of the C program."}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:11", "is_worked_example": false, "text": "The FSM repeats the LOOP state until the new value to be stored in \"b\" is equal to 0, at which point the FSM transitions into the final DONE state."}, {"start": "00:02:11", "is_lecture": true, "end": "00:02:19", "is_worked_example": false, "text": "The high-level FSM is useful when designing the circuitry necessary to implement the desired computation using our digital logic building blocks."}, {"start": "00:02:19", "is_lecture": true, "end": "00:02:23", "is_worked_example": false, "text": "We'll use 32-bit D-registers to hold the \"a\" and \"b\" values."}, {"start": "00:02:23", "is_lecture": true, "end": "00:02:32", "is_worked_example": false, "text": "And we'll need a 2-bit D-register to hold the 2-bit encoding of the current state, i.e., the encoding for either START, LOOP or DONE."}, {"start": "00:02:32", "is_lecture": true, "end": "00:02:37", "is_worked_example": false, "text": "We'll include logic to compute the inputs required to implement the correct state transitions."}, {"start": "00:02:37", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "In this case, we need to know if the new value for \"b\" is zero or not."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:52", "is_worked_example": false, "text": "And, finally, we'll need logic to perform multiply and decrement, and to select which value should be loaded into the \"a\" and \"b\" registers at the end of each FSM cycle."}, {"start": "00:02:52", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "Let's start by designing the logic that implements the desired computations -- we call this part of the logic the \"datapath\"."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:04", "is_worked_example": false, "text": "First we'll need two 32-bit D-registers to hold the \"a\" and \"b\" values."}, {"start": "00:03:04", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "Then we'll draw the combinational logic blocks needed to compute the values to be stored in those registers."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:17", "is_worked_example": false, "text": "In the START state , we need the constant 1 to load into the \"a\" register and the constant N to load into the \"b\" register."}, {"start": "00:03:17", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "In the LOOP state, we need to compute a*b for the \"a\" register and b-1 for the \"b\" register."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "Finally, in the DONE state , we need to be able to reload each register with its current value."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "We'll use multiplexers to select the appropriate value to load into each of the data registers."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:47", "is_worked_example": false, "text": "These multiplexers are controlled by 2-bit select signals that choose which of the three 32-bit input values will be the 32-bit value to be loaded into the register."}, {"start": "00:03:47", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "So by choosing the appropriate values for WASEL and WBSEL, we can make the datapath compute the desired values at each step in the FSM's operation."}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "Next we'll add the combinational logic needed to control the FSM's state transitions."}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:07", "is_worked_example": false, "text": "In this case, we need to test if the new value to be loaded into the \"b\" register is zero."}, {"start": "00:04:07", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "The Z signal from the datapath will be 1 if that's the case and 0 otherwise."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:25", "is_worked_example": false, "text": "Now we're all set to add the hardware for the control FSM, which has one input (Z) from the datapath and generates two 2-bit outputs (WASEL and WBSEL) to control the datapath."}, {"start": "00:04:25", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "Here's the truth table for the FSM's combinational logic."}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:34", "is_worked_example": false, "text": "S is the current state, encoded as a 2-bit value, and S' is the next state."}, {"start": "00:04:34", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "Using our skills from Part 1 of the course, we're ready to draw a schematic for the system!"}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "We know how to design the appropriate multiplier and decrement circuitry."}, {"start": "00:04:44", "is_lecture": true, "end": "00:04:48", "is_worked_example": false, "text": "And we can use our standard register-and-ROM implementation for the control FSM."}, {"start": "00:04:48", "is_lecture": true, "end": "00:05:01", "is_worked_example": false, "text": "The Z signal from the datapath is combined with the 2 bits of current state to form the 3 inputs to the combinational logic, in this case realized by a read-only memory with 2^3=8 locations."}, {"start": "00:05:01", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "Each ROM location has the appropriate values for the 6 output bits: 2 bits each for WASEL, WBSEL, and next state."}, {"start": "00:05:10", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "The table on the right shows the ROM contents, which are easily determined from the table on the previous slide."}]}, "C03S01B14-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s1/14?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s1v14", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "Finally, our last instruction!"}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:07", "is_worked_example": false, "text": "Branches conditionally transfer control to a specific target instruction."}, {"start": "00:00:07", "is_lecture": true, "end": "00:00:18", "is_worked_example": false, "text": "But we'll also need the ability to compute the address of the target instruction -- that ability is provided by the JMP instruction which simply sets the program counter to value from register \"ra\"."}, {"start": "00:00:18", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "Like branches, JMP will write the PC+4 value into to the specified destination register."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "This capability is very useful for implementing procedures in Beta code."}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:37", "is_worked_example": false, "text": "Suppose we have a procedure \"sqrt\" that computes the square root of its argument, which is passed in, say, R0."}, {"start": "00:00:37", "is_lecture": true, "end": "00:00:42", "is_worked_example": false, "text": "We don't show the code for sqrt on the right, except for the last instruction, which is a JMP."}, {"start": "00:00:42", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "On the left we see that the programmer wants to call the sqrt procedure from two different places in his program."}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:50", "is_worked_example": false, "text": "Let's watch what happens..."}, {"start": "00:00:50", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "The first call to the sqrt procedure is implemented by the unconditional branch at location 0x100 in main memory."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:04", "is_worked_example": false, "text": "The branch target is the first instruction of the sqrt procedure, so execution continues there."}, {"start": "00:01:04", "is_lecture": true, "end": "00:01:13", "is_worked_example": false, "text": "The BEQ also writes the address of the following instruction (0x104) into its destination register, R28."}, {"start": "00:01:13", "is_lecture": true, "end": "00:01:27", "is_worked_example": false, "text": "When we reach the end of first procedure call, the JMP instruction loads the value in R28, which is 0x104, into the PC, so execution continues with the instruction following the first BEQ."}, {"start": "00:01:27", "is_lecture": true, "end": "00:01:34", "is_worked_example": false, "text": "So we've managed to return from the procedure and continue execution where we left off in the main program."}, {"start": "00:01:34", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "When we get to the second call to the sqrt procedure, the sequence of events is the same as before except that this time R28 contains 0x67C, the address of the instruction following the second BEQ."}, {"start": "00:01:48", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "So the second time we reach the end of the sqrt procedure, the JMP sets the PC to 0x67C and execution resumes with the instruction following the second procedure call."}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "Neat!"}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:06", "is_worked_example": false, "text": "The BEQs and JMP have worked together to implement procedure call and return."}, {"start": "00:02:06", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "We'll discuss the implementation of procedures in detail in an upcoming lecture."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "That wraps up the design of the Beta instruction set architecture."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "In summary, the Beta has 32 registers to hold values that can be used as operands for the ALU."}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:27", "is_worked_example": false, "text": "All other values, along with the binary representation of the program itself, are stored in main memory."}, {"start": "00:02:27", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "The Beta supports 32-bit memory addresses and can access values in 2^32 = 4 gigabytes of main memory."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:45", "is_worked_example": false, "text": "All Beta memory access refer to 32-bit words, so all addresses will be a multiple of 4 since there are 4 bytes/word."}, {"start": "00:02:45", "is_lecture": true, "end": "00:02:48", "is_worked_example": false, "text": "The are two instruction formats."}, {"start": "00:02:48", "is_lecture": true, "end": "00:02:53", "is_worked_example": false, "text": "The first specifies an opcode, two source registers and a destination register."}, {"start": "00:02:53", "is_lecture": true, "end": "00:03:03", "is_worked_example": false, "text": "The second replaces the second source register with a 32-bit constant, derived by sign-extending a 16-bit constant stored in the instruction itself."}, {"start": "00:03:03", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "There are three classes of instructions:"}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "ALU operations, LD and ST for accessing main memory, and branches and JMPs that change the order of execution."}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "And that's it!"}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "As we'll see in the next lecture, we'll be able parlay this relatively simple repertoire of operations into a system that can execute any computation we can specify."}]}, "C06S01B04-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c6/c6s1/4?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c6s1v4", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:03", "is_worked_example": false, "text": "Now let's turn our attention compile_statement."}, {"start": "00:00:03", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "The first two statement types are pretty easy to handle."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:11", "is_worked_example": false, "text": "Unconditional statements are usually assignment expressions or procedure calls."}, {"start": "00:00:11", "is_lecture": true, "end": "00:00:15", "is_worked_example": false, "text": "We'll simply ask compile_expr to generate the appropriate code."}, {"start": "00:00:15", "is_lecture": true, "end": "00:00:18", "is_worked_example": false, "text": "Compound statements are equally easy."}, {"start": "00:00:18", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "We'll recursively call compile_statement to generate code for each statement in turn."}, {"start": "00:02:24", "is_lecture": true, "end": "00:00:28", "is_worked_example": false, "text": "The code for statement_2 will immediately follow the code generated for statement_1."}, {"start": "00:00:28", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "Execution will proceed sequentially through the code for each statement."}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "Here we see the simplest form the conditional statement, where we need to generate code to evaluate the test expression and then, if the value in the register is FALSE, skip over the code that executes the statement in the THEN clause."}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:57", "is_worked_example": false, "text": "The simple assembly-language template uses recursive calls to compile_expr and compile_statement to generate code for the various parts of the IF statement."}, {"start": "00:00:57", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "The full-blown conditional statement includes an ELSE clause, which should be executed if the value of the test expression is FALSE."}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "The template uses some branches and labels to ensure the course of execution is as intended."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:29", "is_worked_example": false, "text": "You can see that the compilation process is really just the application of many small templates that break the code generation task down step-by-step into smaller and smaller tasks, generating the necessary code to glue all the pieces together in the appropriate fashion."}, {"start": "00:01:29", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "And here's the template for the WHILE statement, which looks a lot like the template for the IF statement with a branch at the end that causes the generated code to be re-executed until the value of the test expression is FALSE."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:46", "is_worked_example": false, "text": "With a bit of thought, we can improve on this template slightly."}, {"start": "00:01:46", "is_lecture": true, "end": "00:01:59", "is_worked_example": false, "text": "We've reorganized the code so that only a single branch instruction (BT) is executed each iteration, instead of the two branches (BF, BR) per iteration in the original template."}, {"start": "00:01:59", "is_lecture": true, "end": "00:02:07", "is_worked_example": false, "text": "Not a big deal, but little optimizations to code inside a loop can add up to big savings in a long-running program."}, {"start": "00:02:07", "is_lecture": true, "end": "00:02:12", "is_worked_example": false, "text": "Just a quick comment about another common iteration statement, the FOR loop."}, {"start": "00:02:12", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "The FOR loop is a shorthand way of expressing iterations where the loop index (\"i\" in the example shown) is run through a sequence of values and the body of the FOR loop is executed once for each value of the loop index."}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:34", "is_worked_example": false, "text": "The FOR loop can be transformed into the WHILE statement shown here, which can then be compiled using the templates shown above."}, {"start": "00:02:34", "is_lecture": true, "end": "00:02:43", "is_worked_example": false, "text": "In this example, we've applied our templates to generate code for the iterative implementation of the factorial function that we've seen before."}, {"start": "00:02:43", "is_lecture": true, "end": "00:02:51", "is_worked_example": false, "text": "Look through the generated code and you'll be able to match the code fragments with the templates from last couple of slides."}, {"start": "00:02:51", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "It's not the most efficient code, but not bad given the simplicity of the recursive-descent approach for compiling high-level programs."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "It's a simple matter to modify the recursive-descent process to accommodate variable values that are stored in dedicated registers rather than in main memory."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:20", "is_worked_example": false, "text": "Optimizing compilers are quite good at identifying opportunities to keep values in registers and hence avoid the LD and ST operations needed to access values in main memory."}, {"start": "00:03:20", "is_lecture": true, "end": "00:03:28", "is_worked_example": false, "text": "Using this simple optimization, the number of instructions in the loop has gone from 10 down to 4."}, {"start": "00:03:28", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "Now the generated code is looking pretty good!"}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "But rather than keep tweaking the recursive-descent approach, let's stop here."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "In the next segment, we'll see how modern compilers take a more general approach to generating code."}, {"start": "00:03:41", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "Still though, the first time I learned about recursive descent, I ran home to write a simple implementation and marveled at having authored my own compiler in an afternoon!"}]}, "C04S03B07-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c4/c4s1/7?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c4s1v7", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "An interesting question for computer architects is what capabilities must be included in the ISA?"}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:20", "is_worked_example": false, "text": "When we studied Boolean gates in Part 1 of the course, we were able to prove that NAND gates were universal, i.e., that we could implement any Boolean function using only circuits constructed from NAND gates."}, {"start": "00:00:20", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "We can ask the corresponding question of our ISA:"}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "is it universal, i.e., can it be used to perform any computation?"}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:32", "is_worked_example": false, "text": "What problems can we solve with a von Neumann computer?"}, {"start": "00:00:32", "is_lecture": true, "end": "00:00:36", "is_worked_example": false, "text": "Can the Beta solve any problem FSMs can solve?"}, {"start": "00:00:36", "is_lecture": true, "end": "00:00:40", "is_worked_example": false, "text": "Are there problems FSMs can't solve?"}, {"start": "00:00:40", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "If so, can the Beta solve those problems?"}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:47", "is_worked_example": false, "text": "Do the answers to these questions depend on the particular ISA?"}, {"start": "00:00:47", "is_lecture": true, "end": "00:00:52", "is_worked_example": false, "text": "To provide some answers, we need a mathematical model of computation."}, {"start": "00:00:52", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "Reasoning about the model, we should be able to prove what can be computed and what can't."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "And hopefully we can ensure that the Beta ISA has the functionality needed to perform any computation."}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "The roots of computer science stem from the evaluation of many alternative mathematical models of computation to determine the classes of computation each could represent."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:24", "is_worked_example": false, "text": "An elusive goal was to find a universal model, capable of representing *all* realizable computations."}, {"start": "00:01:24", "is_lecture": true, "end": "00:01:35", "is_worked_example": false, "text": "In other words if a computation could be described using some other well-formed model, we should also be able to describe the same computation using the universal model."}, {"start": "00:01:35", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "One candidate model might be finite state machines (FSMs), which can be built using sequential logic."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:55", "is_worked_example": false, "text": "Using Boolean logic and state transition diagrams we can reason about how an FSM will operate on any given input, predicting the output with 100% certainty."}, {"start": "00:01:55", "is_lecture": true, "end": "00:02:00", "is_worked_example": false, "text": "Are FSMs the universal digital computing device?"}, {"start": "00:02:00", "is_lecture": true, "end": "00:02:08", "is_worked_example": false, "text": "In other words, can we come up with FSM implementations that implement all computations that can be solved by any digital device?"}, {"start": "00:02:08", "is_lecture": true, "end": "00:02:16", "is_worked_example": false, "text": "Despite their usefulness and flexibility, there are common problems that cannot be solved by any FSM."}, {"start": "00:02:16", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "For example, can we build an FSM to determine if a string of parentheses (properly encoded into a binary sequence) is well-formed?"}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "A parenthesis string is well-formed if the parentheses balance, i.e., for every open parenthesis there is a matching close parenthesis later in the string."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "In the example shown here, the input string on the top is well-formed, but the input string on the bottom is not."}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:53", "is_worked_example": false, "text": "After processing the input string, the FSM would output a 1 if the string is well-formed, 0 otherwise."}, {"start": "00:02:53", "is_lecture": true, "end": "00:02:57", "is_worked_example": false, "text": "Can this problem be solved using an FSM?"}, {"start": "00:02:57", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "No, it can't."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:05", "is_worked_example": false, "text": "The difficulty is that the FSM uses its internal state to encode what it knows about the history of the inputs."}, {"start": "00:03:05", "is_lecture": true, "end": "00:03:18", "is_worked_example": false, "text": "In the paren checker, the FSM would need to count the number of unbalanced open parens seen so far, so it can determine if future input contains the required number of close parens."}, {"start": "00:03:18", "is_lecture": true, "end": "00:03:27", "is_worked_example": false, "text": "But in a finite state machine there are only a fixed number of states, so a particular FSM has a maximum count it can reach."}, {"start": "00:03:27", "is_lecture": true, "end": "00:03:38", "is_worked_example": false, "text": "If we feed the FSM an input with more open parens than it has the states to count, it won't be able to check if the input string is well-formed."}, {"start": "00:03:38", "is_lecture": true, "end": "00:03:45", "is_worked_example": false, "text": "The \"finite-ness\" of FSMs limits their ability to solve problems that require unbounded counting."}, {"start": "00:03:45", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "Hmm, what other models of computation might we consider?"}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:57", "is_worked_example": false, "text": "Mathematics to the rescue, in this case in the form of a British mathematician named Alan Turing."}, {"start": "00:03:57", "is_lecture": true, "end": "00:04:06", "is_worked_example": false, "text": "In the early 1930's Alan Turing was one of many mathematicians studying the limits of proof and computation."}, {"start": "00:04:06", "is_lecture": true, "end": "00:04:18", "is_worked_example": false, "text": "He proposed a conceptual model consisting of an FSM combined with a infinite digital tape that could read and written under the control of the FSM."}, {"start": "00:04:18", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "The inputs to some computation would be encoded as symbols on the tape, then the FSM would read the tape, changing its state as it performed the computation, then write the answer onto the tape and finally halting."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:36", "is_worked_example": false, "text": "Nowadays, this model is called a Turing Machine (TM)."}, {"start": "00:04:36", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "Turing Machines, like other models of the time, solved the \"finite\" problem of FSMs."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:47", "is_worked_example": false, "text": "So how does all this relate to computation?"}, {"start": "00:04:47", "is_lecture": true, "end": "00:04:56", "is_worked_example": false, "text": "Assuming the non-blank input on the tape occupies a finite number of adjacent cells, it can be expressed as a large integer."}, {"start": "00:04:56", "is_lecture": true, "end": "00:05:07", "is_worked_example": false, "text": "Just construct a binary number using the bit encoding of the symbols from the tape, alternating between symbols to the left of the tape head and symbols to the right of the tape head."}, {"start": "00:05:07", "is_lecture": true, "end": "00:05:13", "is_worked_example": false, "text": "Eventually all the symbols will be incorporated into the (very large) integer representation."}, {"start": "00:05:13", "is_lecture": true, "end": "00:05:27", "is_worked_example": false, "text": "So both the input and output of the TM can be thought of as large integers, and the TM itself as implementing an integer function that maps input integers to output integers."}, {"start": "00:05:27", "is_lecture": true, "end": "00:05:33", "is_worked_example": false, "text": "The FSM brain of the Turing Machine can be characterized by its truth table."}, {"start": "00:05:33", "is_lecture": true, "end": "00:05:42", "is_worked_example": false, "text": "And we can systematically enumerate all the possible FSM truth tables, assigning an index to each truth table as it appears in the enumeration."}, {"start": "00:05:42", "is_lecture": true, "end": "00:05:51", "is_worked_example": false, "text": "Note that indices get very large very quickly since they essentially incorporate all the information in the truth table."}, {"start": "00:05:51", "is_lecture": true, "end": "00:05:55", "is_worked_example": false, "text": "Fortunately we have a very large supply of integers!"}, {"start": "00:05:55", "is_lecture": true, "end": "00:06:02", "is_worked_example": false, "text": "We'll use the index for a TM's FSM to identify the TM as well."}, {"start": "00:06:02", "is_lecture": true, "end": "00:06:11", "is_worked_example": false, "text": "So we can talk about TM 347 running on input 51, producing the answer 42."}]}, "C06S01B01-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c6/c6s1/1?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c6s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "Today we're going to talk about how to translate high-level languages into code that computers can execute."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:14", "is_worked_example": false, "text": "So far we've seen the Beta ISA, which includes instructions that control the datapath operations performed on 32-bit data stored in the registers."}, {"start": "00:00:14", "is_lecture": true, "end": "00:00:19", "is_worked_example": false, "text": "There are also instructions for accessing main memory and changing the program counter."}, {"start": "00:00:19", "is_lecture": true, "end": "00:00:26", "is_worked_example": false, "text": "The instructions are formatted as opcode, source, and destination fields that form 32-bit values in main memory."}, {"start": "00:00:26", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "To make our lives easier, we developed assembly language as a way of specifying sequences of instructions."}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:38", "is_worked_example": false, "text": "Each assembly language statement corresponds to a single instruction."}, {"start": "00:00:38", "is_lecture": true, "end": "00:00:48", "is_worked_example": false, "text": "As assembly language programmers, we're responsible for managing which values are in registers and which are in main memory, and we need to figure out how to break down complicated operations,"}, {"start": "00:00:48", "is_lecture": true, "end": "00:00:54", "is_worked_example": false, "text": "e.g., accessing an element of an array, into the right sequence of Beta operations."}, {"start": "00:00:54", "is_lecture": true, "end": "00:01:01", "is_worked_example": false, "text": "We can go one step further and use high-level languages to describe the computations we want to perform."}, {"start": "00:01:01", "is_lecture": true, "end": "00:01:11", "is_worked_example": false, "text": "These languages use variables and other data structures to abstract away the details of storage allocation and the movement of data to and from main memory."}, {"start": "00:01:11", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "We can just refer to a data object by name and let the language processor handle the details."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:26", "is_worked_example": false, "text": "Similarly, we'll write expressions and other operators such as assignment (=) to efficiently describe what would require many statements in assembly language."}, {"start": "00:01:26", "is_lecture": true, "end": "00:01:33", "is_worked_example": false, "text": "Today we're going to dive into how to translate high-level language programs into code that will run on the Beta."}, {"start": "00:01:33", "is_lecture": true, "end": "00:01:42", "is_worked_example": false, "text": "Here we see Euclid's algorithm for determining the greatest common divisor of two numbers, in this case the algorithm is written in the C programming language."}, {"start": "00:01:42", "is_lecture": true, "end": "00:01:47", "is_worked_example": false, "text": "We'll be using a simple subset of C as our example high-level language."}, {"start": "00:01:47", "is_lecture": true, "end": "00:01:54", "is_worked_example": false, "text": "Please see the brief overview of C in the Handouts section if you'd like an introduction to C syntax and semantics."}, {"start": "00:01:54", "is_lecture": true, "end": "00:02:03", "is_worked_example": false, "text": "C was developed by Dennis Ritchie at AT&T Bell Labs in the late 60's and early 70's to use when implementing the Unix operating system."}, {"start": "00:02:03", "is_lecture": true, "end": "00:02:14", "is_worked_example": false, "text": "Since that time many new high-level languages have been introduced providing modern abstractions like object-oriented programming along with useful new data and control structures."}, {"start": "00:02:14", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "Using C allows us describe a computation without referring to any of the details of the Beta ISA like registers, specific Beta instructions, and so on."}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "The absence of such details means there is less work required to create the program and makes it easier for others to read and understand the algorithm implemented by the program."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:40", "is_worked_example": false, "text": "There are many advantages to using a high-level language."}, {"start": "00:02:40", "is_lecture": true, "end": "00:02:45", "is_worked_example": false, "text": "They enable programmers to be very productive since the programs are concise and readable."}, {"start": "00:02:45", "is_lecture": true, "end": "00:02:49", "is_worked_example": false, "text": "These attributes also make it easy to maintain the code."}, {"start": "00:02:49", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "Often it is harder to make certain types of mistakes since the language allows us to check for silly errors like storing a string value into a numeric variable."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:07", "is_worked_example": false, "text": "And more complicated tasks like dynamically allocating and deallocating storage can be completely automated."}, {"start": "00:03:07", "is_lecture": true, "end": "00:03:15", "is_worked_example": false, "text": "The result is that it can take much less time to create a correct program in a high-level language than it would it when writing in assembly language."}, {"start": "00:03:15", "is_lecture": true, "end": "00:03:30", "is_worked_example": false, "text": "Since the high-level language has abstracted away the details of a particular ISA, the programs are portable in the sense that we can expect to run the same code on different ISAs without having to rewrite the code."}, {"start": "00:03:30", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "What do we lose by using a high-level language?"}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:42", "is_worked_example": false, "text": "Should we worry that we'll pay a price in terms of the efficiency and performance we might get by crafting each instruction by hand?"}, {"start": "00:03:42", "is_lecture": true, "end": "00:03:46", "is_worked_example": false, "text": "The answer depends on how we choose to run high-level language programs."}, {"start": "00:03:46", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "The two basic execution strategies are \"interpretation\" and \"compilation\"."}, {"start": "00:03:52", "is_lecture": true, "end": "00:04:00", "is_worked_example": false, "text": "To interpret a high-level language program, we'll write a special program called an \"interpreter\" that runs on the actual computer, M1."}, {"start": "00:04:00", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "The interpreter mimics the behavior of some abstract easy-to-program machine M2 and for each M2 operation executes sequences of M1 instructions to achieve the desired result."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "We can think of the interpreter along with M1 as an implementation of M2, i.e., given a program written for M2, the interpreter will, step-by-step, emulate the effect of M2 instructions."}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "We often use several layers of interpretation when tackling computation tasks."}, {"start": "00:04:33", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "For example, an engineer may use her laptop with an Intel CPU to run the Python interpreter."}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:49", "is_worked_example": false, "text": "In Python, she loads the SciPy toolkit, which provides a calculator-like interface for numerical analysis for matrices and data."}, {"start": "00:04:49", "is_lecture": true, "end": "00:05:02", "is_worked_example": false, "text": "For each SciPy command, e.g., \"find the maximum value of a dataset\", the SciPy tool kit executes many Python statements, e.g., to loop over each element of the array, remembering the largest value."}, {"start": "00:05:02", "is_lecture": true, "end": "00:05:12", "is_worked_example": false, "text": "For each Python statement, the Python interpreter executes many x86 instructions, e.g., to increment the loop index and check for loop termination."}, {"start": "00:05:12", "is_lecture": true, "end": "00:05:23", "is_worked_example": false, "text": "Executing a single SciPy command may require executing of tens of Python statements, which in turn each may require executing hundreds of x86 instructions."}, {"start": "00:05:23", "is_lecture": true, "end": "00:05:29", "is_worked_example": false, "text": "The engineer is very happy she didn't have to write each of those instructions herself!"}, {"start": "00:05:29", "is_lecture": true, "end": "00:05:44", "is_worked_example": false, "text": "Interpretation is an effective implementation strategy when performing a computation once, or when exploring which computational approach is most effective before making a more substantial investment in creating a more efficient implementation."}, {"start": "00:05:44", "is_lecture": true, "end": "00:05:57", "is_worked_example": false, "text": "We'll use a compilation implementation strategy when we have computational tasks that we need to execute repeatedly and hence we are willing to invest more time up-front for more efficiency in the long-term."}, {"start": "00:05:57", "is_lecture": true, "end": "00:06:01", "is_worked_example": false, "text": "In compilation, we also start with our actual computer M1."}, {"start": "00:06:01", "is_lecture": true, "end": "00:06:09", "is_worked_example": false, "text": "Then we'll take our high-level language program P2 and translate it statement-by-statement into a program for M1."}, {"start": "00:06:09", "is_lecture": true, "end": "00:06:12", "is_worked_example": false, "text": "Note that we're not actually running the P2 program."}, {"start": "00:06:12", "is_lecture": true, "end": "00:06:19", "is_worked_example": false, "text": "Instead we're using it as a template to create an equivalent P1 program that can execute directly on M1."}, {"start": "00:06:19", "is_lecture": true, "end": "00:06:27", "is_worked_example": false, "text": "The translation process is called \"compilation\" and the program that does the translation is called a \"compiler\"."}, {"start": "00:06:27", "is_lecture": true, "end": "00:06:36", "is_worked_example": false, "text": "We compile the P2 program once to get the translation P1, and then we'll run P1 on M1 whenever we want to execute P2."}, {"start": "00:06:36", "is_lecture": true, "end": "00:06:45", "is_worked_example": false, "text": "Running P1 avoids the overhead of having to process the P2 source and the costs of executing any intervening layers of interpretation."}, {"start": "00:06:45", "is_lecture": true, "end": "00:06:52", "is_worked_example": false, "text": "Instead of dynamically figuring out the necessary machine instructions for each P2 statement as it's encountered,"}, {"start": "00:06:52", "is_lecture": true, "end": "00:06:59", "is_worked_example": false, "text": "in effect we've arranged to capture that stream of machine instructions and save them as a P1 program for later execution."}, {"start": "00:06:59", "is_lecture": true, "end": "00:07:06", "is_worked_example": false, "text": "If we're willing to pay the up-front costs of compilation, we'll get more efficient execution."}, {"start": "00:07:06", "is_lecture": true, "end": "00:07:15", "is_worked_example": false, "text": "And, with different compilers, we can arrange to run P2 on many different machines -- M2, M3, etc. -- without having rewrite P2."}, {"start": "00:07:15", "is_lecture": true, "end": "00:07:24", "is_worked_example": false, "text": "So we now have two ways to execute a high-level language program: interpretation and compilation."}, {"start": "00:07:24", "is_lecture": true, "end": "00:07:27", "is_worked_example": false, "text": "Both allow us to change the original source program."}, {"start": "00:07:27", "is_lecture": true, "end": "00:07:32", "is_worked_example": false, "text": "Both allow us to abstract away the details of the actual computer we'll use to run the program."}, {"start": "00:07:32", "is_lecture": true, "end": "00:07:36", "is_worked_example": false, "text": "And both strategies are widely used in modern computer systems!"}, {"start": "00:07:36", "is_lecture": true, "end": "00:07:41", "is_worked_example": false, "text": "Let's summarize the differences between interpretation and compilation."}, {"start": "00:07:41", "is_lecture": true, "end": "00:07:46", "is_worked_example": false, "text": "Suppose the statement \"x+2\" appears in the high-level program."}, {"start": "00:07:46", "is_lecture": true, "end": "00:07:53", "is_worked_example": false, "text": "When the interpreter processes this statement it immediately fetches the value of the variable x and adds 2 to it."}, {"start": "00:07:53", "is_lecture": true, "end": "00:08:02", "is_worked_example": false, "text": "On the other hand, the compiler would generate Beta instructions that would LD the variable x into a register and then ADD 2 to that value."}, {"start": "00:08:02", "is_lecture": true, "end": "00:08:14", "is_worked_example": false, "text": "The interpreter is executing each statement as it's processed and, in fact, may process and execute the same statement many times if, e.g., it was in a loop."}, {"start": "00:08:14", "is_lecture": true, "end": "00:08:19", "is_worked_example": false, "text": "The compiler is just generating instructions to be executed at some later time."}, {"start": "00:08:19", "is_lecture": true, "end": "00:08:30", "is_worked_example": false, "text": "Interpreters have the overhead of processing the high-level source code during execution and that overhead may be incurred many times in loops."}, {"start": "00:08:30", "is_lecture": true, "end": "00:08:36", "is_worked_example": false, "text": "Compilers incur the processing overhead once, making the eventual execution more efficient."}, {"start": "00:08:36", "is_lecture": true, "end": "00:08:47", "is_worked_example": false, "text": "But during development, the programmer may have to compile and run the program many times, often incurring the cost of compilation for only a single execution of the program."}, {"start": "00:08:47", "is_lecture": true, "end": "00:08:51", "is_worked_example": false, "text": "So the compile-run-debug loop can take more time."}, {"start": "00:08:51", "is_lecture": true, "end": "00:09:02", "is_worked_example": false, "text": "The interpreter is making decisions about the data type of x and the type of operations necessary at run time, i.e., while the program is running."}, {"start": "00:09:02", "is_lecture": true, "end": "00:09:06", "is_worked_example": false, "text": "The compiler is making those decisions during the compilation process."}, {"start": "00:09:06", "is_lecture": true, "end": "00:09:08", "is_worked_example": false, "text": "Which is the better approach?"}, {"start": "00:09:08", "is_lecture": true, "end": "00:09:14", "is_worked_example": false, "text": "In general, executing compiled code is much faster than running the code interpretively."}, {"start": "00:09:14", "is_lecture": true, "end": "00:09:29", "is_worked_example": false, "text": "But since the interpreter is making decisions at run time, it can change its behavior depending, say, on the type of the data in the variable X, offering considerable flexibility in handling different types of data with the same algorithm."}, {"start": "00:09:29", "is_lecture": true, "end": "00:09:35", "is_worked_example": false, "text": "Compilers take away that flexibility in exchange for fast execution."}]}, "C04S03B08-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c4/c4s1/8?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c4s1v8", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:10", "is_worked_example": false, "text": "There are many other models of computation, each of which describes a class of integer functions where a computation is performed on an integer input to produce an integer answer."}, {"start": "00:00:10", "is_lecture": true, "end": "00:00:18", "is_worked_example": false, "text": "Kleene, Post and Turing were all students of Alonzo Church at Princeton University in the mid-1930's."}, {"start": "00:00:18", "is_lecture": true, "end": "00:00:22", "is_worked_example": false, "text": "They explored many other formulations for modeling computation:"}, {"start": "00:00:22", "is_lecture": true, "end": "00:00:27", "is_worked_example": false, "text": "recursive functions, rule-based systems for string rewriting, and the lambda calculus."}, {"start": "00:00:27", "is_lecture": true, "end": "00:00:36", "is_worked_example": false, "text": "They were all particularly intrigued with proving the existence of problems unsolvable by realizable machines."}, {"start": "00:00:36", "is_lecture": true, "end": "00:00:42", "is_worked_example": false, "text": "Which, of course, meant characterizing the problems that could be solved by realizable machines."}, {"start": "00:00:42", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "It turned out that each model was capable of computing *exactly* the same set of integer functions!"}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:56", "is_worked_example": false, "text": "This was proved by coming up with constructions that translated the steps in a computation between the various models."}, {"start": "00:00:56", "is_lecture": true, "end": "00:01:05", "is_worked_example": false, "text": "It was possible to show that if a computation could be described by one model, an equivalent description exists in the other model."}, {"start": "00:01:05", "is_lecture": true, "end": "00:01:12", "is_worked_example": false, "text": "This lead to a notion of computability that was independent of the computation scheme chosen."}, {"start": "00:01:12", "is_lecture": true, "end": "00:01:24", "is_worked_example": false, "text": "This notion is formalized by Church's Thesis, which says that every discrete function computable by any realizable machine is computable by some Turing Machine."}, {"start": "00:01:24", "is_lecture": true, "end": "00:01:38", "is_worked_example": false, "text": "So if we say the function f(x) is computable, that's equivalent to saying that there's a TM that given x as an input on its tape will write f(x) as an output on the tape and halt."}, {"start": "00:01:38", "is_lecture": true, "end": "00:01:45", "is_worked_example": false, "text": "As yet there's no proof of Church's Thesis, but it's universally accepted that it's true."}, {"start": "00:01:45", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "In general \"computable\" is taken to mean \"computable by some TM\"."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:57", "is_worked_example": false, "text": "If you're curious about the existence of uncomputable functions, please see the optional video at the end of this lecture."}, {"start": "00:01:57", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "Okay, we've decided that Turing Machines can model any realizable computation."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:11", "is_worked_example": false, "text": "In other words for every computation we want to perform, there's a (different) Turing Machine that will do the job."}, {"start": "00:02:11", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "But how does this help us design a general-purpose computer?"}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:21", "is_worked_example": false, "text": "Or are there some computations that will require a special-purpose machine no matter what?"}, {"start": "00:02:21", "is_lecture": true, "end": "00:02:25", "is_worked_example": false, "text": "What we'd like to find is a universal function U:"}, {"start": "00:02:25", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "it would take two arguments, k and j, and then compute the result of running T_k on input j."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:39", "is_worked_example": false, "text": "Is U computable, i.e., is there a universal Turing Machine T_U?"}, {"start": "00:02:39", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "If so, then instead of many ad-hoc TMs, we could just use T_U to compute the results for any computable function. .249 Surprise!  U is computable and T_U exists."}, {"start": "00:02:55", "is_lecture": true, "end": "00:03:00", "is_worked_example": false, "text": "If fact there are infinitely many universal TMs, some quite simple."}, {"start": "00:03:00", "is_lecture": true, "end": "00:03:06", "is_worked_example": false, "text": "The smallest known universal TM has 4 states and uses 6 tape symbols."}, {"start": "00:03:06", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "A universal machine is capable of performing any computation that can be performed by any TM!"}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:16", "is_worked_example": false, "text": "What's going on here?"}, {"start": "00:03:16", "is_lecture": true, "end": "00:03:24", "is_worked_example": false, "text": "k encodes a \"program\" -- a description of some arbitrary TM that performs a particular computation."}, {"start": "00:03:24", "is_lecture": true, "end": "00:03:29", "is_worked_example": false, "text": "j encodes the input data on which to perform that computation."}, {"start": "00:03:29", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "T_U \"interprets\" the program, emulating the steps T_k will take to process the input and write out the answer."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "The notion of interpreting a coded representation of a computation is a key idea and forms the basis for our stored program computer."}, {"start": "00:03:49", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "The Universal Turing Machine is the paradigm for modern general-purpose computers."}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "Given an ISA we want to know if it's equivalent to a universal Turing Machine."}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:08", "is_worked_example": false, "text": "If so, it can emulate every other TM and hence compute any computable function."}, {"start": "00:04:08", "is_lecture": true, "end": "00:04:12", "is_worked_example": false, "text": "How do we show our computer is Turing Universal?"}, {"start": "00:04:12", "is_lecture": true, "end": "00:04:17", "is_worked_example": false, "text": "Simply demonstrate that it can emulate some known Universal Turing Machine."}, {"start": "00:04:17", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "The finite memory on actual computers will mean we can only emulate UTM operations on inputs up to a certain size"}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:33", "is_worked_example": false, "text": "but within this limitation we can show our computer can perform any computation that fits into memory."}, {"start": "00:04:33", "is_lecture": true, "end": "00:04:37", "is_worked_example": false, "text": "As it turns out this is not a high bar:"}, {"start": "00:04:37", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "so long as the ISA has conditional branches and some simple arithmetic, it will be Turing Universal."}, {"start": "00:04:44", "is_lecture": true, "end": "00:04:51", "is_worked_example": false, "text": "This notion of encoding a program in a way that allows it to be data to some other program is a key idea in computer science."}, {"start": "00:04:51", "is_lecture": true, "end": "00:05:06", "is_worked_example": false, "text": "We often translate a program Px written to run on some abstract high-level machine (eg, a program in C or Java) into, say, an assembly language program Py that can be interpreted by our CPU."}, {"start": "00:05:06", "is_lecture": true, "end": "00:05:09", "is_worked_example": false, "text": "This translation is called compilation."}, {"start": "00:05:09", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "Much of software engineering is based on the idea of taking a program and using it as as component in some larger program."}, {"start": "00:05:17", "is_lecture": true, "end": "00:05:32", "is_worked_example": false, "text": "Given a strategy for compiling programs, that opens the door to designing new programming languages that let us express our desired computation using data structures and operations particularly suited to the task at hand."}, {"start": "00:05:32", "is_lecture": true, "end": "00:05:38", "is_worked_example": false, "text": "So what have learned from the mathematicians' work on models of computation?"}, {"start": "00:05:38", "is_lecture": true, "end": "00:05:48", "is_worked_example": false, "text": "Well, it's nice to know that the computing engine we're planning to build will be able to perform any computation that can be performed on any realizable machine."}, {"start": "00:05:48", "is_lecture": true, "end": "00:05:56", "is_worked_example": false, "text": "And the development of the universal Turing Machine model paved the way for modern stored-program computers."}, {"start": "00:05:56", "is_lecture": true, "end": "00:06:01", "is_worked_example": false, "text": "The bottom line: we're good to go with the Beta ISA!"}]}, "C06S01B07-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c6/c6s1/7?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c6s1v7", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:09", "is_worked_example": false, "text": "The syntax tree is a useful intermediate representation (IR) that is independent of both the source language and the target ISA."}, {"start": "00:00:09", "is_lecture": true, "end": "00:00:17", "is_worked_example": false, "text": "It contains information about the sequencing and grouping of operations that isn't apparent in individual machine language instructions."}, {"start": "00:00:17", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "And it allows frontends for different source languages to share a common backend targeting a specific ISA."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:29", "is_worked_example": false, "text": "As we'll see, the backend processing can be split into two sub-phases."}, {"start": "00:00:29", "is_lecture": true, "end": "00:00:35", "is_worked_example": false, "text": "The first performs machine-independent optimizations on the IR."}, {"start": "00:00:35", "is_lecture": true, "end": "00:00:45", "is_worked_example": false, "text": "The optimized IR is then translated by the code generation phase into sequences of instructions for the target ISA."}, {"start": "00:00:45", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "A common IR is to reorganize the syntax tree into what's called a control flow graph (CFG)."}, {"start": "00:00:53", "is_lecture": true, "end": "00:00:59", "is_worked_example": false, "text": "Each node in the graph is a sequence of assignment and expression evaluations that ends with a branch."}, {"start": "00:00:59", "is_lecture": true, "end": "00:01:06", "is_worked_example": false, "text": "The nodes are called \"basic blocks\" and represent sequences of operations that are executed as a unit."}, {"start": "00:01:06", "is_lecture": true, "end": "00:01:15", "is_worked_example": false, "text": "Once the first operation in a basic block is performed, the remaining operations will also be performed without any other intervening operations."}, {"start": "00:01:15", "is_lecture": true, "end": "00:01:32", "is_worked_example": false, "text": "This knowledge lets us consider many optimizations, e.g., temporarily storing variable values in registers, that would be complicated if there was the possibility that other operations outside the block might also need to access the variable values while we were in the middle of this block."}, {"start": "00:01:32", "is_lecture": true, "end": "00:01:39", "is_worked_example": false, "text": "The edges of the graph indicate the branches that take us to another basic block."}, {"start": "00:01:39", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "For example, here's the CFG for GCD."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:54", "is_worked_example": false, "text": "If a basic block ends with a conditional branch, there are two edges, labeled \"T\" and \"F\" leaving the block that indicate the next block to execute depending on the outcome of the test."}, {"start": "00:01:54", "is_lecture": true, "end": "00:02:03", "is_worked_example": false, "text": "Other blocks have only a single departing arrow, indicating that the block always transfers control to the block indicated by the arrow."}, {"start": "00:02:03", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "Note that if we can arrive at a block from only a single predecessor block, then any knowledge we have about operations and variables from the predecessor block can be carried over to the destination block."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:32", "is_worked_example": false, "text": "For example, if the \"if (x > y)\" block has generated code to load the values of x and y into registers, both destination blocks can use that information and use the appropriate registers without having to generate their own LDs."}, {"start": "00:02:32", "is_lecture": true, "end": "00:02:38", "is_worked_example": false, "text": "But if a block has multiple predecessors, such optimizations are more constrained."}, {"start": "00:02:38", "is_lecture": true, "end": "00:02:42", "is_worked_example": false, "text": "We can only use knowledge that is common to *all* the predecessor blocks."}, {"start": "00:02:42", "is_lecture": true, "end": "00:02:48", "is_worked_example": false, "text": "The CFG looks a lot like the state transition diagram for a high-level FSM!"}, {"start": "00:02:48", "is_lecture": true, "end": "00:02:55", "is_worked_example": false, "text": "We'll optimize the IR by performing multiple passes over the CFG."}, {"start": "00:02:55", "is_lecture": true, "end": "00:03:00", "is_worked_example": false, "text": "Each pass performs a specific, simple optimization."}, {"start": "00:03:00", "is_lecture": true, "end": "00:03:08", "is_worked_example": false, "text": "We'll repeatedly apply the simple optimizations in multiple passes, until we can't find any further optimizations to perform."}, {"start": "00:03:08", "is_lecture": true, "end": "00:03:14", "is_worked_example": false, "text": "Collectively, the simple optimizations can combine to achieve very complex optimizations."}, {"start": "00:03:14", "is_lecture": true, "end": "00:03:17", "is_worked_example": false, "text": "Here are some example optimizations:"}, {"start": "00:03:17", "is_lecture": true, "end": "00:03:23", "is_worked_example": false, "text": "We can eliminate assignments to variables that are never used and basic blocks that are never reached."}, {"start": "00:03:23", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "This is called \"dead code elimination\"."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:35", "is_worked_example": false, "text": "In constant propagation, we identify variables that have a constant value and substitute that constant in place of references to the variable."}, {"start": "00:03:35", "is_lecture": true, "end": "00:03:39", "is_worked_example": false, "text": "We can compute the value of expressions that have constant operands."}, {"start": "00:03:39", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "This is called \"constant folding\"."}, {"start": "00:03:41", "is_lecture": true, "end": "00:03:49", "is_worked_example": false, "text": "To illustrate how these optimizations work, consider this slightly silly source program and its CFG."}, {"start": "00:03:49", "is_lecture": true, "end": "00:04:00", "is_worked_example": false, "text": "Note that we've broken down complicated expressions into simple binary operations, using temporary variable names (e.g, \"_t1\") to name the intermediate results."}, {"start": "00:04:00", "is_lecture": true, "end": "00:04:02", "is_worked_example": false, "text": "Let's get started!"}, {"start": "00:04:02", "is_lecture": true, "end": "00:04:13", "is_worked_example": false, "text": "The dead code elimination pass can remove the assignment to Z in the first basic block since Z is reassigned in subsequent blocks and the intervening code makes no reference to Z."}, {"start": "00:04:13", "is_lecture": true, "end": "00:04:17", "is_worked_example": false, "text": "Next we look for variables with constant values."}, {"start": "00:04:17", "is_lecture": true, "end": "00:04:26", "is_worked_example": false, "text": "Here we find that X is assigned the value of 3 and is never re-assigned, so we can replace all references to X with the constant 3."}, {"start": "00:04:26", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "Now perform constant folding [CLICK], evaluating any constant expressions."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:38", "is_worked_example": false, "text": "Here's the updated CFG, ready for another round of optimizations."}, {"start": "00:04:38", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "First dead code elimination."}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:43", "is_worked_example": false, "text": "Then constant propagation."}, {"start": "00:04:43", "is_lecture": true, "end": "00:04:46", "is_worked_example": false, "text": "And, finally, constant folding."}, {"start": "00:04:46", "is_lecture": true, "end": "00:04:52", "is_worked_example": false, "text": "So after two rounds of these simple operations, we've thinned out a number of assignments."}, {"start": "00:04:52", "is_lecture": true, "end": "00:04:54", "is_worked_example": false, "text": "On to round three!"}, {"start": "00:04:54", "is_lecture": true, "end": "00:04:56", "is_worked_example": false, "text": "Dead code elimination."}, {"start": "00:04:56", "is_lecture": true, "end": "00:05:07", "is_worked_example": false, "text": "And here we can determine the outcome of a conditional branch, eliminating entire basic blocks from the IR, either because they're now empty or because they can no longer be reached."}, {"start": "00:05:07", "is_lecture": true, "end": "00:05:12", "is_worked_example": false, "text": "Wow, the IR is now considerably smaller."}, {"start": "00:05:12", "is_lecture": true, "end": "00:05:17", "is_worked_example": false, "text": "Next is another application of constant propagation."}, {"start": "00:05:17", "is_lecture": true, "end": "00:05:19", "is_worked_example": false, "text": "And then constant folding."}, {"start": "00:05:19", "is_lecture": true, "end": "00:05:23", "is_worked_example": false, "text": "Followed by more dead code elimination."}, {"start": "00:05:23", "is_lecture": true, "end": "00:05:29", "is_worked_example": false, "text": "The passes continue until we discover there are no further optimizations to perform, so we're done!"}, {"start": "00:05:29", "is_lecture": true, "end": "00:05:39", "is_worked_example": false, "text": "Repeated applications of these simple transformations have transformed the original program into an equivalent program that computes the same final value for Z."}, {"start": "00:05:39", "is_lecture": true, "end": "00:05:50", "is_worked_example": false, "text": "We can do more optimizations by adding passes: eliminating redundant computation of common subexpressions, moving loop-independent calculations out of loops,"}, {"start": "00:05:50", "is_lecture": true, "end": "00:06:00", "is_worked_example": false, "text": "unrolling short loops to perform the effect of, say, two iterations in a single loop execution, saving some of the cost of increment and test instructions."}, {"start": "00:06:00", "is_lecture": true, "end": "00:06:08", "is_worked_example": false, "text": "Optimizing compilers have a sophisticated set of optimizations they employ to make smaller and more efficient code."}, {"start": "00:06:08", "is_lecture": true, "end": "00:06:11", "is_worked_example": false, "text": "Okay, we're done with optimizations."}, {"start": "00:06:11", "is_lecture": true, "end": "00:06:14", "is_worked_example": false, "text": "Now it's time to generate instructions for the target ISA."}, {"start": "00:06:14", "is_lecture": true, "end": "00:06:19", "is_worked_example": false, "text": "First the code generator assigns each variable a dedicated register."}, {"start": "00:06:19", "is_lecture": true, "end": "00:06:26", "is_worked_example": false, "text": "If we have more variables than registers, some variables are stored in memory and we'll use LD and ST to access them as needed."}, {"start": "00:06:26", "is_lecture": true, "end": "00:06:31", "is_worked_example": false, "text": "But frequently-used variables will almost certainly live as much as possible in registers."}, {"start": "00:06:31", "is_lecture": true, "end": "00:06:38", "is_worked_example": false, "text": "Use our templates from before to translate each assignment and operation into one or more instructions."}, {"start": "00:06:38", "is_lecture": true, "end": "00:06:43", "is_worked_example": false, "text": "The emit the code for each block, adding the appropriate labels and branches."}, {"start": "00:06:43", "is_lecture": true, "end": "00:06:49", "is_worked_example": false, "text": "Reorder the basic block code to eliminate unconditional branches wherever possible."}, {"start": "00:06:49", "is_lecture": true, "end": "00:06:54", "is_worked_example": false, "text": "And finally perform any target-specific peephole optimizations."}, {"start": "00:06:54", "is_lecture": true, "end": "00:07:02", "is_worked_example": false, "text": "Here's the original CFG for the GCD code, along with the slightly optimized CFG."}, {"start": "00:07:02", "is_lecture": true, "end": "00:07:09", "is_worked_example": false, "text": "GCD isn't as trivial as the previous example, so we've only been able to do a bit of constant propagation and constant folding."}, {"start": "00:07:09", "is_lecture": true, "end": "00:07:19", "is_worked_example": false, "text": "Note that we can't propagate knowledge about variable values from the top basic block to the following \"if\" block since the \"if\" block has multiple predecessors."}, {"start": "00:07:19", "is_lecture": true, "end": "00:07:25", "is_worked_example": false, "text": "Here's how the code generator will process the optimized CFG."}, {"start": "00:07:25", "is_lecture": true, "end": "00:07:29", "is_worked_example": false, "text": "First, it dedicates registers to hold the values for x and y."}, {"start": "00:07:29", "is_lecture": true, "end": "00:07:32", "is_worked_example": false, "text": "Then, it emits the code for each of the basic blocks."}, {"start": "00:07:32", "is_lecture": true, "end": "00:07:38", "is_worked_example": false, "text": "Next, reorganize the order of the basic blocks to eliminate unconditional branches wherever possible."}, {"start": "00:07:38", "is_lecture": true, "end": "00:07:42", "is_worked_example": false, "text": "The resulting code is pretty good."}, {"start": "00:07:42", "is_lecture": true, "end": "00:07:47", "is_worked_example": false, "text": "There no obvious changes that a human programmer might make to make the code faster or smaller."}, {"start": "00:07:47", "is_lecture": true, "end": "00:07:48", "is_worked_example": false, "text": "Good job, compiler!"}, {"start": "00:07:48", "is_lecture": true, "end": "00:07:56", "is_worked_example": false, "text": "Here are all the compilation steps shown in order, along with their input and output data structures."}, {"start": "00:07:56", "is_lecture": true, "end": "00:08:01", "is_worked_example": false, "text": "Collectively they transform the original source code into high-quality assembly code."}, {"start": "00:08:01", "is_lecture": true, "end": "00:08:09", "is_worked_example": false, "text": "The patient application of optimization passes often produces code that's more efficient than writing assembly language by hand."}, {"start": "00:08:09", "is_lecture": true, "end": "00:08:22", "is_worked_example": false, "text": "Nowadays, programmers are able to focus on getting the source code to achieve the desired functionality and leave the details of translation to instructions in the hands of the compiler."}]}, "C04S03B01-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c4/c4s1/1?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c4s1v1", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:09", "is_worked_example": false, "text": "In the previous lecture we developed the instruction set architecture for the Beta, the computer system we'll be building throughout this part of the course."}, {"start": "00:00:09", "is_lecture": true, "end": "00:00:12", "is_worked_example": false, "text": "The Beta incorporates two types of storage or memory."}, {"start": "00:00:12", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "In the CPU datapath there are 32 general-purpose registers, which can be read to supply source operands for the ALU or written with the ALU result."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:33", "is_worked_example": false, "text": "In the CPU's control logic there is a special-purpose register called the program counter, which contains the address of the memory location holding the next instruction to be executed."}, {"start": "00:00:33", "is_lecture": true, "end": "00:00:45", "is_worked_example": false, "text": "The datapath and control logic are connected to a large main memory with a maximum capacity of 2^32 bytes, organized as 2^30 32-bit words."}, {"start": "00:00:45", "is_lecture": true, "end": "00:00:49", "is_worked_example": false, "text": "This memory holds both data and instructions."}, {"start": "00:00:49", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "Beta instructions are 32-bit values comprised of various fields."}, {"start": "00:00:53", "is_lecture": true, "end": "00:00:58", "is_worked_example": false, "text": "The 6-bit OPCODE field specifies the operation to be performed."}, {"start": "00:00:58", "is_lecture": true, "end": "00:01:07", "is_worked_example": false, "text": "The 5-bit Ra, Rb, and Rc fields contain register numbers, specifying one of the 32 general-purpose registers."}, {"start": "00:01:07", "is_lecture": true, "end": "00:01:18", "is_worked_example": false, "text": "There are two instruction formats: one specifying an opcode and three registers, the other specifying an opcode, two registers, and a 16-bit signed constant."}, {"start": "00:01:18", "is_lecture": true, "end": "00:01:21", "is_worked_example": false, "text": "There three classes of instructions."}, {"start": "00:01:21", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "The ALU instructions perform an arithmetic or logic operation on two operands, producing a result that is stored in the destination register."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:37", "is_worked_example": false, "text": "The operands are either two values from the general-purpose registers, or one register value and a constant."}, {"start": "00:01:37", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "The yellow highlighting indicates instructions that use the second instruction format."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:53", "is_worked_example": false, "text": "The Load/Store instructions access main memory, either loading a value from main memory into a register, or storing a register value to main memory."}, {"start": "00:01:53", "is_lecture": true, "end": "00:02:01", "is_worked_example": false, "text": "And, finally, there are branches and jumps whose execution may change the program counter and hence the address of the next instruction to be executed."}, {"start": "00:02:01", "is_lecture": true, "end": "00:02:07", "is_worked_example": false, "text": "To program the Beta we'll need to load main memory with binary-encoded instructions."}, {"start": "00:02:07", "is_lecture": true, "end": "00:02:17", "is_worked_example": false, "text": "Figuring out each encoding is clearly the job for a computer, so we'll create a simple programming language that will let us specify the opcode and operands for each instruction."}, {"start": "00:02:17", "is_lecture": true, "end": "00:02:24", "is_worked_example": false, "text": "So instead of writing the binary at the top of slide, we'll write assembly language statements to specify instructions in symbolic form."}, {"start": "00:02:24", "is_lecture": true, "end": "00:02:33", "is_worked_example": false, "text": "Of course we still have think about which registers to use for which values and write sequences of instructions for more complex operations."}, {"start": "00:02:33", "is_lecture": true, "end": "00:02:45", "is_worked_example": false, "text": "By using a high-level language we can move up one more level abstraction and describe the computation we want in terms of variables and mathematical operations rather than registers and ALU functions."}, {"start": "00:02:45", "is_lecture": true, "end": "00:02:51", "is_worked_example": false, "text": "In this lecture we'll describe the assembly language we'll use for programming the Beta."}, {"start": "00:02:51", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "And in the next lecture we'll figure out how to translate high-level languages, such as C, into assembly language."}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:02", "is_worked_example": false, "text": "The layer cake of abstractions gets taller yet:"}, {"start": "00:03:02", "is_lecture": true, "end": "00:03:08", "is_worked_example": false, "text": "we could write an interpreter for say, Python, in C and then write our application programs in Python."}, {"start": "00:03:08", "is_lecture": true, "end": "00:03:22", "is_worked_example": false, "text": "Nowadays, programmers often choose the programming language that's most suitable for expressing their computations, then, after perhaps many layers of translation, come up with a sequence of instructions that the Beta can actually execute."}, {"start": "00:03:22", "is_lecture": true, "end": "00:03:34", "is_worked_example": false, "text": "Okay, back to assembly language, which we'll use to shield ourselves from the bit-level representations of instructions and from having to know the exact location of variables and instructions in memory."}, {"start": "00:03:34", "is_lecture": true, "end": "00:03:45", "is_worked_example": false, "text": "A program called the \"assembler\" reads a text file containing the assembly language program and produces an array of 32-bit words that can be used to initialize main memory."}, {"start": "00:03:45", "is_lecture": true, "end": "00:03:52", "is_worked_example": false, "text": "We'll learn the UASM assembly language, which is built into BSim, our simulator for the Beta ISA."}, {"start": "00:03:52", "is_lecture": true, "end": "00:03:56", "is_worked_example": false, "text": "UASM is really just a fancy calculator!"}, {"start": "00:03:56", "is_lecture": true, "end": "00:04:07", "is_worked_example": false, "text": "It reads arithmetic expressions and evaluates them to produce 8-bit values, which it then adds sequentially to the array of bytes which will eventually be loaded into the Beta's memory."}, {"start": "00:04:07", "is_lecture": true, "end": "00:04:14", "is_worked_example": false, "text": "UASM supports several useful language features that make it easier to write assembly language programs."}, {"start": "00:04:14", "is_lecture": true, "end": "00:04:19", "is_worked_example": false, "text": "Symbols and labels let us give names to particular values and addresses."}, {"start": "00:04:19", "is_lecture": true, "end": "00:04:29", "is_worked_example": false, "text": "And macros let us create shorthand notations for sequences of expressions that, when evaluated, will generate the binary representations for instructions and data."}, {"start": "00:04:29", "is_lecture": true, "end": "00:04:32", "is_worked_example": false, "text": "Here's an example UASM source file."}, {"start": "00:04:32", "is_lecture": true, "end": "00:04:41", "is_worked_example": false, "text": "Typically we write one UASM statement on each line and can use spaces, tabs, and newlines to make the source as readable as possible."}, {"start": "00:04:41", "is_lecture": true, "end": "00:04:44", "is_worked_example": false, "text": "We've added some color coding to help in our explanation."}, {"start": "00:04:44", "is_lecture": true, "end": "00:04:49", "is_worked_example": false, "text": "Comments (shown in green) allow us to add text annotations to the program."}, {"start": "00:04:49", "is_lecture": true, "end": "00:04:52", "is_worked_example": false, "text": "Good comments will help remind you how your program works."}, {"start": "00:04:52", "is_lecture": true, "end": "00:04:59", "is_worked_example": false, "text": "You really don't want to have figure out from scratch what a section of code does each time you need to modify or debug it!"}, {"start": "00:04:59", "is_lecture": true, "end": "00:05:02", "is_worked_example": false, "text": "There are two ways to add comments to the code."}, {"start": "00:05:02", "is_lecture": true, "end": "00:05:07", "is_worked_example": false, "text": "\"//\" starts a comment, which then occupies the rest of the source line."}, {"start": "00:05:07", "is_lecture": true, "end": "00:05:16", "is_worked_example": false, "text": "Any characters after \"//\" are ignored by the assembler, which will start processing statements again at the start of the next line in the source file."}, {"start": "00:05:16", "is_lecture": true, "end": "00:05:26", "is_worked_example": false, "text": "You can also enclose comment text using the delimiters \"/*\" and \"*/\" and the assembler will ignore everything in-between."}, {"start": "00:05:26", "is_lecture": true, "end": "00:05:38", "is_worked_example": false, "text": "Using this second type of comment, you can \"comment-out\" many lines of code by placing \"/*\" at the start and, many lines later, end the comment section with a \"*/\"."}, {"start": "00:05:38", "is_lecture": true, "end": "00:05:42", "is_worked_example": false, "text": "Symbols (shown in red) are symbolic names for constant values."}, {"start": "00:05:42", "is_lecture": true, "end": "00:05:52", "is_worked_example": false, "text": "Symbols make the code easier to understand, e.g., we can use N as the name for an initial value for some computation, in this case the value 12."}, {"start": "00:05:52", "is_lecture": true, "end": "00:05:58", "is_worked_example": false, "text": "Subsequent statements can refer to this value using the symbol N instead of entering the value 12 directly."}, {"start": "00:05:58", "is_lecture": true, "end": "00:06:03", "is_worked_example": false, "text": "When reading the program, we'll know that N means this particular initial value."}, {"start": "00:06:03", "is_lecture": true, "end": "00:06:13", "is_worked_example": false, "text": "So if later we want to change the initial value, we only have to change the definition of the symbol N rather than find all the 12's in our program and change them."}, {"start": "00:06:13", "is_lecture": true, "end": "00:06:22", "is_worked_example": false, "text": "In fact some of the other appearances of 12 might not refer to this initial value and so to be sure we only changed the ones that did,"}, {"start": "00:06:22", "is_lecture": true, "end": "00:06:27", "is_worked_example": false, "text": "we'd have to read and understand the whole program to make sure we only edited the right 12's."}, {"start": "00:06:27", "is_lecture": true, "end": "00:06:29", "is_worked_example": false, "text": "You can imagine how error-prone that might be!"}, {"start": "00:06:29", "is_lecture": true, "end": "00:06:33", "is_worked_example": false, "text": "So using symbols is a practice you want to follow!"}, {"start": "00:06:33", "is_lecture": true, "end": "00:06:37", "is_worked_example": false, "text": "Note that all the register names are shown in red."}, {"start": "00:06:37", "is_lecture": true, "end": "00:06:43", "is_worked_example": false, "text": "We'll define the symbols R0 through R31 to have the values 0 through 31."}, {"start": "00:06:43", "is_lecture": true, "end": "00:06:56", "is_worked_example": false, "text": "Then we'll use those symbols to help us understand which instruction operands are intended to be registers, e.g., by writing R1, and which operands are numeric values, e.g., by writing the number 1."}, {"start": "00:06:56", "is_lecture": true, "end": "00:07:01", "is_worked_example": false, "text": "We could just use numbers everywhere, but the code would be much harder to read and understand."}, {"start": "00:07:01", "is_lecture": true, "end": "00:07:08", "is_worked_example": false, "text": "Labels (shown in yellow) are symbols whose value are the address of a particular location in the program."}, {"start": "00:07:08", "is_lecture": true, "end": "00:07:13", "is_worked_example": false, "text": "Here, the label \"loop\" will be our name for the location of the MUL instruction in memory."}, {"start": "00:07:13", "is_lecture": true, "end": "00:07:19", "is_worked_example": false, "text": "In the BNE at the end of the code, we use the label \"loop\" to specify the MUL instruction as the branch target."}, {"start": "00:07:19", "is_lecture": true, "end": "00:07:25", "is_worked_example": false, "text": "So if R1 is non-zero, we want to branch back to the MUL instruction and start another iteration."}, {"start": "00:07:25", "is_lecture": true, "end": "00:07:33", "is_worked_example": false, "text": "We'll use indentation for most UASM statements to make it easy to spot the labels defined by the program."}, {"start": "00:07:33", "is_lecture": true, "end": "00:07:40", "is_worked_example": false, "text": "Indentation isn't required, it's just another habit assembly language programmers use to keep their programs readable."}, {"start": "00:07:40", "is_lecture": true, "end": "00:07:47", "is_worked_example": false, "text": "We use macro invocations (shown in blue) when we want to write Beta instructions."}, {"start": "00:07:47", "is_lecture": true, "end": "00:07:55", "is_worked_example": false, "text": "When the assembler encounters a macro, it \"expands\" the macro, replacing it with a string of text provided by in the macro's definition."}, {"start": "00:07:55", "is_lecture": true, "end": "00:08:03", "is_worked_example": false, "text": "During expansion, the provided arguments are textually inserted into the expanded text at locations specified in the macro definition."}, {"start": "00:08:03", "is_lecture": true, "end": "00:08:08", "is_worked_example": false, "text": "Think of a macro as shorthand for a longer text string we could have typed in."}, {"start": "00:08:08", "is_lecture": true, "end": "00:08:12", "is_worked_example": false, "text": "We'll show how all this works in the next video segment."}]}, "C03S01B12-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c3/c3s1/12?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c3s1v12", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:06", "is_worked_example": false, "text": "Finally, let's discuss the third class of instructions that let us change the program counter."}, {"start": "00:00:06", "is_lecture": true, "end": "00:00:19", "is_worked_example": false, "text": "Up until now, the program counter has simply been incremented by 4 at the end of each instruction, so that the next instruction comes from the memory location that immediately follows the location that held the current instruction,"}, {"start": "00:00:19", "is_lecture": true, "end": "00:00:23", "is_worked_example": false, "text": "i.e., the Beta has been executing instructions sequentially from memory."}, {"start": "00:00:23", "is_lecture": true, "end": "00:00:37", "is_worked_example": false, "text": "But in many programs, such as in factorial, we need to disrupt sequential execution, either to loop back to repeat some earlier instruction, or to skip over instructions because of some data dependency."}, {"start": "00:00:37", "is_lecture": true, "end": "00:00:43", "is_worked_example": false, "text": "We need a way to change the program counter based on data values generated by the program's execution."}, {"start": "00:00:43", "is_lecture": true, "end": "00:00:53", "is_worked_example": false, "text": "In the factorial example, as long as b is not equal to 0, we need to keep executing the instructions that calculate a*b and decrement b."}, {"start": "00:00:53", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "So we need instructions to test the value of b after it's been decremented and if it's non-zero, change the PC to repeat the loop one more time."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:12", "is_worked_example": false, "text": "Changing the PC depending on some condition is implemented by a branch instruction, and the operation is referred to as a \"conditional branch\"."}, {"start": "00:01:12", "is_lecture": true, "end": "00:01:20", "is_worked_example": false, "text": "When the branch is taken, the PC is changed and execution is restarted at the new location, which is called the branch target."}, {"start": "00:01:20", "is_lecture": true, "end": "00:01:30", "is_worked_example": false, "text": "If the branch is not taken, the PC is incremented by 4 and execution continues with the instruction following the branch."}, {"start": "00:01:30", "is_lecture": true, "end": "00:01:36", "is_worked_example": false, "text": "As the name implies, a branch instruction represents a potential fork in the execution sequence."}, {"start": "00:01:36", "is_lecture": true, "end": "00:01:44", "is_worked_example": false, "text": "We'll use branches to implement many different types of control structures: loops, conditionals, procedure calls, etc."}, {"start": "00:01:44", "is_lecture": true, "end": "00:01:50", "is_worked_example": false, "text": "Branches instructions also use the instruction format with the 16-bit signed constant."}, {"start": "00:01:50", "is_lecture": true, "end": "00:01:56", "is_worked_example": false, "text": "The operation of the branch instructions are a bit complicated, so let's walk through their operation step-by-step."}, {"start": "00:01:56", "is_lecture": true, "end": "00:03:41", "is_worked_example": false, "text": "Let's start by looking at the operation of the BEQ instruction."}, {"start": "00:03:41", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "First the usual PC+4 calculation is performed, giving us the address of the instruction following the BEQ."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:15", "is_worked_example": false, "text": "This value is written to the \"rc\" register whether or not the branch is taken."}, {"start": "00:02:15", "is_lecture": true, "end": "00:02:22", "is_worked_example": false, "text": "This feature of branches is pretty handy and we'll use it to implement procedure calls a couple of lectures from now."}, {"start": "00:02:22", "is_lecture": true, "end": "00:02:30", "is_worked_example": false, "text": "Note that if we don't need to remember the PC+4 value, we can specify R31 as the \"rc\" register."}, {"start": "00:02:30", "is_lecture": true, "end": "00:02:36", "is_worked_example": false, "text": "Next, BEQ tests the value of the \"ra\" register to see if it's equal to 0."}, {"start": "00:02:36", "is_lecture": true, "end": "00:02:44", "is_worked_example": false, "text": "If it is equal to 0, the branch is taken and the PC is incremented by the amount specified in the constant field of the instruction."}, {"start": "00:02:44", "is_lecture": true, "end": "00:02:58", "is_worked_example": false, "text": "Actually the constant, called an offset since we're using it to offset the PC, is treated as a word offset and is multiplied by 4 to convert it a byte offset since the PC uses byte addressing."}, {"start": "00:02:58", "is_lecture": true, "end": "00:03:09", "is_worked_example": false, "text": "If the contents of the \"ra\" register is not equal to 0, the PC is incremented by 4 and execution continues with the instruction following the BEQ."}, {"start": "00:03:09", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "Let me say a few more words about the offset."}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:17", "is_worked_example": false, "text": "The branches are using what's referred to as \"pc-relative addressing\"."}, {"start": "00:03:17", "is_lecture": true, "end": "00:03:27", "is_worked_example": false, "text": "That means the address of the branch target is specified relative to the address of the branch, or, actually, relative to the address of the instruction following the branch."}, {"start": "00:03:27", "is_lecture": true, "end": "00:03:36", "is_worked_example": false, "text": "So an offset of 0 would refer to the instruction following the branch and an offset of -1 would refer to the branch itself."}, {"start": "00:03:36", "is_lecture": true, "end": "00:03:50", "is_worked_example": false, "text": "Negative offsets are called \"backwards branches\" and are usually seen at branches used at the end of loops, where the looping condition is tested and we branch backwards to the beginning of the loop if another iteration is called for."}, {"start": "00:03:50", "is_lecture": true, "end": "00:04:01", "is_worked_example": false, "text": "Positive offsets are called \"forward branches\" and are usually seen in code for \"if statements\", where we might skip over some part of the program if a condition is not true."}, {"start": "00:04:01", "is_lecture": true, "end": "00:04:08", "is_worked_example": false, "text": "We can use BEQ to implement a so-called unconditional branch, i.e., a branch that is always taken."}, {"start": "00:04:08", "is_lecture": true, "end": "00:04:16", "is_worked_example": false, "text": "If we test R31 to see if it's 0, that's always true, so BEQ(R31,...) would always branch to the specified target."}, {"start": "00:04:16", "is_lecture": true, "end": "00:04:27", "is_worked_example": false, "text": "There's also a BNE instruction, identical to BEQ in its operation except the sense of the condition is reversed: the branch is taken if the value of register \"ra\" is non-zero."}, {"start": "00:04:27", "is_lecture": true, "end": "00:04:34", "is_worked_example": false, "text": "It might seem that only testing for zero/non-zero doesn't let us do everything we might want to do."}, {"start": "00:04:34", "is_lecture": true, "end": "00:04:40", "is_worked_example": false, "text": "For example, how would we branch if \"a < b\"?"}, {"start": "00:04:40", "is_lecture": true, "end": "00:04:49", "is_worked_example": false, "text": "That's where the compare instructions come in -- they do more complicated comparisons, producing a non-zero value if the comparison is true and a zero value if the comparison is false."}, {"start": "00:04:49", "is_lecture": true, "end": "00:04:55", "is_worked_example": false, "text": "Then we can use BEQ and BNE to test the result of the comparison and branch appropriately."}, {"start": "00:04:55", "is_lecture": true, "end": "00:05:04", "is_worked_example": false, "text": "At long last we're finally in a position to write Beta code to compute factorial using the iterative algorithm shown in C code on the left."}, {"start": "00:05:04", "is_lecture": true, "end": "00:05:10", "is_worked_example": false, "text": "In the Beta code, the loop starts at the second instruction and is marked with the \"L:\" label."}, {"start": "00:05:10", "is_lecture": true, "end": "00:05:16", "is_worked_example": false, "text": "The body of the loop consists of the required multiplication and the decrement of b."}, {"start": "00:05:16", "is_lecture": true, "end": "00:05:24", "is_worked_example": false, "text": "Then, in the fourth instruction, b is tested and, if it's non-zero, the BNE will branch back to the instruction with the label L."}, {"start": "00:05:24", "is_lecture": true, "end": "00:05:36", "is_worked_example": false, "text": "Note that in our symbolic notation for BEQ and BNE instructions we don't write the offset directly since that would be a pain to calculate and would change if we added or removed instructions from the loop."}, {"start": "00:05:36", "is_lecture": true, "end": "00:05:47", "is_worked_example": false, "text": "Instead we reference the instruction to which we want to branch, and the program that translates the symbolic code into the binary instruction fields will do the offset calculation for us."}, {"start": "00:05:47", "is_lecture": true, "end": "00:06:01", "is_worked_example": false, "text": "There's a satisfying similarity between the Beta code and the operations specified by the high-level FSM we created for computing factorial in the simple programmable datapath discussed earlier in this lecture."}, {"start": "00:06:01", "is_lecture": true, "end": "00:06:08", "is_worked_example": false, "text": "In this example, each state in the high-level FSM matches up nicely with a particular Beta instruction."}, {"start": "00:06:08", "is_lecture": true, "end": "00:06:19", "is_worked_example": false, "text": "We wouldn't expect that high degree of correspondence in general, but since our Beta datapath and the example datapath were very similar, the states and instructions match up pretty well."}]}, "C04S03B02-LEC.srt": {"url": "https://courses.edx.org/courses/course-v1:MITx+6.004.2x+3T2015/courseware/c4/c4s1/2?activate_block_id=block-v1%3AMITx%2B6.004.2x%2B3T2015%2Btype%40discussion%2Bblock%40c4s1v2", "items": [{"start": "00:00:00", "is_lecture": true, "end": "00:00:04", "is_worked_example": false, "text": "Let's follow along as the assembler processes our source file."}, {"start": "00:00:04", "is_lecture": true, "end": "00:00:09", "is_worked_example": false, "text": "The assembler maintains a symbol table that maps symbols names to their numeric values."}, {"start": "00:00:09", "is_lecture": true, "end": "00:00:14", "is_worked_example": false, "text": "Initially the symbol table is loaded with mappings for all the register symbols."}, {"start": "00:00:14", "is_lecture": true, "end": "00:00:24", "is_worked_example": false, "text": "The assembler reads the source file line-by-line, defining symbols and labels, expanding macros, or evaluating expressions to generate bytes for the output array."}, {"start": "00:00:24", "is_lecture": true, "end": "00:00:32", "is_worked_example": false, "text": "Whenever the assembler encounters a use of a symbol or label, it's replaced by the corresponding numeric value found in the symbol table."}, {"start": "00:00:32", "is_lecture": true, "end": "00:00:42", "is_worked_example": false, "text": "The first line, N = 12, defines the value of the symbol N to be 12, so the appropriate entry is made in the symbol table."}, {"start": "00:00:42", "is_lecture": true, "end": "00:00:51", "is_worked_example": false, "text": "Advancing to the next line, the assembler encounters an invocation of the ADDC macro with the arguments \"r31\", \"N\", and \"r1\"."}, {"start": "00:00:51", "is_lecture": true, "end": "00:01:02", "is_worked_example": false, "text": "As we'll see in a couple of slides, this triggers a series of nested macro expansions that eventually lead to generating a 32-bit binary value to be placed in memory location 0."}, {"start": "00:01:02", "is_lecture": true, "end": "00:01:10", "is_worked_example": false, "text": "The 32-bit value is formatted here to show the instruction fields and the destination address is shown in brackets."}, {"start": "00:01:10", "is_lecture": true, "end": "00:01:16", "is_worked_example": false, "text": "The next instruction is processed in the same way, generating a second 32-bit word."}, {"start": "00:01:16", "is_lecture": true, "end": "00:01:25", "is_worked_example": false, "text": "On the fourth line, the label loop is defined to have the value of the location in memory that's about to filled, in this case, location 8."}, {"start": "00:01:25", "is_lecture": true, "end": "00:01:34", "is_worked_example": false, "text": "So the appropriate entry is made in the symbol table and the MUL macro is expanded into the 32-bit word to be placed in location 8."}, {"start": "00:01:34", "is_lecture": true, "end": "00:01:40", "is_worked_example": false, "text": "The assembler processes the file line-by-line until it reaches the end of the file."}, {"start": "00:01:40", "is_lecture": true, "end": "00:01:43", "is_worked_example": false, "text": "Actually the assembler makes two passes through the file."}, {"start": "00:01:43", "is_lecture": true, "end": "00:01:48", "is_worked_example": false, "text": "On the first pass it loads the symbol table with the values from all the symbol and label definitions."}, {"start": "00:01:48", "is_lecture": true, "end": "00:02:04", "is_worked_example": false, "text": "Then, on the second pass, it generates the binary output. .152 The two-pass approach allows a statement to refer to symbol or label that is defined later in the file, e.g., a forward branch instruction could refer to the label for an instruction later in the program."}, {"start": "00:02:04", "is_lecture": true, "end": "00:02:10", "is_worked_example": false, "text": "As we saw in the previous slide, there's nothing magic about the register symbols."}, {"start": "00:02:10", "is_lecture": true, "end": "00:02:13", "is_worked_example": false, "text": "They are just symbolic names for the values 0 through 31."}, {"start": "00:02:13", "is_lecture": true, "end": "00:02:26", "is_worked_example": false, "text": "So when processing ADDC(r31,N,r1), UASM replaces the symbols with their values and actually expands ADDC(31,12,1)."}, {"start": "00:02:26", "is_lecture": true, "end": "00:02:28", "is_worked_example": false, "text": "UASM is very simple."}, {"start": "00:02:28", "is_lecture": true, "end": "00:02:34", "is_worked_example": false, "text": "It simply replaces symbols with their values, expands macros and evaluates expressions."}, {"start": "00:02:34", "is_lecture": true, "end": "00:02:41", "is_worked_example": false, "text": "So if you use a register symbol where a numeric value is expected, the value of the symbol is used as the numeric constant."}, {"start": "00:02:41", "is_lecture": true, "end": "00:02:43", "is_worked_example": false, "text": "Probably not what the programmer intended."}, {"start": "00:02:43", "is_lecture": true, "end": "00:02:56", "is_worked_example": false, "text": "Similarly, if you use a symbol or expression where a register number is expected, the low-order 5 bits of the value is used as the register number, in this example, as the Rb register number."}, {"start": "00:02:56", "is_lecture": true, "end": "00:02:59", "is_worked_example": false, "text": "Again probably not what the programmer intended."}, {"start": "00:02:59", "is_lecture": true, "end": "00:03:13", "is_worked_example": false, "text": "The moral of the story is that when writing UASM assembly language programs, you have to keep your wits about you and recognize that the interpretation of an operand is determined by the opcode macro, not by the way you wrote the operand."}, {"start": "00:03:13", "is_lecture": true, "end": "00:03:26", "is_worked_example": false, "text": "Recall from Lecture 9 that branch instructions use the 16-bit constant field of the instruction to encode the address of the branch target as a word offset from the location of the branch instruction."}, {"start": "00:03:26", "is_lecture": true, "end": "00:03:37", "is_worked_example": false, "text": "Well, actually the offset is calculated from the instruction immediately following the branch, so an offset of -1 would refer to the branch itself."}, {"start": "00:03:37", "is_lecture": true, "end": "00:03:47", "is_worked_example": false, "text": "The calculation of the offset is a bit tedious to do by hand and would, of course, change if we added or removed instructions between the branch instruction and branch target."}, {"start": "00:03:47", "is_lecture": true, "end": "00:03:57", "is_worked_example": false, "text": "Happily macros for the branch instructions incorporate the necessary formula to compute the offset from the address of the branch and the address of the branch target."}, {"start": "00:03:57", "is_lecture": true, "end": "00:04:05", "is_worked_example": false, "text": "So we just specify the address of the branch target, usually with a label, and let UASM do the heavy lifting."}, {"start": "00:04:05", "is_lecture": true, "end": "00:04:15", "is_worked_example": false, "text": "Here we see that BNE branches backwards by three instructions (remember to count from the instruction following the branch) so the offset is -3."}, {"start": "00:04:15", "is_lecture": true, "end": "00:04:24", "is_worked_example": false, "text": "The 16-bit two's complement representation of -3 is the value placed in the constant field of the BNE instruction."}]}}
