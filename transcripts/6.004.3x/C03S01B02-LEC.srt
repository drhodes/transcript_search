0
00:00:00,000 --> 00:00:07,000
Let's start by redrawing and simplifying the Beta data path so that it will be easier to reason about when we add pipelining.

1
00:00:07,000 --> 00:00:15,000
The first simplification is to focus on sequential execution and so leave out the branch addressing and PC mux logic.

2
00:00:15,000 --> 00:00:19,000
Our simplified Beta always executes the next instruction from PC+4.

3
00:00:19,000 --> 00:00:25,000
We'll add back the branch and jump logic when we discuss control hazards.

4
00:00:25,000 --> 00:00:36,000
The second simplification is to have the register file appear twice in the diagram so that we can tease apart the read and write operations that occur at different stages of instruction execution.

5
00:00:36,000 --> 00:00:44,000
The top Register File shows the combinational read ports, used to when reading the register operands in the RF stage.

6
00:00:44,000 --> 00:00:52,000
The bottom Register File shows the clocked write port, used to write the result into the destination register at the end of the WB stage.

7
00:00:52,000 --> 00:01:00,000
Physically, there's only one set of 32 registers, we've just drawn the read and write circuity as separate components in the diagram.

8
00:01:00,000 --> 00:01:09,000
If we add pipeline registers to the simplified diagram, we see that execution proceeds through the five stages from top to bottom.

9
00:01:09,000 --> 00:01:21,000
If we consider execution of instruction sequences with no data hazards, information is flowing down the pipeline and the pipeline will correctly overlap the execution of all the instructions in the pipeline.

10
00:01:21,000 --> 00:01:26,000
The diagram shows the components needed to implement each of the five stages.

11
00:01:26,000 --> 00:01:32,000
The IF stage contains the program counter and the main memory interface for fetching instructions.

12
00:01:32,000 --> 00:01:26,000
The RF stage has the register file and operand multiplexers.

13
00:01:26,000 --> 00:01:41,000
The ALU stage uses the operands and computes the result.

14
00:01:41,000 --> 00:01:46,000
The MEM stage handles the memory access for load and store operations.

15
00:01:46,000 --> 00:01:51,000
And the WB stage writes the result into the destination register.

16
00:01:51,000 --> 00:01:57,000
In each clock cycle, each stage does its part in the execution of a particular instruction.

17
00:01:57,000 --> 00:02:01,000
In a given clock cycle, there are five instructions in the pipeline.

18
00:02:01,000 --> 00:02:05,000
Note that data accesses to main memory span almost two clock cycles.

19
00:02:05,000 --> 00:02:14,000
Data accesses are initiated at the beginning of the MEM stage and returning data is only needed just before the end of the WB stage.

20
00:02:14,000 --> 00:02:23,000
The memory is itself pipelined and can simultaneously finish the access from an earlier instruction while starting an access for the next instruction.

21
00:02:23,000 --> 00:02:29,000
This simplified diagram isn't showing how the control logic is split across the pipeline stages.

22
00:02:29,000 --> 00:02:30,000
How does that work?

23
00:02:30,000 --> 00:02:40,000
Note that we've included instruction registers as part of each pipeline stage, so that each stage can compute the control signals it needs from its instruction register.

24
00:02:40,000 --> 00:02:47,000
The encoded instruction is simply passed from one stage to the next as the instruction flows through the pipeline..

25
00:02:47,000 --> 00:02:52,000
Each stage computes its control signals from the opcode field of its instruction register.

26
00:02:52,000 --> 00:02:57,000
The RF stage needs the RA, RB, and literal fields from its instruction register.

27
00:02:57,000 --> 00:03:02,000
And the WB stage needs the RC field from its instruction register.

28
00:03:02,000 --> 00:03:10,000
The required logic is very similar to the unpipelined implementation, it's just been split up and moved to the appropriate pipeline stage.

29
00:03:10,000 --> 00:03:16,000
We'll see that we will have to add some additional control logic to deal correctly with pipeline hazards.

30
00:03:16,000 --> 00:03:20,000
Our simplified diagram isn't so simple anymore!

31
00:03:20,000 --> 00:03:27,000
To see how the pipeline works, let's follow along as it executes this sequence of six instructions.

32
00:03:27,000 --> 00:03:33,000
Note that the instructions are reading and writing from different registers, so there are no potential data hazards.

33
00:03:33,000 --> 00:03:03,000
And there are no branches and jumps, so there are no potential control hazards.

34
00:03:03,000 --> 00:03:47,000
Since there are no potential hazards, the instruction executions can be overlapped and their overlapped execution in the pipeline will work correctly.

35
00:03:47,000 --> 00:03:49,000
Okay, here we go!

36
00:03:49,000 --> 00:04:03,000
During cycle 1, the IF stage sends the value from the program counter to main memory to fetch the first instruction (the green LD instruction), which will be stored in the RF-stage instruction register at the end of the cycle.

37
00:04:03,000 --> 00:04:09,000
Meanwhile, it's also computing PC+4, which will be the next value of the program counter.

38
00:04:09,000 --> 00:04:16,000
We've colored the next value blue to indicate that it's the address of the blue instruction in the sequence.

39
00:04:16,000 --> 00:04:23,000
We'll add the appropriately colored label on the right of each pipeline stage to indicate which instruction the stage is processing.

40
00:04:23,000 --> 00:04:34,000
At the start of cycle 2, we see that values in the PC and instruction registers for the RF stage now correspond to the green instruction.

41
00:04:34,000 --> 00:04:42,000
During the cycle the register file will be reading the register operands, in this case R1, which is needed for the green instruction.

42
00:04:42,000 --> 00:04:53,000
Since the green instruction is a LD, ASEL is 0 and BSEL is 1, selecting the appropriate values to be written into the A and B operand registers at the end of the cycle.

43
00:04:53,000 --> 00:05:03,000
Concurrently, the IF stage is fetching the blue instruction from main memory and computing an updated PC value for the next cycle.

44
00:05:03,000 --> 00:05:20,000
In cycle 3, the green instruction is now in the ALU stage, where the ALU is adding the values in its operand registers (in this case the value of R1 and the constant 4) and the result will be stored in Y_MEM register at the end of the cycle.

45
00:05:20,000 --> 00:05:25,000
In cycle 4, we're overlapping execution of four instructions.

46
00:05:25,000 --> 00:05:30,000
The MEM stage initiates a memory read for the green LD instruction.

47
00:05:30,000 --> 00:05:39,000
Note that the read data will first become available in the WB stage -- it's not available to CPU in the current clock cycle.

48
00:05:39,000 --> 00:05:47,000
In cycle 5, the results of the main memory read initiated in cycle 4 are available for writing to the register file in the WB stage.

49
00:05:47,000 --> 00:05:56,000
So execution of the green LD instruction will be complete when the memory data is written to R2 at the end of cycle 5.

50
00:05:56,000 --> 00:06:02,000
Meanwhile, the MEM stage is initiating a memory read for the blue LD instruction.

51
00:06:02,000 --> 00:06:07,000
The pipeline continues to complete successive instructions in successive clock cycles.

52
00:06:07,000 --> 00:06:10,000
The latency for a particular instruction is 5 clock cycles.

53
00:06:10,000 --> 00:06:15,000
The throughput of the pipelined CPU is 1 instruction/cycle.

54
00:06:15,000 --> 00:06:24,000
This is the same as the unpipelined implementation, except that the clock period is shorter because each pipeline stage has fewer components.

55
00:06:24,000 --> 00:06:34,000
Note that the effects of the green LD, i.e., filling R2 with a new value, don't happen until the rising edge of the clock at the end of cycle 5.

56
00:06:34,000 --> 00:06:41,000
In other words, the results of the green LD aren't available to other instructions until cycle 6.

57
00:06:41,000 --> 00:06:49,000
If there were instructions in the pipeline that read R2 before cycle 6, they would have gotten an old value!

58
00:06:49,000 --> 00:06:51,000
This is an example of a data hazard.

59
00:06:51,000 --> 00:06:56,000
Not a problem for us, since our instruction sequence didn't trigger this data hazard.

60
00:06:56,000 --> 00:07:01,000
Tackling data hazards is our next task.

