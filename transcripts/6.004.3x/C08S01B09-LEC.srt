0
00:00:00,000 --> 00:00:07,000
In a weak priority system the currently-running task will always run to completion before considering what to run next.

1
00:00:07,000 --> 00:00:14,000
This means the worst-case latency for a device always includes the worst-case service time across all the other devices,

2
00:00:14,000 --> 00:00:19,000
i.e., the maximum time we have to wait for the currently-running task to complete.

3
00:00:19,000 --> 00:00:26,000
If there's a long-running task that usually means it will be impossible to meet tight deadlines for other tasks.

4
00:00:26,000 --> 00:00:34,000
For example, suppose disk requests have a 800 us deadline in order to guarantee the best throughput from the disk subsystem.

5
00:00:34,000 --> 00:00:46,000
Since the disk handler service time is 500 us, the maximum allowable latency between a disk request and starting to execute the disk service routine is 300 us.

6
00:00:46,000 --> 00:00:48,000
Oops!

7
00:00:48,000 --> 00:00:55,000
The weak priority scheme can only guarantee a maximum latency of 800 us, not nearly fast enough to meet the disk deadline.

8
00:00:55,000 --> 00:00:59,000
We can't meet the disk deadline using weak priorities.

9
00:00:59,000 --> 00:01:08,000
We need to introduce a preemptive priority system that allows lower-priority handlers to be interrupted by higher-priority requests.

10
00:01:08,000 --> 00:01:11,000
We'll refer to this as a "strong" priority system.

11
00:01:11,000 --> 00:01:19,000
Suppose we gave the disk the highest priority, the printer second priority, and keyboard the lowest priority, just like we did before.

12
00:01:19,000 --> 00:01:29,000
Now when a disk request arrives, it will start executing immediately without having to wait for the completion of the lower-priority printer or keyboard handlers.

13
00:01:29,000 --> 00:01:33,000
The worst-case latency for the disk has dropped to 0.

14
00:01:33,000 --> 00:01:39,000
The printer can only be preempted by the disk, so it's worst-case latency is 500 us.

15
00:01:39,000 --> 00:01:49,000
Since it has the lowest priority, the worst-case latency for the keyboard is unchanged at 900 us since it might still have to wait on the disk and printer.

16
00:01:49,000 --> 00:01:59,000
The good news: with the proper assignment of priorities, the strong priority system can guarantee that disk requests will be serviced by the 800 us deadline.

17
00:01:59,000 --> 00:02:05,000
We'll need to make a small tweak to our Beta hardware to implement a strong priority system.

18
00:02:05,000 --> 00:02:20,000
We'll replace the single supervisor mode bit in PC[31] with, say, a three-bit field (PRI) in PC[31:29] that indicates which of the eight priority levels the processor is currently running at.

19
00:02:20,000 --> 00:02:23,000
Next, we'll modify the interrupt mechanism as follows.

20
00:02:23,000 --> 00:02:32,000
In addition to requesting an interrupt, the requesting device also specifies the 3-bit priority it was assigned by the system architect.

21
00:02:32,000 --> 00:02:44,000
We'll add a priority encoder circuit to the interrupt hardware to select the highest-priority request and compare the priority of that request (PDEV) to the 3-bit PRI value in the PC.

22
00:02:44,000 --> 00:02:55,000
The system will take the interrupt request only if PDEV > PRI, i.e., if the priority of the request is *higher* than the priority the system is running at.

23
00:02:55,000 --> 00:03:08,000
When the interrupt is taken, the old PC and PRI information is saved in XP, and the new PC is determined by the type of interrupt and the new PRI field is set to PDEV.

24
00:03:08,000 --> 00:03:12,000
So the processor will now be running at the higher priority specified by the device.

25
00:03:12,000 --> 00:03:20,000
A strong priority system allows low-priority handlers to be interrupted by higher-priority requests,

26
00:03:20,000 --> 00:03:28,000
so the worst-case latency seen at high priorities is unaffected by the service times of lower-priority handlers.

27
00:03:28,000 --> 00:03:36,000
Using strong priorities allows us to assign a high priority to devices with tight deadlines and thus guarantee their deadlines are met.

28
00:03:36,000 --> 00:03:43,000
Now let's consider the impact of recurring interrupts, i.e., multiple interrupt requests from each device.

29
00:03:43,000 --> 00:03:52,000
We've added a "maximum frequency" column to our table, which gives the maximum rate at which requests will be generated by each device.

30
00:03:52,000 --> 00:03:57,000
The execution diagram for a strong priority system is shown below the table.

31
00:03:57,000 --> 00:04:05,000
Here we see there are multiple requests from each device, in this case shown at their maximum possible rate of request.

32
00:04:05,000 --> 00:04:10,000
Each tick on the timeline represent 100 us of real time.

33
00:04:10,000 --> 00:04:22,000
Printer requests occur every 1 ms (10 ticks), disk requests every 2 ms (20 ticks), and keyboard requests every 10 ms (100 ticks).

34
00:04:22,000 --> 00:04:29,000
In the diagram you can see that the high-priority disk requests are serviced as soon as they're received.

35
00:04:29,000 --> 00:04:35,000
And that medium-priority printer requests preempt lower-priority execution of the keyboard handler.

36
00:04:35,000 --> 00:04:48,000
Printer requests would be preempted by disk requests, but given their request patterns, there's never a printer request in progress when a disk request arrives, so we don't see that happening here.

37
00:04:48,000 --> 00:04:53,000
The maximum latency before a keyboard requests starts is indeed 900 us.

38
00:04:53,000 --> 00:04:56,000
But that doesn't tell the whole story!

39
00:04:56,000 --> 00:05:09,000
As you can see, the poor keyboard handler is continually preempted by higher-priority disk and printer requests and so the keyboard handler doesn't complete until 3 ms after its request was received!

40
00:05:09,000 --> 00:05:15,000
This illustrates why real-time constraints are best expressed in terms of deadlines and not latencies.

41
00:05:15,000 --> 00:05:24,000
If the keyboard deadline had been less that 3 ms, even the strong priority system would have failed to meet the hard real-time constraints.

42
00:05:24,000 --> 00:05:32,000
The reason would be that there simply aren't enough CPU cycles to meet the recurring demands of the devices in the face of tight deadlines.

43
00:05:32,000 --> 00:05:40,000
Speaking of having enough CPU cycles, there are several calculations we need to do when thinking about recurring interrupts.

44
00:05:40,000 --> 00:05:45,000
The first is to consider how much load each periodic request places on the system.

45
00:05:45,000 --> 00:05:57,000
There's one keyboard request every 10 ms and servicing each request takes 800 us, which consumes 800us/10ms = 8% of the CPU.

46
00:05:57,000 --> 00:06:05,000
A similar calculation shows that servicing the disk takes 25% of the CPU and servicing the printer takes 40% of the CPU.

47
00:06:05,000 --> 00:06:15,000
Collectively servicing all the devices takes 73% of the CPU cycles, leaving 27% for running user-mode programs.

48
00:06:15,000 --> 00:06:21,000
Obviously we'd be in trouble if takes more than 100% of the available cycles to service the devices.

49
00:06:21,000 --> 00:06:28,000
Another way to get in trouble is to not have enough CPU cycles to meet each of the deadlines.

50
00:06:28,000 --> 00:06:36,000
We need 500/800 = 67.5% of the cycles to service the disk in the time between the disk request and disk deadline.

51
00:06:36,000 --> 00:06:45,000
If we assume we want to finish serving one printer request before receiving the next, the effective printer deadline is 1000 us.

52
00:06:45,000 --> 00:06:55,000
In 1000 us we need to be able to service one higher-priority disk request (500 us) and, obviously, the printer request (400 us).

53
00:06:55,000 --> 00:07:01,000
So we'll need to use 900 us of the CPU in that 1000 us interval.

54
00:07:01,000 --> 00:07:04,000
Whew, just barely made it!

55
00:07:04,000 --> 00:07:08,000
Suppose we tried setting the keyboard deadline to 2000 us.

56
00:07:08,000 --> 00:07:14,000
In that time interval we'd also need to service 1 disk request and 2 printer requests.

57
00:07:14,000 --> 00:07:22,000
So the total service time needed is 500 + 2*400 + 800 = 2100 us.

58
00:07:22,000 --> 00:07:32,000
Oops, that exceeds the 2000 us window we were given, so we can't meet the 2000 us deadline with the available CPU resources.

59
00:07:32,000 --> 00:07:38,000
But if the keyboard deadline is 3000 us, let's see what happens.

60
00:07:38,000 --> 00:07:53,000
In a 3000 us interval we need to service 2 disk requests, 3 printer requests, and, of course, 1 keyboard request, for a total service time of 2*500 + 3*400 + 800 = 3000 us.

61
00:07:53,000 --> 00:07:56,000
Whew! Just made it!

