0
00:00:00,000 --> 00:00:05,000
A key technology for timesharing is the periodic interrupt from the external timer device.

1
00:00:05,000 --> 00:00:09,000
Let's remind ourselves how the interrupt hardware in the Beta works.

2
00:00:09,000 --> 00:00:16,000
External devices request an interrupt by asserting the Beta's interrupt request (IRQ) input.

3
00:00:16,000 --> 00:00:28,000
If the Beta is running in user mode, i.e., the supervisor bit stored in the PC is 0, asserting IRQ will trigger the following actions on the clock cycle the interrupt is recognized.

4
00:00:28,000 --> 00:00:40,000
The goal is to save the current PC+4 value in the XP register and force the program counter (PC) to a particular kernel-mode instruction, which starts the execution of the interrupt handler code.

5
00:00:40,000 --> 00:00:50,000
The normal process of generating control signals based on the current instruction is superseded by forcing particular values for some of the control signals.

6
00:00:50,000 --> 00:00:58,000
PCSEL is set to 4, which selects a specified kernel-mode address as the next value of the program counter.

7
00:00:58,000 --> 00:01:02,000
The address chosen depends on the type of external interrupt.

8
00:01:02,000 --> 00:01:08,000
In the case of the timer interrupt, the address is 0x80000008.

9
00:01:08,000 --> 00:01:18,000
Note that PC[31], the supervisor bit, is being set to 1 and the CPU will be in kernel-mode as it starts executing the code of the interrupt handler.

10
00:01:18,000 --> 00:01:30,000
The WASEL, WDSEL, and WERF control signals are set so that PC+4 is written into the XP register (i.e., R30) in the register file.

11
00:01:30,000 --> 00:01:39,000
And, finally, MWR is set to 0 to ensure that if we're interrupting a ST instruction that its execution is aborted correctly.

12
00:01:39,000 --> 00:01:45,000
So in the next clock cycle, execution starts with the first instruction of the kernel-mode interrupt handler,

13
00:01:45,000 --> 00:01:52,000
which can find the PC+4 of the interrupted instruction in the XP register of the CPU.

14
00:01:52,000 --> 00:01:56,000
As we can see the interrupt hardware is pretty minimal:

15
00:01:56,000 --> 00:02:07,000
it saves the PC+4 of the interrupted user-mode program in the XP register and sets the program counter to some predetermined value that depends on which external interrupt happened.

16
00:02:07,000 --> 00:02:13,000
The remainder of the work to handle the interrupt request is performed in software.

17
00:02:13,000 --> 00:02:24,000
The state of the interrupted process, e.g., the values in the CPU registers R0 through R30, is stored in main memory in an OS data structure called UserMState.

18
00:02:24,000 --> 00:02:31,000
Then the appropriate handler code, usually a procedure written in C, is invoked to do the heavy lifting.

19
00:02:31,000 --> 00:02:36,000
When that procedure returns, the process state is reloaded from UserMState.

20
00:02:36,000 --> 00:02:47,000
The OS subtracts 4 from the value in XP, making it point to the interrupted instruction and then resumes user-mode execution with a JMP(XP).

21
00:02:47,000 --> 00:02:57,000
Note that in our simple Beta implementation the first instructions for the various interrupt handlers occupy consecutive locations in main memory.

22
00:02:57,000 --> 00:03:05,000
Since interrupt handlers are longer than one instruction, this first instruction is invariably a branch to the actual interrupt code.

23
00:03:05,000 --> 00:03:21,000
Here we see that the reset interrupt (asserted when the CPU first starts running) sets the PC to 0, the illegal instruction interrupt sets the PC to 4, the timer interrupt sets the PC to 8, and so on.

24
00:03:21,000 --> 00:03:33,000
In all cases, bit 31 of the new PC value is set to 1 so that handlers execute in supervisor or kernel mode, giving them access to the kernel context.

25
00:03:33,000 --> 00:03:45,000
A common alternative is provide a table of new PC values at a known location and have the interrupt hardware access that table to fetch the PC for the appropriate handler routine.

26
00:03:45,000 --> 00:03:50,000
This provides the same functionality as our simple Beta implementation.

27
00:03:50,000 --> 00:03:59,000
Since the process state is saved and restored during an interrupt, interrupts are transparent to the running user-mode program.

28
00:03:59,000 --> 00:04:07,000
In essence, we borrow a few CPU cycles to deal with the interrupt, then it's back to normal program execution.

29
00:04:07,000 --> 00:04:10,000
Here's how the timer interrupt handler would work.

30
00:04:10,000 --> 00:04:17,000
Our initial goal is to use the timer interrupt to update a data value in the OS that records the current time of day (TOD).

31
00:04:17,000 --> 00:04:21,000
Let's assume the timer interrupt is triggered every 1/60th of a second.

32
00:04:21,000 --> 00:04:28,000
A user-mode program executes normally, not needing to make any special provision to deal with timer interrupts.

33
00:04:28,000 --> 00:04:38,000
Periodically the timer interrupts the user-mode program to run the clock interrupt handler code in the OS, then resumes execution of the user-mode program.

34
00:04:38,000 --> 00:04:43,000
The program continues execution just as if the interrupt had not occurred.

35
00:04:43,000 --> 00:04:50,000
If the program needs access to the TOD, it makes the appropriate service request to the OS.

36
00:04:50,000 --> 00:04:58,000
The clock handler code in the OS starts and ends with a small amount of assembly-language code to save and restore the state.

37
00:04:58,000 --> 00:05:04,000
In the middle, the assembly code makes a C procedure call to actually handle the interrupt.

38
00:05:04,000 --> 00:05:07,000
Here's what the handler code might look like.

39
00:05:07,000 --> 00:05:17,000
In C, we find the declarations for the TOD data value and the structure, called UserMState, that temporarily holds the saved process state.

40
00:05:17,000 --> 00:05:21,000
There's also the C procedure for incrementing the TOD value.

41
00:05:21,000 --> 00:05:31,000
A timer interrupt executes the BR() instruction at location 8, which branches to the actual interrupt handler code at CLOCK_H.

42
00:05:31,000 --> 00:05:37,000
The code first saves the values of all the CPU registers into the UserMState data structure.

43
00:05:37,000 --> 00:05:42,000
Note that we don't save the value of R31 since its value is always 0.

44
00:05:42,000 --> 00:05:49,000
After setting up the kernel-mode stack, the assembly-language stub calls the C procedure above to do the hard work.

45
00:05:49,000 --> 00:06:01,000
When the procedure returns, the CPU registers are reloaded from the saved process state and the XP register value decremented by 4 so that it will point to the interrupted instruction.

46
00:06:01,000 --> 00:06:05,000
Then a JMP(XP) resumes user-mode execution.

47
00:06:05,000 --> 00:06:08,000
Okay, that was simple enough.

48
00:06:08,000 --> 00:06:12,000
But what does this all have to do with timesharing?

49
00:06:12,000 --> 00:06:16,000
Wasn't our goal to arrange to periodically switch which process was running?

50
00:06:16,000 --> 00:06:18,000
Aha!

51
00:06:18,000 --> 00:06:27,000
We have code that runs on every timer interrupt, so let's modify it so that every so often we arrange to call the OS' Scheduler() routine.

52
00:06:27,000 --> 00:06:35,000
In this example, we'd set the constant QUANTUM to 2 if we wanted to call Scheduler() every second timer interrupt.

53
00:06:35,000 --> 00:06:40,000
The Scheduler() subroutine is where the time sharing magic happens!

54
00:06:40,000 --> 00:06:48,000
Here we see the UserMState data structure from the previous slide where the user-mode process state is stored during interrupts.

55
00:06:48,000 --> 00:06:55,000
And here's an array of process control block (PCB) data structures, one for each process in the system.

56
00:06:55,000 --> 00:07:05,000
The PCB holds the complete state of a process when some other process is currently executing -- it's the long-term storage for processor state!

57
00:07:05,000 --> 00:07:17,000
As you can see, it includes a copy of MState with the process' register values, the MMU state, and various state associated with the process' input/output activities,

58
00:07:17,000 --> 00:07:23,000
represented here by a number indicating which virtual user-interface console is attached to the process.

59
00:07:23,000 --> 00:07:27,000
There are N processes altogether.

60
00:07:27,000 --> 00:07:33,000
The variable CUR gives the index into ProcTable for the currently running process.

61
00:07:33,000 --> 00:07:39,000
And here's the surprisingly simple code for implementing timesharing.

62
00:07:39,000 --> 00:07:48,000
Whenever the Scheduler() routine is called, it starts by moving the temporary saved state into the PCB for the current process.

63
00:07:48,000 --> 00:07:58,000
It then increments CUR to move to the next process, making sure it wraps back around to 0 when we've just finished running the last of the N processes.

64
00:07:58,000 --> 00:08:07,000
It then loads reloads the temporary state from the PCB of the new process and sets up the MMU appropriately.

65
00:08:07,000 --> 00:08:17,000
At this point Scheduler() returns and the clock interrupt handler reloads the CPU registers from the updated temporary saved state and resumes execution.

66
00:08:17,000 --> 00:08:19,000
Voila!

67
00:08:19,000 --> 00:08:21,000
We're now running a new process.

68
00:08:21,000 --> 00:08:26,000
Let's use this diagram to once again walk through how time sharing works.

69
00:08:26,000 --> 00:08:24,000
At the top of the diagram you'll see the code for the user-mode processes, and below the OS code along with its data structures.

70
00:08:24,000 --> 00:08:42,000
The timer interrupts the currently running user-mode program and starts execution of the OS' clock handler code.

71
00:08:42,000 --> 00:08:48,000
The first thing the handler does is save all the registers into the UserMState data structure.

72
00:08:48,000 --> 00:09:00,000
If the Scheduler() routine is called, it moves the temporarily saved state into the PCB, which provides the long-term storage for a process' state.

73
00:09:00,000 --> 00:09:06,000
Next, Scheduler() copies the saved state for the next process into the temporary holding area.

74
00:09:06,000 --> 00:09:15,000
Then the clock handler reloads the updated state into the CPU registers and resumes execution, this time running code in the new process.

75
00:09:15,000 --> 00:09:25,000
While we're looking at the OS, note that since its code runs with the supervisor mode bit set to 1, interrupts are disabled while in the OS.

76
00:09:25,000 --> 00:09:37,000
This prevents the awkward problem of getting a second interrupt while still in the middle of handling a first interrupt, a situation that might accidentally overwrite the state in UserMState.

77
00:09:37,000 --> 00:09:42,000
But that means one has to be very careful when writing OS code.

78
00:09:42,000 --> 00:09:46,000
Any sort of infinite loop can never be interrupted.

79
00:09:46,000 --> 00:09:53,000
You may have experienced this when your machine appears to freeze, accepting no inputs and just sitting there like a lump.

80
00:09:53,000 --> 00:10:00,000
At this point, your only choice is to power-cycle the hardware (the ultimate interrupt!) and start afresh.

81
00:10:00,000 --> 00:10:12,000
Interrupts are allowed during execution of user-mode programs, so if they run amok and need to be interrupted, that's always possible since the OS is still responding to, say, keyboard interrupts.

82
00:10:12,000 --> 00:10:22,000
Every OS has a magic combination of keystrokes that is guaranteed to suspend execution of the current process, sometimes arranging to make a copy of the process state for later debugging.

83
00:10:22,000 --> 00:10:24,000
Very handy!

