0
00:00:00,000 --> 00:00:03,000
Here's how our virtual memory system will work.

1
00:00:03,000 --> 00:00:11,000
The memory addresses generated by the CPU are called virtual addresses to distinguish them from the physical addresses used by main memory.

2
00:00:11,000 --> 00:00:19,000
In between the CPU and main memory there's a new piece of hardware called the memory management unit (MMU).

3
00:00:19,000 --> 00:00:24,000
The MMU's job is to translate virtual addresses to physical addresses.

4
00:00:24,000 --> 00:00:26,000
"But wait!" you say.

5
00:00:26,000 --> 00:00:30,000
"Doesn't the cache go between the CPU and main memory?"

6
00:00:30,000 --> 00:00:36,000
You're right and at the end of this lecture we'll talk about how to use both an MMU and a cache.

7
00:00:36,000 --> 00:00:40,000
But for now, let's assume there's only an MMU and no cache.

8
00:00:40,000 --> 00:00:48,000
The MMU hardware translates virtual addresses to physical addresses using a simple table lookup.

9
00:00:48,000 --> 00:00:51,000
This table is called the page map or page table.

10
00:00:51,000 --> 00:01:00,000
Conceptually, the MMU uses the virtual address as index to select an entry in the table, which tells us the corresponding physical address.

11
00:01:00,000 --> 00:01:05,000
The table allows a particular virtual address to be found anywhere in main memory.

12
00:01:05,000 --> 00:01:12,000
In normal operation we'd want to ensure that two virtual addresses don't map to the same physical address.

13
00:01:12,000 --> 00:01:19,000
But it would be okay if some of the virtual addresses did not have a translation to a physical address.

14
00:01:19,000 --> 00:01:29,000
This would indicate that the contents of the requested virtual address haven't yet been loaded into main memory, so the MMU would signal a memory-management exception to the CPU,

15
00:01:29,000 --> 00:01:38,000
which could assign a location in physical memory and perform the required I/O operation to initialize that location from secondary storage.

16
00:01:38,000 --> 00:01:47,000
The MMU table gives the system a lot of control over how physical memory is accessed by the program running on the CPU.

17
00:01:47,000 --> 00:01:57,000
For example, we could arrange to run multiple programs in quick succession (a technique called time sharing) by changing the page map when we change programs.

18
00:01:57,000 --> 00:02:06,000
Main memory locations accessible to one program could be made inaccessible to another program by proper management of their respective page maps.

19
00:02:06,000 --> 00:02:17,000
And we could use memory-management exceptions to load program contents into main memory on demand instead of having to load the entire program before execution starts.

20
00:02:17,000 --> 00:02:24,000
In fact, we only need to ensure the current working set of a program is actually resident in main memory.

21
00:02:24,000 --> 00:02:29,000
Locations not currently being used could live in secondary storage until needed.

22
00:02:29,000 --> 00:02:37,000
In this lecture and next, we'll see how the MMU plays a central role in the design of a modern timesharing computer system.

23
00:02:37,000 --> 00:02:45,000
Of course, we'd need an impossibly large table to separately map each virtual address to a physical address.

24
00:02:45,000 --> 00:02:52,000
So instead we divide both the virtual and physical address spaces into fixed-sized blocks, called pages.

25
00:02:52,000 --> 00:03:03,000
Page sizes are always a power-of-2 bytes, say 2^p bytes, so p is the number address bits needed to select a particular location on the page.

26
00:03:03,000 --> 00:03:08,000
We'll the use low-order p bits of the virtual or physical address as the page offset.

27
00:03:08,000 --> 00:03:15,000
The remaining address bits tell us which page is being accessed and are called the page number.

28
00:03:15,000 --> 00:03:24,000
A typical page size is 4KB to 16KB, which correspond to p=12 and p=14 respectively.

29
00:03:24,000 --> 00:03:26,000
Suppose p=12.

30
00:03:26,000 --> 00:03:38,000
If the CPU produces a 32-bit virtual address, the low-order 12 bits of the virtual address are the page offset and the high-order 20 bits are the virtual page number.

31
00:03:38,000 --> 00:03:47,000
Similarly, the low-order p bits of the physical address are the page offset and the remaining physical address bits are the physical page number.

32
00:03:47,000 --> 00:03:53,000
The key idea is that the MMU will manage pages, not individual locations.

33
00:03:53,000 --> 00:03:57,000
We'll move entire pages from secondary storage into main memory.

34
00:03:57,000 --> 00:04:07,000
By the principal of locality, if a program access one location on a page, we expect it will soon access other nearby locations.

35
00:04:07,000 --> 00:04:18,000
By choosing the page offset from the low-order address bits, we'll ensure that nearby locations live on the same page (unless of course we're near one end of the page or the other).

36
00:04:18,000 --> 00:04:22,000
So pages naturally capture the notion of locality.

37
00:04:22,000 --> 00:04:27,000
And since pages are large, by dealing with pages when accessing secondary storage,

38
00:04:27,000 --> 00:04:35,000
we'll take advantage that reading or writing many locations is only slightly more time consuming than accessing the first location.

39
00:04:35,000 --> 00:04:40,000
The MMU will map virtual page numbers to physical page numbers.

40
00:04:40,000 --> 00:04:47,000
It does this by using the virtual page number (VPN) as an index into the page table.

41
00:04:47,000 --> 00:04:55,000
Each entry in the page table indicates if the page is resident in main memory and, if it is, provides the appropriate physical page number (PPN).

42
00:04:55,000 --> 00:05:02,000
The PPN is combined with the page offset to form the physical address for main memory.

43
00:05:02,000 --> 00:05:13,000
If the requested virtual page is NOT resident in main memory, the MMU signals a memory-management exception, called a page fault, to the CPU

44
00:05:13,000 --> 00:05:20,000
so it can load the appropriate page from secondary storage and set up the appropriate mapping in the MMU.

45
00:05:20,000 --> 00:05:31,000
Our plan to use main memory as page cache is called "paging" or sometimes "demand paging" since movements of pages to and from secondary storage is determined by the demands of the program.

46
00:05:31,000 --> 00:05:34,000
So here's the plan.

47
00:05:34,000 --> 00:05:44,000
Initially all the virtual pages for a program reside in secondary storage and the MMU is empty, i.e., there are no pages resident in physical memory.

48
00:05:44,000 --> 00:05:56,000
The CPU starts running the program and each virtual address it generates, either for an instruction fetch or data access, is passed to the MMU to be mapped to a physical address in main memory.

49
00:05:56,000 --> 00:06:02,000
If the virtual address is resident in physical memory, the main memory hardware can complete the access.

50
00:06:02,000 --> 00:06:15,000
If the virtual address in NOT resident in physical memory, the MMU signals a page fault exception, forcing the CPU to switch execution to special code called the page fault handler.

51
00:06:15,000 --> 00:06:25,000
The handler allocates a physical page to hold the requested virtual page and loads the virtual page from secondary storage into main memory.

52
00:06:25,000 --> 00:06:37,000
It then adjusts the page map entry for the requested virtual page to show that it is now resident and to indicate the physical page number for the newly allocated and initialized physical page.

53
00:06:37,000 --> 00:06:45,000
When trying to allocate a physical page, the handler may discover that all physical pages are currently in use.

54
00:06:45,000 --> 00:06:54,000
In this case it chooses an existing page to replace, e.g., a resident virtual page that hasn't been recently accessed.

55
00:06:54,000 --> 00:07:05,000
It swaps the contents of the chosen virtual page out to secondary storage and updates the page map entry for the replaced virtual page to indicate it is no longer resident.

56
00:07:05,000 --> 00:07:11,000
Now there's a free physical page to re-use to hold the contents of the virtual page that was missing.

57
00:07:11,000 --> 00:07:22,000
The working set of the program, i.e., the set of pages the program is currently accessing, is loaded into main memory through a series of page faults.

58
00:07:22,000 --> 00:07:36,000
After a flurry of page faults when the program starts running, the working set changes slowly, so the frequency of page faults drops dramatically, perhaps close to zero if the program is small and well-behaved.

59
00:07:36,000 --> 00:07:42,000
It is possible to write programs that consistently generate page faults, a phenomenon called thrashing.

60
00:07:42,000 --> 00:07:55,000
Given the long access times of secondary storage, a program that's thrashing runs *very* slowly, usually so slowly that users give up and rewrite the program to behave more sensibly.

61
00:07:55,000 --> 00:07:59,000
The design of the page map is straightforward.

62
00:07:59,000 --> 00:08:03,000
There's one entry in the page map for each virtual page.

63
00:08:03,000 --> 00:08:17,000
For example, if the CPU generates a 32-bit virtual address and the page size is 2^12 bytes, the virtual page number has 32-12 = 20 bits and the page table will have 2^20 entries.

64
00:08:17,000 --> 00:08:27,000
Each entry in the page table contains a "resident bit" (R) which is set to 1 when the virtual page is resident in physical memory.

65
00:08:27,000 --> 00:08:32,000
If R is 0, an access to that virtual page will cause a page fault.

66
00:08:32,000 --> 00:08:41,000
If R is 1, the entry also contains the PPN, indicating where to find the virtual page in main memory.

67
00:08:41,000 --> 00:08:46,000
There's one additional state bit called the "dirty bit" (D).

68
00:08:46,000 --> 00:08:57,000
When a page has just been loaded from secondary storage, it's "clean", i.e, the contents of physical memory match the contents of the page in secondary storage.

69
00:08:57,000 --> 00:09:00,000
So the D bit is set to 0.

70
00:09:00,000 --> 00:09:14,000
If subsequently the CPU stores into a location on the page, the D bit for the page is set to 1, indicating the page is "dirty", i.e., the contents of memory now differ from the contents of secondary storage.

71
00:09:14,000 --> 00:09:25,000
If a dirty page is ever chosen for replacement, its contents must be written to secondary storage in order to save the changes before the page gets reused.

72
00:09:25,000 --> 00:09:30,000
Some MMUs have additional state bits in each page table entry.

73
00:09:30,000 --> 00:09:38,000
For example, there could be a "read-only" bit which, when set, would generate an exception if the program attempts to store into the page.

74
00:09:38,000 --> 00:09:46,000
This would be useful for protecting code pages from accidentally being corrupted by errant data accesses, a very handy debugging feature.

75
00:09:46,000 --> 00:09:50,000
Here's an example of the MMU in action.

76
00:09:50,000 --> 00:09:59,000
To make things simple, assume that the virtual address is 12 bits, consisting of an 8-bit page offset and a 4-bit virtual page number.

77
00:09:59,000 --> 00:10:03,000
So there are 2^4 = 16 virtual pages.

78
00:10:03,000 --> 00:10:11,000
The physical address is 11 bits, divided into the same 8-bit page offset and a 3-bit physical page number.

79
00:10:11,000 --> 00:10:14,000
So there are 2^3 = 8 physical pages.

80
00:10:14,000 --> 00:10:23,000
On the left we see a diagram showing the contents of the 16-entry page map, i.e., an entry for each virtual page.

81
00:10:23,000 --> 00:10:33,000
Each page table entry includes a dirty bit (D), a resident bit (R) and a 3-bit physical page number, for a total of 5 bits.

82
00:10:33,000 --> 00:10:40,000
So the page map has 16 entries, each with 5-bits, for a total of 16*5 = 80 bits.

83
00:10:40,000 --> 00:10:47,000
The first entry in the table is for virtual page 0, the second entry for virtual page 1, and so on.

84
00:10:47,000 --> 00:10:54,000
In the middle of the slide there's a diagram of physical memory showing the 8 physical pages.

85
00:10:54,000 --> 00:11:00,000
The annotation for each physical page shows the virtual page number of its contents.

86
00:11:00,000 --> 00:11:05,000
Note that there's no particular order to how virtual pages are stored in physical memory --

87
00:11:05,000 --> 00:11:11,000
which page holds what is determined by which pages are free at the time of a page fault.

88
00:11:11,000 --> 00:11:18,000
In general, after the program has run for a while, we'd expected to find the sort of jumbled ordering we see here.

89
00:11:18,000 --> 00:11:29,000
Let's follow along as the MMU handles the request for virtual address 0x2C8, generated by the execution of the LD instruction shown here.

90
00:11:29,000 --> 00:11:39,000
Splitting the virtual address into page number and offset, we see that the VPN is 2 and the offset is 0xC8.

91
00:11:39,000 --> 00:11:49,000
Looking at the page map entry with index 2, we see that the R bit is 1, indicating that virtual page 2 is resident in physical memory.

92
00:11:49,000 --> 00:11:56,000
The PPN field of entry tells us that virtual page 2 can be found in physical page 4.

93
00:11:56,000 --> 00:12:08,000
Combining the PPN with the 8-bit offset, we find that the contents of virtual address 0x2C8 can be found in main memory location 0x4C8.

94
00:12:08,000 --> 00:12:13,000
Note that the offset is unchanged by the translation process --

95
00:12:13,000 --> 00:12:19,000
the offset into the physical page is always the same as the offset into the virtual page.

