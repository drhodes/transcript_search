0
00:00:00,000 --> 00:00:19,000
Here's an old quiz problem we can use to test our understanding of all the factors that went into the final design of our ReadKey() SVC code.

1
00:00:19,000 --> 00:00:20,000
We're considering three different versions (R1, R2, and R3) of the ReadKey() SVC code, all variants of the various attempts from the previous section.

2
00:00:20,000 --> 00:00:25,000
And there are three types of systems (Models A, B, and C).

3
00:00:25,000 --> 00:00:30,000
We've been asked to match the three handlers to the appropriate system.

4
00:00:30,000 --> 00:00:41,000
Looking at R1, we see it's similar to Attempt #2 from the previous section, except it always reads from the same keyboard regardless of the process making the SVC request.

5
00:00:41,000 --> 00:00:50,000
That wouldn't make much sense in a timesharing system since a single stream of input characters would be shared across all the processes.

6
00:00:50,000 --> 00:00:57,000
So this handler must be intended for the Model C system, which has only a single process.

7
00:00:57,000 --> 00:01:08,000
Looking at R2, we see it's similar to Attempt #1 from the previous section, which had the fatal flaw of a potentially infinite loop if attempting to read from an empty buffer.

8
00:01:08,000 --> 00:01:20,000
So this code would only run successfully on the Model B system, which *does* allow device interrupts even when the CPU is running inside an SVC call.

9
00:01:20,000 --> 00:01:28,000
So the keyboard interrupt would interrupt the while loop in R2 and the next iteration of the loop would discover that buffer was no longer empty.

10
00:01:28,000 --> 00:01:36,000
By the process of elimination that leaves the R3 handler to be paired with the Model A system.

11
00:01:36,000 --> 00:01:45,000
R3 is Attempt #3 from the previous section and is designed for our standard system in which the kernel is uninterruptible.

12
00:01:45,000 --> 00:01:57,000
The problem goes on to say that a fumble-fingered summer intern has jumbled up the disks containing the handlers and sent an unknown handler version to each user running one of the three model systems.

13
00:01:57,000 --> 00:02:07,000
To atone for the mistake, he's been assigned the task of reading various user messages sent after the user has tried the new handler disk on their particular system.

14
00:02:07,000 --> 00:02:14,000
Based on the message, he's been asked to identify which handler disk and system the user is using.

15
00:02:14,000 --> 00:02:21,000
The first message says "I get compile-time errors; Scheduler and ProcTbl are undefined!"

16
00:02:21,000 --> 00:02:31,000
On the right of the slide we've included a table enumerating all the combinations of handlers and systems, where we've X-ed the matches from the previous slide

17
00:02:31,000 --> 00:02:29,000
since they correspond to when the new handler would be the same as the old handler and the user wouldn't be sending a message!

18
00:02:29,000 --> 00:02:48,000
The phrase "Scheduler and ProcTbl are undefined" wouldn't apply to a timesharing system, which includes both symbols.

19
00:02:48,000 --> 00:02:52,000
So we can eliminate the first two columns from consideration.

20
00:02:52,000 --> 00:02:59,000
And we can also eliminate the second row, since handler R2 doesn't include a call to Scheduler.

21
00:02:59,000 --> 00:03:06,000
So this message came from a user trying to run handler R3 on a Model C system.

22
00:03:06,000 --> 00:03:14,000
Since Model C doesn't support timesharing, it would have neither Scheduler nor ProcTbl as part the OS code.

23
00:03:14,000 --> 00:03:22,000
Okay, here's the next message: "Hey, now the system always reads everybody's input from keyboard 0.

24
00:03:22,000 --> 00:03:27,000
Besides that, it seems to waste a lot more CPU cycles than it used to."

25
00:03:27,000 --> 00:03:34,000
R1 is the only handler that always reads from keyboard 0, so we can eliminate rows 2 and 3.

26
00:03:34,000 --> 00:03:41,000
So how can we tell if R1 is being run on a Model A or a Model B system?

27
00:03:41,000 --> 00:03:51,000
The R1 handler wastes a lot of cycles looping while waiting for a character to arrive and the implication is that was a big change for the user

28
00:03:51,000 --> 00:03:36,000
since they're complaining that running R1 is wasting time compared to their previous handler.

29
00:03:36,000 --> 00:04:04,000
If the user had been running R2 on a model B system, they're already used to the performance hit of looping

30
00:04:04,000 --> 00:04:12,000
and so wouldn't have noticed a performance difference switching to R1, so we can eliminate Model B from consideration.

31
00:04:12,000 --> 00:04:18,000
So this message came from a user running handler R1 on a model A system.

32
00:04:18,000 --> 00:04:23,000
The final message reads "Neat, the new system seems to work fine.

33
00:04:23,000 --> 00:04:27,000
It even wastes less CPU time than it used to!"

34
00:04:27,000 --> 00:04:34,000
Since the system works as expected with the new handler, we can eliminate a lot of possibilities.

35
00:04:34,000 --> 00:04:48,000
Handler R1 wouldn't work fine on a timesharing system since the user could tell that the processes were now all reading from the same keyboard buffer, so we can eliminate R1 on Models A and B.

36
00:04:48,000 --> 00:04:59,000
And handlers R2 and R3 wouldn't work on a Model C system since that doesn't include process tables or scheduling, eliminating the right-most column.

37
00:04:59,000 --> 00:05:11,000
Finally handler R2 wouldn't work on a Model A system with its uninterruptible kernel since any attempt to read from an empty buffer would cause an infinite loop.

38
00:05:11,000 --> 00:05:16,000
So, the message must have been sent by a Model B user now running R3.

39
00:05:16,000 --> 00:05:18,000
Well, that was fun!

40
00:05:18,000 --> 00:05:23,000
Just like solving the logic puzzles you find in games magazines :)

