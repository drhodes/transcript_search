0
00:00:00,000 --> 00:00:08,000
In this exercise, we will learn how semaphores can be used to ensure that different precedence constraints in our programs can be satisfied.

1
00:00:08,000 --> 00:00:16,000
Before diving into the use of semaphores to enforce our precedence requirements, let's review what tools we have available to us.

2
00:00:16,000 --> 00:00:21,000
You can think of a semaphore as a shared resource that is limited in quantity.

3
00:00:21,000 --> 00:00:29,000
If we have a semaphore S that is initialized to 0 then it represents the fact that currently resource S is not available.

4
00:00:29,000 --> 00:00:36,000
If S equals 1, then that means that exactly one S resource is available for use.

5
00:00:36,000 --> 00:00:41,000
If S equals 2, then there are 2 S resources available, and so on.

6
00:00:41,000 --> 00:00:46,000
In order to make use of the shared resource, a process must first grab that resource.

7
00:00:46,000 --> 00:00:52,000
This is achieved by adding a wait(S) call before the code that requires the resource.

8
00:00:52,000 --> 00:01:02,000
As long as the value of S equals 0, the code that is waiting for this resource is stalled meaning that it can't get past the wait(S) command.

9
00:01:02,000 --> 00:01:11,000
To get past the wait(S) call, the value of semaphore S must be greater than 0, indicating that the resource is available.

10
00:01:11,000 --> 00:01:17,000
Grabbing the resource is achieved by decrementing the value of the semaphore by 1.

11
00:01:17,000 --> 00:01:21,000
Analogous to the wait(S) command, we have a signal(S) command.

12
00:01:21,000 --> 00:01:28,000
A signal of semaphore S indicates that one additional S resource has become available.

13
00:01:28,000 --> 00:01:32,000
The signal(S) command increments the value of S by 1.

14
00:01:32,000 --> 00:01:40,000
The result of this is that a process that is waiting on S will now be able to grab it and proceed with the next line of code.

15
00:01:40,000 --> 00:01:46,000
Now, lets consider two processes, P1 and P2, that run concurrently.

16
00:01:46,000 --> 00:01:51,000
P1 has two sections of code where section A is followed by section B.

17
00:01:51,000 --> 00:01:56,000
Similarly, P2 has two sections which are C followed by D.

18
00:01:56,000 --> 00:02:06,000
Within each process execution proceeds sequentially, so we are guaranteed that A will always precede B, and C will always precede D.

19
00:02:06,000 --> 00:02:12,000
Let's also assume that there is no looping and that each process runs exactly once.

20
00:02:12,000 --> 00:02:20,000
We want to consider how we can make use of different semaphores to ensure any necessary precedence constraints in the code.

21
00:02:20,000 --> 00:02:28,000
Suppose that the constraint that we need to satisfy is that the section B code completes before the section C code begins execution.

22
00:02:28,000 --> 00:02:36,000
We can achieve this using semaphore S by first initializing the semaphore to 0 in shared memory.

23
00:02:36,000 --> 00:02:46,000
Next, in order to ensure that section C code does not begin running too early, we add a wait(S) call before the section C code.

24
00:02:46,000 --> 00:02:52,000
As long as S = 0, the code in process P2 will not get to run.

25
00:02:52,000 --> 00:03:00,000
P1 on the other hand, will not be constrained in this way, so section A code can begin running right away.

26
00:03:00,000 --> 00:03:05,000
Since section B follows section A, it will be executed after section A.

27
00:03:05,000 --> 00:03:16,000
Once B completes, process P1 needs to signal our semaphore to indicate that it is now okay for process P2 to begin its execution.

28
00:03:16,000 --> 00:03:23,000
The signal(S) call will set S = 1, which will allow P2 to finally move beyond the wait(S) command.

29
00:03:23,000 --> 00:03:35,000
Next, lets consider a slightly more complicated constraint where section D precedes section A, OR section B precedes section C.

30
00:03:35,000 --> 00:03:39,000
In other words, P1 and P2 cannot overlap.

31
00:03:39,000 --> 00:03:44,000
One has to run followed by the other but either of them can be the one to run first.

32
00:03:44,000 --> 00:03:50,000
To achieve this we want to use our S semaphore as a mutual exclusion semaphore.

33
00:03:50,000 --> 00:03:59,000
A mutual exclusion semaphore, or mutex, ensures that only one complete block of code can run at a time without getting interrupted.

34
00:03:59,000 --> 00:04:08,000
This can be achieved by initializing our semaphore S to 1 and having a wait(S) statement at the top of both processes.

35
00:04:08,000 --> 00:04:14,000
Since S is initialized to 1, only one of the two processes will be able to grab the S semaphore.

36
00:04:14,000 --> 00:04:18,000
Whichever process happens to grab it first is the one that will run first.

37
00:04:18,000 --> 00:04:27,000
There is one last piece of code we need to add to complete our requirements which is that at the end of both processes' code, we must signal(S).

38
00:04:27,000 --> 00:04:37,000
If we do not signal(S) then only the process that happened to grab the S semaphore first will get to run while the other is stuck waiting for the S semaphore.

39
00:04:37,000 --> 00:04:46,000
If at the end of the process, we signal S, then S gets incremented back to 1 thus allowing the next process to execute.

40
00:04:46,000 --> 00:04:53,000
Note that because this code does not loop, there is no concern about the first process grabbing the S semaphore again.

41
00:04:53,000 --> 00:04:57,000
Finally, lets consider one last set of constraints.

42
00:04:57,000 --> 00:05:07,000
In this case, we want to ensure that the first section of both processes P1 and P2 run before the second section of processes P1 and P2.

43
00:05:07,000 --> 00:05:12,000
In other words A must precede B and D, and C must precede B and D.

44
00:05:12,000 --> 00:05:21,000
The constraint that A must precede B, and C must precede D is satisfied by default because the code is always executed in order.

45
00:05:21,000 --> 00:05:27,000
This means that our constraint reduces to A preceding D, and C preceding B.

46
00:05:27,000 --> 00:05:35,000
To achieve this, we need to use two semaphores, say S and T and initialize them to 0.

47
00:05:35,000 --> 00:05:47,000
After the first section of a process completes, it should signal to the other process that it may begin its second section of code provided that it has already completed its first section of code.

48
00:05:47,000 --> 00:05:56,000
To ensure that it has already completed its first section of code, we place the signal calls between the two sections of code in each process.

49
00:05:56,000 --> 00:06:06,000
In addition to signaling the other process that it may proceed, each of the processes needs to wait for the semaphore that the other process is signaling.

50
00:06:06,000 --> 00:06:14,000
This combination of signal and wait ensures that sections A and C of the code will run before sections B and D.

51
00:06:14,000 --> 00:06:25,000
Since the semaphores are initialized to 0, the wait(S) will not complete until P1 calls signal(S) at which point it has already completed section A.

52
00:06:25,000 --> 00:06:35,000
Similarly, the wait(T) will not complete until P2 calls signal(T) at which point it has already completed section C.

53
00:06:35,000 --> 00:06:43,000
So once the processes can get past their wait commands, we are guaranteed that both first sections of code have already run.

54
00:06:43,000 --> 00:06:52,000
We have also not forced any additional constraints by requiring A to run before C or C to run before A, and so on.

55
00:06:52,000 --> 00:07:00,000
Of course we could have swapped our use of the S and T semaphores and ended up with exactly the same behavior.

56
00:07:00,000 --> 00:07:05,000
Note, however, that we cannot swap the signal and wait commands around.

57
00:07:05,000 --> 00:07:13,000
If we tried to call wait before signal, then both processes would get deadlocked waiting for a semaphore that never gets signaled.

58
00:07:13,000 --> 00:07:31,000
This highlights the fact that when using semaphores you must always be very careful to not only worry about satisfying the desired requirements, but also ensuring that there is no possibility of ending up in a deadlock situation where one or more processes can never run to completion.

