0
00:00:00,000 --> 00:00:03,000
Let's finish up by looking at two extended examples.

1
00:00:03,000 --> 00:00:11,000
The scenario for both examples is the control system for the International Space Station, which has to handle three recurring tasks:

2
00:00:11,000 --> 00:00:18,000
supply ship guidance (SSG), gyroscope control (G), and cabin pressure (CP).

3
00:00:18,000 --> 00:00:28,000
For each device, the table shows us the time between successive requests (the period), the service time for each request, and the service deadline for each request.

4
00:00:28,000 --> 00:00:33,000
We'll first analyze the system assuming that it's using a weak priority system.

5
00:00:33,000 --> 00:00:41,000
First question: What is the maximum service time for the cabin pressure task that still allows all constraints to be met?

6
00:00:41,000 --> 00:00:54,000
Well, the SSG task has a maximum allowable latency of 20 ms, i.e., it's service routine must start execution within 20 ms if it is to meet its 25 ms deadline.

7
00:00:54,000 --> 00:01:01,000
The G task has a maximum allowable latency of 10 ms if it's to meet its deadline.

8
00:01:01,000 --> 00:01:09,000
So no other handler can take longer than 10 ms to run or the G task will miss its deadline.

9
00:01:09,000 --> 00:01:14,000
2. Give a weak priority ordering that meets the constraints.

10
00:01:14,000 --> 00:01:26,000
Using the earliest deadline strategy discussed earlier, the priority would be G with the highest priority, SSG with the middle priority, and CP with the lowest priority.

11
00:01:26,000 --> 00:01:31,000
3. What fraction of time will the processor spend idle?

12
00:01:31,000 --> 00:01:38,000
We need to compute the fraction of CPU cycles needed to service the recurring requests for each task.

13
00:01:38,000 --> 00:01:45,000
SSG takes 5/30 = 16.67% of the CPU cycles.

14
00:01:45,000 --> 00:01:49,000
G takes 10/40 = 25% of the CPU cycles.

15
00:01:49,000 --> 00:01:54,000
And CP takes 10/100 = 10% of the CPU cycles.

16
00:01:54,000 --> 00:48:33,000
So servicing the task requests takes 51.67% of the cycles, leaving

17
00:02:02,000 --> 00:02:07,000
So the astronauts will be able to play Minecraft in their spare time :)

18
00:02:07,000 --> 00:02:13,000
4. What is the worst-case delay for each task until completion of its service routine?

19
00:02:13,000 --> 00:02:25,000
Each task might have to wait for the longest-running lower-priority handler to complete plus the service times of any other higher-priority tasks plus, of course, its own service time.

20
00:02:25,000 --> 00:02:37,000
SSG has the lowest priority, so it might have to wait for CP and G to complete (a total of 20 ms), then add its own service time (5 ms).

21
00:02:37,000 --> 00:02:42,000
So it's worst-case completion time is 25 ms after the request.

22
00:02:42,000 --> 00:02:52,000
G might to wait for CP to complete (10 ms), then add its own service time (10 ms) for a worst-case completion time of 20 ms.

23
00:02:52,000 --> 00:03:06,000
CP might have to wait for SSG to finish (5 ms), then wait for G to run (10 ms), then add its own service time (10 ms) for a worst-case completion time of 25 ms.

24
00:03:06,000 --> 00:03:12,000
Let's redo the problem, this timing assuming a strong priority system where, as before,

25
00:03:12,000 --> 00:03:18,000
G has the highest priority, SSG the middle priority, and CP the lowest priority.

26
00:03:18,000 --> 00:03:24,000
What is the maximum service time for CP that still allows all constraints to be met?

27
00:03:24,000 --> 00:03:35,000
This calculation is different in a strong priority system, since the service time of CP is no longer constrained by the maximum allowable latency of the higher-priority tasks --

28
00:03:35,000 --> 00:03:38,000
they'll simply preempt CP when they need to run!

29
00:03:38,000 --> 00:03:49,000
Instead we need to think about how much CPU time will be used by the SSG and G tasks in the 100 ms interval between the CP request and its deadline.

30
00:03:49,000 --> 00:04:02,000
In a 100 ms interval, there might be four SSG requests (at times 0, 30, 60, and 90) and three G requests (at times 0, 40, and 80).

31
00:04:02,000 --> 00:04:07,000
Together these requests require a total of 50 ms to service.

32
00:04:07,000 --> 00:04:14,000
So the service time for CP can be up 50 ms and still meet the 100 ms deadline.

33
00:04:14,000 --> 00:04:19,000
2. What fraction of the time will the processor spend idle?

34
00:04:19,000 --> 00:04:26,000
Assuming a 50 ms service time for CP, it now consumes 50% of the CPU.

35
00:04:26,000 --> 00:04:37,000
The other request loads are as before, so 91.67% of the CPU cycles will be spent servicing requests, leaving 8.33% of idle time.

36
00:04:37,000 --> 00:04:41,000
3. What is the worst-case completion time for each task?

37
00:04:41,000 --> 00:04:52,000
The G task has the highest priority, so its service routine runs immediately after the request is received and its worst-case completion time is exactly its service time.

38
00:04:52,000 --> 00:05:01,000
In the 25 ms interval between an SSG request and its deadline, there might be at most one G request that will preempt execution.

39
00:05:01,000 --> 00:05:09,000
So the worst-case completion time is one G service time (10 ms) plus the SSG service time (5 ms).

40
00:05:09,000 --> 00:05:20,000
Finally, from the calculation for problem 1, we chose the service time for the CP task so that it will complete just at its deadline of 100 ms,

41
00:05:20,000 --> 00:05:24,000
taking into account the service time for multiple higher-priority requests.

42
00:05:24,000 --> 00:05:27,000
We covered a lot of ground in this lecture!

43
00:05:27,000 --> 00:05:34,000
We saw that the computation needed for user-mode programs to interact with external devices was split into two parts.

44
00:05:34,000 --> 00:05:42,000
On the device-side, the OS handles device interrupts and performs the task of moving data between kernel buffers and the device.

45
00:05:42,000 --> 00:05:49,000
On the application side, user-mode programs access the information via SVC calls to the OS.

46
00:05:49,000 --> 00:05:58,000
We worried about how to handle SVC requests that needed to wait for an I/O event before the request could be satisfied.

47
00:05:58,000 --> 00:06:08,000
Ultimately we came up with a sleep/wakeup mechanism that suspends execution of the process until the some interrupt routine signals that the needed information has arrived,

48
00:06:08,000 --> 00:06:11,000
causing the sleeping process to marked as active.

49
00:06:11,000 --> 00:06:18,000
Then the SVC is retried the next time the now active process is scheduled for execution.

50
00:06:18,000 --> 00:06:24,000
We discussed hard real-time constraints with their latencies, service times and deadlines.

51
00:06:24,000 --> 00:06:30,000
Then we explored the implementation of interrupt systems using both weak and strong priorities.

52
00:06:30,000 --> 00:06:37,000
Real-life computer systems usually implement strong priorities and support a modest number of priority levels,

53
00:06:37,000 --> 00:06:43,000
using a weak priority system to deal with multiple devices assigned to the same strong priority level.

54
00:06:43,000 --> 00:06:51,000
This seems to work quite well in practice, allowing the systems to meet the variety of real-time constraints imposed by their I/O devices.

